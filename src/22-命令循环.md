# 22 命令循环

当您运行 `Emacs` 时，它几乎立即进入编辑器命令循环。这个循环读取键序列，执行它们的定义，并显示结果。在本章中，我们将描述这些事情是如何完成的，以及允许 `Lisp` 程序完成这些事情的子例程。


<a id="org2368bdd"></a>

## 22.1 命令循环概述

命令循环必须做的第一件事是读取一个键序列，这是一个转换为命令的输入事件序列。它通过调用函数 `read-key-sequence` 来做到这一点。Lisp 程序也可以调用这个函数（参见按键序列输入）。他们还可以使用 `read-key` 或 `read-event` 读取较低级别的输入（请参阅Reading One Event），或使用discard-input 丢弃待处理的输入（请参阅Miscellaneous Event Input Features）。

键序列通过当前活动的键映射转换为命令。有关如何完成此操作的信息，请参阅 `Key Lookup` 。结果应该是键盘宏或交互式可调用函数。如果键是 `Mx` ，那么它会读取另一个命令的名称，然后调用它。这是通过命令 `execute-extended-command` 完成的（请参阅交互式调用）。

在执行命令之前，Emacs 会运行 `undo-boundary` 来创建一个 `undo` 边界。请参阅维护撤消列表。

为了执行一个命令，Emacs 首先通过调用 `command-execute` 来读取它的参数（参见交互式调用）。对于用 `Lisp` 编写的命令，交互式规范说明了如何读取参数。这可以使用前缀参数（参见前缀命令参数）或者可以在小缓冲区中读取提示（参见小缓冲区）。例如，命令 `find-file` 有一个交互式规范，它说使用 `minibuffer` 读取文件名。find-file 的函数体不使用 `minibuffer` ，所以如果你从 `Lisp` 代码中调用 `find-file` 作为一个函数，你必须提供文件名字符串作为一个普通的 `Lisp` 函数参数。

如果命令是键盘宏（即，字符串或向量），Emacs 使用 `execute-kbd-macro` 执行它（请参阅键盘宏）。

    Variable: pre-command-hook ¶

这个普通的钩子在执行每个命令之前由编辑器命令循环运行。此时，this-command 包含即将运行的命令，last-command 描述了上一条命令。请参阅命令循环中的信息。

    Variable: post-command-hook ¶

这个正常的钩子由编辑器命令循环在执行每个命令后运行（包括由于退出或错误而提前终止的命令）。此时this-command指的是刚刚运行的命令，last-command指的是之前的命令。

当 `Emacs` 第一次进入命令循环时（此时 `this-command` 和 `last-command` 都是 `nil` ），这个钩子也会运行。

运行 `pre-command-hook` 和 `post-command-hook` 时会抑制退出。如果在执行这些钩子之一时发生错误，它不会终止钩子的执行；取而代之的是，错误被静音，并且发生错误的函数被从钩子中删除。

进入 `Emacs` 服务器的请求（参见 `GNU Emacs` 手册中的 `Emacs` 服务器）运行这两个钩子，就像键盘命令一样。


<a id="orgb5bd2db"></a>

## 22.2 定义命令

特殊形式 `interactive` 将 `Lisp` 函数转换为命令。交互表单必须位于函数体的顶层，通常作为函数体的第一个表单；这适用于 `lambda` 表达式（请参阅 `Lambda` 表达式）和 `defun` 形式（请参阅定义函数）。这个表单在函数的实际执行过程中什么都不做；它的存在作为一个标志，告诉 `Emacs` 命令循环该函数可以交互调用。交互形式的参数指定应该如何读取交互调用的参数。

或者，可以在函数符号的交互形式属性中指定交互形式。此属性的非 `nil`  值优先于函数体本身中的任何交互形式。这个功能很少使用。

有时，一个函数只打算以交互方式调用，而不是直接从 `Lisp` 调用。在这种情况下，给函数一个非 `nil`  仅交互属性，直接或通过声明（请参阅声明表单）。如果从 `Lisp` 调用命令，这会导致字节编译器发出警告。describe-function 的输出将包含类似的信息。该属性的值可以是：一个字符串，字节编译器将直接在其警告中使用该字符串（它应该以句点结尾，而不是以大写字母开头，例如， `use (system-name) instead.` ） `; ~ 吨；任何其他符号，它应该是在 ~Lisp` 代码中使用的替代函数。

泛型函数（参见泛型函数）不能通过向它们添加交互形式来转换为命令。


<a id="orge4f576f"></a>

### 22.2.1 使用 ~interactive

~ 本节介绍如何编写使 `Lisp` 函数成为交互式可调用命令的交互式表单，以及如何检查命令的交互式表单。

    Special Form: interactive &optional arg-descriptor &rest modes ¶

这种特殊形式声明一个函数是一个命令，因此可以交互调用它（通过 `Mx` 或通过输入绑定到它的键序列）。参数 `arg-descriptor` 声明了在交互调用命令时如何计算命令的参数。

一个命令可以像任何其他函数一样从 `Lisp` 程序中调用，但是调用者提供了参数并且 `arg-descriptor` 没有任何效果。

交互式表单必须位于函数体的顶层，或函数符号的交互式表单属性中（请参阅符号属性）。它之所以有效果，是因为命令循环在调用函数之前会查找它（请参阅交互式调用）。一旦函数被调用，它的所有主体形式都会被执行；此时，如果交互形式出现在正文中，则该形式直接返回 `nil` ，甚至不计算其参数。

模式列表允许指定该命令要使用的模式。有关指定模式的效果以及何时使用它的更多详细信息，请参阅为命令指定模式。

按照惯例，您应该将交互表单放在函数体中，作为第一个顶级表单。如果交互形式符号属性和函数体中都存在交互形式，则前者优先。交互式表单符号属性可用于将交互式表单添加到现有函数，或更改其参数的交互式处理方式，而无需重新定义函数。

参数 `arg-descriptor` 有三种可能性：

它可以省略或为零；然后调用不带参数的命令。如果命令需要一个或多个参数，这会很快导致错误。
它可能是一个字符串；它的内容是由换行符分隔的一系列元素，每个参数一个。每个元素都包含一个代码字符（请参阅交互式代码字符），可选地后跟一个提示（一些代码字符使用而一些忽略）。这是一个例子：

    (interactive "P\nbFrobnicate buffer: ")

代码字母 `P` 将命令的第一个参数设置为原始命令前缀（请参阅前缀命令参数）。'bFrobnicate buffer:' 提示用户使用 `'Frobnicate buffer:'` 输入现有缓冲区的名称，该名称将成为第二个也是最后一个参数。

提示字符串可以使用 `'%'` 在提示中包含以前的参数值（从第一个参数开始）。这是使用 `format-message` 完成的（请参阅格式化字符串）。例如，您可以通过以下方式读取现有缓冲区的名称，然后为该缓冲区提供新名称：

    (interactive "bBuffer to rename: \nsRename buffer %s to: ")

如果 `'*'` 出现在字符串的开头，则如果缓冲区是只读的，则会发出错误信号。

如果 `'@'` 出现在字符串的开头，并且如果用于调用命令的键序列包括任何鼠标事件，则在运行命令之前选择与这些事件中的第一个事件关联的窗口。

如果 `'^'` 出现在字符串的开头，并且如果命令是通过 `shift-translation` 调用的，则在命令运行之前设置标记并临时激活该区域，或者扩展一个已经激活的区域。如果在没有移位转换的情况下调用了该命令，并且该区域暂时处于活动状态，请在运行该命令之前停用该区域。Shift-translation 由 `shift-select-mode` 在用户级别控制；请参阅 `GNU Emacs` 手册中的 `Shift` 选择。

您可以同时使用 `*` 、 `@` 和 `^` ；顺序无关紧要。参数的实际读取由提示字符串的其余部分控制（从不是 `*` 、 `@` 或 `^` 的第一个字符开始）。
它可能是一个不是字符串的 `Lisp` 表达式；那么它应该是一个经过评估以获取要传递给命令的参数列表的表单。通常这种形式会调用各种函数来读取用户的输入，最常见的是通过 `minibuffer` （参见 `Minibuffers` ）或直接从键盘（参见 `Reading Input` ）。

提供点或标记作为参数值也很常见，但如果您这样做并读取输入（无论是否使用迷你缓冲区），请务必在读取后获取点或标记的整数值。当前缓冲区可能正在接收子进程输出；如果在命令等待输入时子进程输出到达，它可以重新定位点和标记。

下面是一个不该做什么的例子：

    (interactive
     (list (region-beginning) (region-end)
           (read-string "Foo: " nil 'my-history)))

以下是如何避免该问题，通过在读取键盘输入后检查点和​​标记：

    (interactive
     (let ((string (read-string "Foo: " nil 'my-history)))
       (list (region-beginning) (region-end) string)))

警告：参数值不应包含任何无法打印然后读取的数据类型。一些工具将命令历史保存在一个文件中，以便在后续会话中读取；如果命令的参数包含使用 `'#<...>'` 语法打印的数据类型，则这些工具将不起作用。

然而，也有一些例外：可以使用一组有限的表达式，例如 `(point)` 、(mark)、(region-beginning) 和 `(region-end)` ，因为 `Emacs` 会特别识别它们并将表达式（而不是它的值）到命令历史记录中。要查看您编写的表达式是否是这些异常之一，请运行命令，然后检查 `(car command-history)` 。

    Function: interactive-form function ¶

该函数返回函数的交互形式。如果 `function` 是一个交互式可调用函数（请参阅交互式调用），则该值是命令的交互式形式（交互式规范），它指定如何计算其参数。否则，该值为 `nil` 。如果 `function` 是一个符号，则使用其函数定义。

脚注
(14)

有些元素实际上提供了两个参数。


<a id="orgf368855"></a>

### 22.2.2 代码字符 ~interactive

~ 下面的代码字符描述包含一些关键词，这里定义如下：

    Completion ¶

提供完成。TAB、SPC 和 `RET` 执行名称完成，因为参数是使用完成读取（请参阅完成）读取的。?  显示可能完成的列表。

    Existing

需要现有对象的名称。不接受无效名称；如果当前输入无效，则退出 `minibuffer` 的命令不会退出。

    Default ¶

如果用户在 `minibuffer` 中没有输入文本，则使用某种默认值。默认值取决于代码字符。

    No I/O

此代码字母在不读取任何输入的情况下计算参数。因此，它不使用提示字符串，并且您提供的任何提示字符串都将被忽略。

即使代码字母不使用提示字符串，如果它不是字符串中的最后一个代码字符，则必须在其后加上换行符。

    Prompt

提示符紧跟在代码字符之后。提示以字符串结尾或换行符结束。

    Special

此代码字符仅在交互式字符串的开头有意义，它不寻找提示符或换行符。它是一个单一的、孤立的角色。

以下是用于交互的代码字符描述：

    ‘*’

如果当前缓冲区是只读的，则发出错误信号。特别的。

    ‘@’

在调用此命令的按键序列中选择第一个鼠标事件中提到的窗口。特别的。

    ‘^’

如果命令是通过 `shift-translation` 调用的，则在命令运行之前设置标记并临时激活该区域，或者扩展一个已经处于活动状态的区域。如果在没有移位转换的情况下调用了该命令，并且该区域暂时处于活动状态，请在运行该命令之前停用该区域。特别的。

    ‘a’

函数名（即满足 `fboundp` 的符号）。现有，完成，提示。

    ‘b’

现有缓冲区的名称。默认情况下，使用当前缓冲区的名称（请参阅缓冲区）。现有、完成、默认、提示。

    ‘B’

缓冲区名称。缓冲区不需要存在。默认情况下，使用最近使用的缓冲区的名称，而不是当前缓冲区。完成，默认，提示。

    ‘c’

一个人物。光标不会移动到回波区域。迅速的。

    ‘C’

命令名称（即满足 `commandp` 的符号）。现有，完成，提示。

    ‘d’ ~¶

~ 点的位置，作为整数（请参阅点）。没有 `I/O` 。

    ‘D’

一个目录。默认值是当前缓冲区的当前默认目录，default-directory（请参阅扩展文件名的函数）。现有、完成、默认、提示。

    ‘e’

调用命令的键序列中的第一个或下一个非键盘事件。更准确地说，'e' 获取列表事件，因此您可以查看列表中的数据。请参阅输入事件。没有 `I/O` 。

您将 `e` 用于鼠标事件和特殊系统事件（请参阅其他系统事件）。命令接收的事件列表取决于事件。请参阅输入事件，其中描述了相应小节中每个事件的列表形式。

您可以在单个命令的交互式规范中多次使用 `e` 。如果调用命令的键序列有 `n` 个列表事件，则第 `n` 个 `e` 提供第 `n` 个此类事件。不是列表的事件，例如功能键和 `ASCII` 字符，在涉及 `'e'` 的地方不计算在内。

    ‘f’

现有文件的文件名（请参阅文件名）。默认目录是默认目录。现有、完成、默认、提示。

    ‘F’

一个文件名。该文件不必存在。完成，默认，提示。

    ‘G’

一个文件名。该文件不必存在。如果用户只输入一个目录名，那么该值就是那个目录名，没有添加目录中的文件名。完成，默认，提示。

    ‘i’

一个无关紧要的论点。此代码始终提供 `nil`  作为参数的值。没有 `I/O` 。

    ‘k’

键序列（请参阅键序列）。这会一直读取事件，直到在当前键映射中找到命令（或未定义的命令）。键序列参数表示为字符串或向量。光标不会移动到回波区域。迅速的。

如果 `k` 读取了一个以向下事件结尾的键序列，它也会读取并丢弃随后的向上事件。您可以使用 `U` 代码字符访问该向上事件。

这种输入由 `describe-key` 和 `global-set-key` 等命令使用。

    ‘K’

表单上的键序列，可用作定义键等函数的输入。这类似于 `k` ，除了它对于键序列中的最后一个输入事件抑制了通常用于（必要时）将未定义键转换为已定义键（请参阅键序列输入）的转换，所以这个form 通常在提示输入要绑定到命令的新键序列时使用。

    ‘m’ ~¶

~ 标记的位置，以整数形式。没有 `I/O` 。

    ‘M’

任意文本，使用当前缓冲区的输入方法在 `minibuffer` 中读取，并以字符串形式返回（参见 `GNU Emacs` 手册中的输入方法）。迅速的。

    ‘n’

一个数字，用 `minibuffer` 读取。如果输入不是数字，则用户必须重试。'n' 从不使用前缀参数。迅速的。

    ‘N’

数字前缀参数；但如果没有前缀参数，则读取与 `n` 相同的数字。该值始终是一个数字。请参阅前缀命令参数。迅速的。

    ‘p’ ~¶

~ 数字前缀参数。（请注意，这个 `p` 是小写的。）无 `I/O` 。

    ‘P’ ~¶

~ 原始前缀参数。（请注意，这个 `P` 是大写的。）无 `I/O` 。

    ‘r’ ~¶

~ 点和标记，作为两个数字参数，最小的在前。这是唯一指定两个连续参数而不是一个的代码字母。如果在调用命令时当前的缓冲区中没有设置标记，这将发出错误信号。如果 `Transient Mark` 模式打开（参见 `The Mark` ）——默认情况下——并且用户选项 `mark-even-if-inactive` 为 `nil` ，即使设置了标记，Emacs 也会发出错误信号，但处于非活动状态。没有 `I/O` 。

    ‘s’

任意文本，在 `minibuffer` 中读取并作为字符串返回（请参阅Reading Text Strings with the Minibuffer）。使用 `Cj` 或 `RET` 终止输入。（Cq 可用于在输入中包含这些字符中的任何一个。） `提` 示。

    ‘S’

在 `minibuffer` 中读取其名称的实习符号。使用 `Cj` 或 `RET` 终止输入。通常终止符号的其他字符（例如，空格、括号和方括号）在此不这样做。迅速的。

    ‘U’

一个键序列或零。可以在 `k` 或 `K` 参数之后使用，以获取在 `k` 或 `K` 读取向下事件后丢弃的向上事件（如果有）。如果没有丢弃任何向上事件，则 `U` 提供 `nil`  作为参数。没有 `I/O` 。

    ‘v’

声明为用户选项的变量（即满足谓词 `custom-variable-p` ）。这使用 `read-variable` 读取变量。请参阅读变量的定义。现有，完成，提示。

    ‘x’

一个 `Lisp` 对象，以其读取语法指定，以 `Cj` 或 `RET` 终止。不评估对象。请参阅使用 `Minibuffer` 读取 `Lisp` 对象。迅速的。

    ‘X’ ~¶

Lisp~ 表单的值。'X' 和 `'x'` 一样读取，然后计算表单，使其值成为命令的参数。迅速的。

    ‘z’

编码系统名称（符号）。如果用户输入 `null` 输入，则参数值为 `nil` 。请参阅编码系统。完成，现有，提示。

    ‘Z’

编码系统名称（符号）——但仅当此命令具有前缀参数时。没有前缀参数，'Z' 提供 `nil`  作为参数值。完成，现有，提示。


<a id="orgafba2f3"></a>

### 22.2.3 使用示例 ~interactive

~ 以下是一些交互式示例：

    (defun foo1 ()              ; foo1 takes no arguments,
        (interactive)           ;   just moves forward two words.
        (forward-word 2))
         ⇒ foo1
    
    
    (defun foo2 (n)             ; foo2 takes one argument,
        (interactive "^p")      ;   which is the numeric prefix.
    			    ; under shift-select-mode,
    			    ;   will activate or extend region.
        (forward-word (* 2 n)))
         ⇒ foo2
    
    
    (defun foo3 (n)             ; foo3 takes one argument,
        (interactive "nCount:") ;   which is read with the Minibuffer.
        (forward-word (* 2 n)))
         ⇒ foo3
    
    
    (defun three-b (b1 b2 b3)
      "Select three existing buffers.
    Put them into three windows, selecting the last one."
    
        (interactive "bBuffer1:\nbBuffer2:\nbBuffer3:")
        (delete-other-windows)
        (split-window (selected-window) 8)
        (switch-to-buffer b1)
        (other-window 1)
        (split-window (selected-window) 8)
        (switch-to-buffer b2)
        (other-window 1)
        (switch-to-buffer b3))
         ⇒ three-b
    
    (three-b "*scratch*" "declarations.texi" "*mail*")
         ⇒ nil


<a id="org32802d2"></a>

### 22.2.4 指定命令模式

Emacs 中的许多命令都是通用的，与任何特定模式无关。例如，Mx kill-region 几乎可以在任何具有可编辑文本的模式下使用，而显示信息的命令（如 `Mx` 列表缓冲区）几乎可以在任何上下文中使用。

然而，许多其他命令专门与模式相关联，并且在该上下文之外没有任何意义。例如，如果在 `Dired` 缓冲区之外使用， `Mx dired-diff` 只会发出错误信号。

因此，Emacs 有一种机制来指定命令 `属于` 什么模式（或模式）：

    (defun dired-diff (...)
      ...
      (interactive "p" dired-mode)
      ...)

这会将命令标记为仅适用于 `dired-mode` （或从 `dired-mode` 派生的任何模式）。可以将任意数量的模式添加到交互式表单中。

指定模式会影响 `MSx` 中的命令完成（execute-extended-command-for-buffer，请参阅交互式调用）。它还可能影响 `Mx` 中的完成，具体取决于 `read-extended-command-predicate` 的值。

例如，当使用 `command-completion-default-include-p` 谓词作为 `read-extended-command-predicate` 的值时，Mx 不会列出已标记为适用于特定模式的命令（除非您在当然是使用该模式的缓冲区）。这适用于主要和次要模式。（相比之下，MSx 总是从补全候选中省略不适用的命令。）

默认情况下，read-extended-command-predicate 为 `nil` ，Mx 中的完成会列出与用户键入的内容匹配的所有命令，无论这些命令是否标记为适用于当前缓冲区的模式。

将命令标记为适用于模式也会使 `Ch m` 列出这些命令（如果它们未绑定到任何键）。

如果使用这个扩展的交互表单不方便（因为代码应该在不支持扩展交互表单的旧版本的 `Emacs` 中工作），可以使用以下等效声明（请参阅声明表单）：

    (declare (modes dired-mode))

用模式标记哪些命令在某种程度上是个人喜好问题，但显然不能在模式之外工作的命令应该被标记。这包括如果从其他地方调用将发出错误信号的命令，也包括从意外模式调用时具有破坏性的命令。（这通常包括为特殊（即非编辑）模式编写的大多数命令。）

某些命令可能是无害的，并且在从其他模式调用时 `有效` ，但如果它们在其他地方使用实际上没有多大意义，则仍应使用模式标记。例如，许多特殊模式具有退出绑定到 `q` 的缓冲区的命令，并且可能什么都不做，只是发出一条消息，如 `从此模式再见` ，然后调用 `kill-buffer` 。此命令将在任何模式下 `工作` ，但任何人都不太可能真正想要在此特殊模式的上下文之外使用该命令。

许多模式都有一组不同的命令，它们以不同的方式启动模式（例如，eww-open-in-new-buffer 和 `eww-open-file` ）。像这样的命令永远不应该被标记为特定于模式的，因为它们可以由用户从几乎任何上下文中发出。

请注意，在 `Emacs 28.1` 中的本机编译函数中不支持指定命令模式（但在以后的 `Emacs` 版本中已修复此问题）。这意味着本机编译版本也不支持 `read-extended-command-predicate` 。


<a id="orgbe72c20"></a>

### 22.2.5 在命令选项中进行选择

宏define-alternatives 可用于定义通用命令。这些是交互式功能，可以根据用户偏好从几个备选方案中选择其实现。

    Macro: define-alternatives command &rest customizations ¶

定义新的命令命令，一个符号。

当用户第一次运行 `Mx` 命令 `RET` 时，Emacs 会提示使用该命令的真实形式，并通过自定义变量的方式记录选择。使用前缀参数重复这个选择替代的过程。

变量 `command-alternatives` 应该包含一个带有替代命令实现的列表。在设置此变量之前，define-alternatives 无效。

如果定制不是零，它应该由交替的 `defcustom` 关键字（通常是 `:group` 和 `:version` ）和添加到命令替代声明的值组成。


<a id="org735d3d6"></a>

## 22.3 交互调用

在命令循环将键序列转换为命令后，它使用函数 `command-execute` 调用该命令。如果命令是一个函数，command-execute 调用 `call-interactive` ，它读取参数并调用命令。您也可以自己调用这些函数。

请注意，在此上下文中，术语 `命令` 是指可交互调用的函数（或类似函数的对象）或键盘宏。它不是指用于调用命令的键序列（请参阅键映射）。

    Function: commandp object &optional for-call-interactively ¶

如果 `object` 是命令，则此函数返回 `t` 。否则，它返回零。

命令包括字符串和向量（被视为键盘宏）、包含顶级交互形式的 `lambda` 表达式（请参阅使用交互）、由此类 `lambda` 表达式生成的字节码函数对象、声明为交互的自动加载对象（非- `nil`  自动加载的第四个参数），以及一些原始函数。此外，如果符号具有非 `nil`  交互形式属性，或者其函数定义满足 `commandp` ，则将其视为命令。

如果 `for-call-interactively` 不为 `nil` ，则 `commandp` 只为 `call-interactively` 可以调用的对象返回 `t` ——因此，不为键盘宏返回。

有关使用 `commandp` 的实际示例，请参阅访问文档字符串中的文档。

    Function: call-interactively command &optional record-flag keys ¶

该函数调用交互式可调用函数命令，根据其交互式调用规范提供参数。它返回任何命令返回。

例如，如果您有一个具有以下签名的函数：

    (defun foo (begin end)
      (interactive "r")
      ...)

然后说

    (call-interactively 'foo)

将以区域（点和标记）作为参数调用 `foo` 。

如果 `command` 不是函数或不能交互调用（即不是命令），则会发出错误信号。请注意，即使它们被视为命令，也不接受键盘宏（字符串和向量），因为它们不是函数。如果 `command` 是一个符号，则 `call-interactively` 使用它的函数定义。

如果 `record-flag` 不是 `nil` ，则此命令及其参数将无条件添加到 `list command-history` 。否则，只有在使用 `minibuffer` 读取参数时才会添加该命令。请参阅命令历史记录。

如果给定了参数键，则应该是一个向量，它指定在命令查询使用哪些事件来调用它时要提供的事件序列。如果keys被省略或 `nil` ，默认是this-command-keys-vector的返回值。请参阅 `this-command-keys-vector` 的定义。

    Function: funcall-interactively function &rest arguments ¶

此函数的工作方式类似于 `funcall` （请参阅调用函数），但它使调用看起来像一个交互式调用：在函数内部调用 `called-interactively-p` 将返回 `t` 。如果函数不是命令，则调用它时不会发出错误信号。

    Function: command-execute command &optional record-flag keys special ¶

该函数执行命令。参数 `command` 必须满足 `commandp` 谓词；即，它必须是可交互调用的函数或键盘宏。

使用 `execute-kbd-macro` 执行作为命令的字符串或向量。一个函数与记录标志和键参数一起以交互方式传递给调用（见上文）。

如果 `command` 是一个符号，则使用它的函数定义代替它。如果一个具有自动加载定义的符号被声明为代表一个可交互调用的函数，那么它就被视为一个命令。这样的定义是通过加载指定的库然后重新检查符号的定义来处理的。

如果给出参数 `special` ，则表示忽略前缀参数并且不清除它。这用于执行特殊事件（请参阅特殊事件）。

    Command: execute-extended-command prefix-argument ¶

此函数使用完成读取从迷你缓冲区中读取命令名称（请参阅完成）。然后它使用命令执行来调用指定的命令。该命令返回的任何内容都将成为 `execute-extended-command` 的值。

如果该命令要求一个前缀参数，它会收到值前缀参数。如果以交互方式调用execute-extended-command，则当前原始前缀参数用于前缀参数，因此传递给运行的任何命令。

execute-extended-command 是 `Mx` 的正常定义，所以它使用字符串 `'Mx '` 作为提示符。（最好从用于调用 `execute-extended-command` 的事件中获取提示，但实现起来很痛苦。）前缀参数值的描述（如果有）也成为提示的一部分。

    (execute-extended-command 3)
    ---------- Buffer: Minibuffer ----------
    3 M-x forward-word RET
    ---------- Buffer: Minibuffer ----------
         ⇒ t

此命令注意 `read-extended-command-predicate` 变量，该变量可以过滤掉不适用于当前主要模式（或启用的次要模式）的命令。默认情况下，该变量的值为 `nil` ，不会过滤掉任何命令。但是，自定义它以调用函数 `command-completion-default-include-p` 将执行与模式相关的过滤。read-extended-command-predicate 可以是任何谓词函数；它将使用两个参数调用：命令的符号和当前缓冲区。如果在该缓冲区中完成时要包含命令，则 `if` 应返回非零。

    Command: execute-extended-command-for-buffer prefix-argument ¶

这类似于执行扩展命令，但将提供完成的命令限制为与当前主要模式（和启用的次要模式）特别相关的那些命令。这包括使用模式标记的命令（请参阅使用交互），以及绑定到本地活动键盘映射的命令。此命令是 `MSx` 的正常定义（即 `meta shift x` ）。


<a id="org1fbb17c"></a>

## 22.4 区分交互调用

有时，命令应仅针对交互式呼叫显示额外的视觉反馈（例如回显区域中的信息性消息）。有三种方法可以做到这一点。测试是否使用 `call-interactively` 调用函数的推荐方法是给它一个可选参数 `print-message` 并使用交互式规范使其在交互式调用中非 `nil` 。这是一个例子：

    (defun foo (&optional print-message)
      (interactive "p")
      (when print-message
        (message "foo")))

我们使用 `p` 是因为数字前缀参数从不为零。以这种方式定义的函数在从键盘宏调用时会显示消息。

带有附加参数的上述方法通常是最好的，因为它允许调用者说 `将此调用视为交互式` 。但是您也可以通过测试称为交互式-p 来完成这项工作。

    Function: called-interactively-p kind ¶

当使用 `call-interactively` 调用调用函数时，此函数返回 `t` 。

参数种类应该是符号 `interactive` 或符号 `any` 。如果它是交互式的，那么只有当调用是由用户直接进行时，called-interactively-p 才返回 `t` ——例如，如果用户键入了绑定到调用函数的键序列，但如果用户运行了调用的键盘宏则不会返回函数（请参阅键盘宏）。如果 `kind` 是 `any` ，called-interactively-p 为任何类型的交互式调用返回 `t` ，包括键盘宏。

如有疑问，请使用任何；唯一已知的正确使用交互是如果您需要决定是否在函数运行时显示有用的消息。

如果函数是通过 `Lisp` 求值（或使用 `apply` 或 `funcall` ）调用的，则永远不会认为它是交互式调用的。

下面是一个使用 `called-interactively-p` 的例子：

    
    
    (defun foo ()
      (interactive)
      (when (called-interactively-p 'any)
        (message "Interactive!")
        'foo-called-interactively))
    
    
    ;; Type M-x foo.
         -| Interactive!
    
    
    (foo)
         ⇒ nil

这是另一个对比被调用交互 `p` 的直接和间接调用的示例。

    (defun bar ()
      (interactive)
      (message "%s" (list (foo) (called-interactively-p 'any))))
    
    
    ;; Type M-x bar.
         -| (nil t)


<a id="orgbb066a2"></a>

## 22.5 来自命令循环的信息

编辑器命令循环设置几个 `Lisp` 变量来保存它自己和正在运行的命令的状态记录。除了 `this-command` 和 `last-command` 之外，在 `Lisp` 程序中更改这些变量中的任何一个通常都是一个坏主意。

    Variable: last-command ¶

该变量记录了命令循环执行的上一个命令的名称（当前命令之前的命令）。通常，该值是具有函数定义的符号，但这不能保证。

当命令返回命令循环时，从 `this-command` 复制该值，除非该命令为以下命令指定了前缀参数。

此变量始终是当前终端的本地变量，不能是缓冲区本地的。请参阅多个终端。

    Variable: real-last-command ¶

这个变量由 `Emacs` 设置，就像 `last-command` 一样，但不会被 `Lisp` 程序改变。

    Variable: last-repeatable-command ¶

此变量存储不属于输入事件的最近执行的命令。这是命令 `repeat` 将尝试重复，请参阅 `GNU Emacs` 手册中的重复。

    Variable: this-command ¶

该变量记录了编辑器命令循环正在执行的命令的名称。与 `last-command` 一样，它通常是带有函数定义的符号。

命令循环在运行命令之前设置此变量，并在命令完成时将其值复制到 `last-command` （除非命令为以下命令指定了前缀参数）。

一些命令在执行期间设置此变量，作为接下来运行的任何命令的标志。特别是，用于杀死文本的函数将 `this-command` 设置为 `kill-region` ，以便紧随其后的任何杀死命令都知道将被杀死的文本附加到前一个杀死。

如果您不希望某个特定命令在出错的情况下被识别为前一个命令，则必须对该命令进行编码以防止这种情况发生。一种方法是在命令开头将 `this-command` 设置为 `t` ，并在最后将 `this-command` 设置回其正确值，如下所示：

    (defun foo (args…)
      (interactive …)
      (let ((old-this-command this-command))
        (setq this-command t)
        …do the work…
        (setq this-command old-this-command)))

我们没有将 `this-command` 与 `let` 绑定，因为这样会在出错的情况下恢复旧值——在这种情况下，let 的一个特性正是我们想要避免的。

    Variable: this-original-command ¶

这与 `this-command` 具有相同的值，除非发生命令重新映射（请参阅重新映射命令）。在这种情况下，this-command 给出了实际运行的命令（重新映射的结果），而 `this-original-command` 给出了指定运行但重新映射到另一个命令的命令。

    Variable: current-minibuffer-command ¶

this 与 `this-command` 具有相同的值，但在进入 `minibuffer` 时被递归绑定。此变量可用于 `minibuffer` 挂钩等，以确定打开当前 `minibuffer` 会话的命令。

    Function: this-command-keys ¶

此函数返回一个字符串或向量，其中包含调用当前命令的键序列。该命令使用 `read-event` 读取的任何没有超时的事件都会被添加到最后。

但是，如果该命令调用了 `read-key-sequence` ，它会返回最后读取的密钥序列。请参阅按键序列输入。如果序列中的所有事件都是适合字符串的字符，则该值是字符串。请参阅输入事件。

    (this-command-keys)
    ;; Now use C-u C-x C-e to evaluate that.
         ⇒ "^X^E"

    Function: this-command-keys-vector ¶

与 `this-command-keys` 类似，只是它始终以向量形式返回事件，因此您无需处理将输入事件存储在字符串中的复杂性（请参阅将键盘事件放入字符串中）。

    Function: clear-this-command-keys &optional keep-record ¶

此函数清空事件表，以便 `this-command-keys` 返回。除非 `keep-record` 不为零，否则它还会清空函数最近键（请参阅记录输入）随后将返回的记录。这在读取密码后很有用，可以防止密码在某些情况下无意中作为下一个命令的一部分回显。

    Variable: last-nonmenu-event ¶

此变量保存作为键序列的一部分读取的最后一个输入事件，不计算鼠标菜单产生的事件。

这个变量的一个用途是告诉 `x-popup-menu` 在哪里弹出菜单。它也被 `y-or-np` 内部使用（参见 `Yes-or-No Queries` ）。

    Variable: last-command-event ¶

此变量设置为命令循环作为命令的一部分读取的最后一个输入事件。这个变量的主要用途是在 `self-insert-command` 中，它使用它来决定插入哪个字符。

    last-command-event
    ;; Now use C-u C-x C-e to evaluate that.
         ⇒ 5

该值为 `5` ，因为那是 `Ce` 的 `ASCII` 码。

    Variable: last-event-frame ¶

此变量记录最后一个输入事件被定向到哪个帧。通常这是在生成事件时选择的帧，但如果该帧已将输入焦点重定向到另一个帧，则该值是事件被重定向到的帧。请参阅输入焦点。

如果最后一个事件来自键盘宏，则值为宏。


<a id="org62dcae2"></a>

## 22.6 指令后点调整

当 `point` 位于具有 `display` 或 `composition` 属性的文本序列的中间或不可见时，Emacs 无法显示光标。因此，在命令完成并返回命令循环后，如果点在这样的序列内，命令循环通常会将点移动到序列的边缘，从而使该序列实际上是无形的。

命令可以通过设置变量 `disable-point-adjustment` 来禁止此功能：

    Variable: disable-point-adjustment ¶

如果当命令返回命令循环时此变量非零，则命令循环不会检查这些文本属性，并且不会将点移出具有它们的序列。

命令循环在每个命令之前将此变量设置为 `nil` ，因此如果命令设置它，则效果仅适用于该命令。

    Variable: global-disable-point-adjustment ¶

如果将此变量设置为非零值，则将点移出这些序列的功能将完全关闭。


<a id="orgbd5ca01"></a>

## 22.7 输入事件

Emacs 命令循环读取代表键盘或鼠标活动的输入事件序列，或发送到 `Emacs` 的系统事件。键盘活动的事件是字符或符号；其他事件始终是列表。本节详细描述输入事件的表示和含义。

    Function: eventp object ¶

如果 `object` 是输入事件或事件类型，则此函数返回非 `nil` 。

请注意，任何非零符号都可能用作事件或事件类型；eventp 无法区分 `Lisp` 代码是否打算将符号用作事件。


<a id="orgd5e63aa"></a>

### 22.7.1 键盘事件

您可以从键盘获得两种输入：普通键和功能键。普通键对应（可能修改过的）字符；它们生成的事件在 `Lisp` 中表示为字符。字符事件的事件类型是字符本身（一个整数），它可能设置了一些修饰符位；见分类事件。

输入字符事件由 `0` 到 `524287` 之间的基本代码以及任何或所有这些修饰符位组成：

    meta

字符代码中的 `2**27` 位表示按住元键键入的字符。

    control

字符代码中的 `2**26` 位表示非 `ASCII` 控制字符。

ASCII 控制字符（例如 `Ca` ）具有自己的特殊基本代码，因此 `Emacs` 不需要特殊位来指示它们。因此，Ca 的代码仅为 `1` 。

但是如果你键入一个不是ASCII的控制组合，比如用控制键的%，你得到的数值就是%加2\*\*26的代码（假设终端支持非ASCII控制字符），即用第27个位设置。

    shift

字符事件代码中的 `2**25` 位（第 `26` 位）表示按住 `shift` 键键入的 `ASCII` 控制字符。

对于字母，基本代码本身表示大写与小写；对于数字和标点符号，shift 键选择具有不同基本代码的完全不同的字符。为了尽可能保持在 `ASCII` 字符集中，Emacs 避免对这些字符事件使用 `2**25` 位。

但是，ASCII 没有提供区分 `CA` 和 `Ca` 的方法，因此 `Emacs` 在 `CA` 中使用 `2**25` 位而不在 `Ca` 中。

    hyper

字符事件代码中的 `2**24` 位表示按住超级键键入的字符。

    super

字符事件代码中的 `2**23` 位表示按住超级键键入的字符。

    alt

字符事件代码中的 `2**22` 位表示按住 `alt` 键键入的字符。（大多数键盘上标记为 `Alt` 的键实际上被视为元键，而不是这个。）

最好避免在程序中提及特定的位数。要测试字符的修饰符位，请使用函数 `event-modifiers` （请参阅分类事件）。在进行键绑定时，您可以对带有修饰符位的字符（'\C-'、'\M-' 等）使用读取语法。要使用 `define-key` 进行键绑定，您可以使用 `(control hyper ?x)` 之类的列表来指定字符（请参阅更改键绑定）。函数 `event-convert-list` 将此类列表转换为事件类型（请参阅分类事件）。


<a id="org592bac8"></a>

### 22.7.2 功能键

大多数键盘还具有功能键——具有非字符名称或符号的键。功能键在 `Emacs Lisp` 中表示为符号；符号的名称是功能键的标签，小写。例如，按下标记为 `F1` 的键会生成由符号 `f1` 表示的输入事件。

功能键事件的事件类型是事件符号本身。请参阅分类事件。

以下是功能键符号命名约定中的一些特殊情况：

    backspace, tab, newline, return, delete

这些键对应于在大多数键盘上具有特殊键的常见 `ASCII` 控制字符。

在 `ASCII` 中，Ci 和 `TAB` 是同一个字符。如果终端可以区分它们，Emacs 会将区别传达给 `Lisp` 程序，将前者表示为整数 `9` ，将后者表示为符号制表符。

大多数情况下，区分这两者是没有用的。所以通常local-function-key-map（见Keymaps for Translating Sequences of Events）设置为将tab映射到9。因此，字符代码9（字符Ci）的键绑定也适用于tab。对于该组中的其他符号也是如此。函数 `read-char` 同样将这些事件转换为字符。

在 `ASCII` 中，BS 实际上是 `Ch` 。但是退格会转换为字符代码 `127 (DEL)` ，而不是代码 `8 (BS)` 。这是大多数用户喜欢的。

    left, up, right, down

光标方向键

    kp-add, kp-decimal, kp-divide, …

小键盘键（在常规键盘的右侧）。

    kp-0, kp-1, …

带数字的键盘键。

    kp-f1, kp-f2, kp-f3, kp-f4

键盘 `PF` 键。

    kp-home, kp-left, kp-up, kp-right, kp-down

键盘方向键。Emacs 通常会将这些转换为相应的非键盘键 `home` 、left、&#x2026;

    kp-prior, kp-next, kp-end, kp-begin, kp-insert, kp-delete

通常在其他地方找到的键的附加键盘副本。Emacs 通常将这些转换为类似名称的非键盘键。

您可以将修饰键 `ALT` 、CTRL、HYPER、META、SHIFT 和 `SUPER` 与功能键一起使用。表示它们的方法是在符号名称中使用前缀：

    ‘A-’

alt 修饰符。

    ‘C-’

控制修饰符。

    ‘H-’

超级修饰符。

    ‘M-’

元修饰符。

    ‘S-’

移位修饰符。

    ‘s-’

超级修饰符。

因此，按下 `META` 的键 `F3` 的符号是 `M-f3` 。当您使用多个前缀时，我们建议您按字母顺序书写；但在键绑定查找和修改函数的参数中，顺序无关紧要。


<a id="orgf01037d"></a>

### 22.7.3 鼠标事件

Emacs 支持四种鼠标事件：单击事件、拖动事件、按钮按下事件和运动事件。所有鼠标事件都表示为列表。列表的 `CAR` 是事件类型；这说明涉及哪个鼠标按钮，以及使用了哪些修饰键。事件类型还可以区分两次或三次按钮按下（请参阅重复事件）。列表元素的其余部分提供位置和时间信息。

对于键查找，只有事件类型很重要：相同类型的两个事件必须运行相同的命令。该命令可以使用 `e` 交互代码访问这些事件的完整值。请参阅代码字符以进行交互。

以鼠标事件开始的键序列是使用鼠标所在窗口中缓冲区的键映射读取的，而不是当前缓冲区。这并不意味着在窗口中单击会选择该窗口或其缓冲区——这完全在键序列的命令绑定的控制之下。


<a id="org0229351"></a>

### 22.7.4 点击事件

当用户按下鼠标按钮并在同一位置释放它时，会生成一个单击事件。根据您的窗口系统报告鼠标滚轮事件的方式，转动鼠标滚轮可以生成鼠标单击或鼠标滚轮事件。所有鼠标事件共享相同的格式：

    (event-type position click-count)

    event-type

这是一个符号，表示使用了哪个鼠标按钮。它是鼠标 `1` 、鼠标 `2` 、&#x2026; 的符号之一，其中按钮从左到右编号。对于鼠标滚轮事件，它可以是上滚轮或下滚轮。

您还可以使用前缀 `A-` 、 `C-` 、 `H-` 、 `M-` 、 `S-` 和 `s-` 作为修饰符 `alt` 、control、hyper、meta、shift 和 `super` ，就像你会用功能键。

该符号也用作事件的事件类型。键绑定按类型描述事件；因此，如果有 `mouse-1` 的键绑定，则该绑定将应用于事件类型为 `mouse-1` 的所有事件。

    position ¶

这是一个鼠标位置列表，指定鼠标事件发生的位置；详情见下文。

    click-count

这是迄今为止快速重复按下同一鼠标按钮的次数或重复转动滚轮的次数。请参阅重复事件。

要在鼠标事件的位置槽中访问鼠标位置列表的内容，通常应该使用访问鼠标事件中记录的函数。

列表的显式格式取决于事件发生的位置。对于文本区域、模式行、标题行、制表行或边缘或边缘区域中的单击，鼠标位置列表具有以下形式

    (window pos-or-area (x . y) timestamp
     object text-pos (col . row)
     image (dx . dy) (width . height))

这些列表元素的含义如下：

    window

发生鼠标事件的窗口。

    pos-or-area

点击字符在文本区域的缓冲位置；或者，如果事件在文本区域之外，则为它发生的窗口区域。它是模式行、标题行、制表行、垂直行、左边距、右边距、左边缘或右边缘的符号之一。

在一种特殊情况下，pos-or-area 是一个包含符号（上面列出的符号之一）的列表，而不仅仅是符号。这发生在 `Emacs` 注册事件的假想前缀键之后。请参阅按键序列输入。

    x, y

事件的相对像素坐标。对于窗口文本区域中的事件，坐标原点 `(0 . 0)` 被视为文本区域的左上角。请参阅窗口大小。对于模式行、标题行或标签行中的事件，坐标原点是窗口本身的左上角。对于边缘、边距和垂直边框，x 没有有意义的数据。对于边缘和边距，y 相对于标题行的底部边缘。在所有情况下，x 和 `y` 坐标分别向右和向下增加。

    timestamp

事件发生的时间，从与系统相关的初始时间开始的整数毫秒数。

    object

要么是 `nil` ，这意味着事件发生在缓冲区文本上，要么是形式为 `(string . string-pos)` 的 `cons` 单元格，如果在事件位置存在来自文本属性或覆盖的字符串。

细绳

     单击的字符串，包括任何属性。
字符串位置

发生单击的字符串中的位置。

    text-pos

对于边缘区域或边缘的单击，这是窗口中相应行中第一个可见字符的缓冲区位置。对于模式行、标题行或制表行的点击，这是 `nil` 。对于其他事件，它是最接近点击的缓冲区位置。

    col, row

这些是 `x` 、y 位置下字形的实际列和行坐标数。如果 `x` 位于其行上实际文本的最后一列之外，则通过添加具有默认字符宽度的虚构额外列来报告 `col` 。如果窗口有一个标题行，则将第 `0` 行作为标题行，如果窗口也有标签行，则将第 `1` 行作为标题行，否则将作为文本区域的最顶行。第 `0` 列被视为文本区域的最左侧列，用于单击窗口文本区域，或最左侧的模式行或标题行列，用于单击那里。对于边缘或垂直边界的点击，这些没有有意义的数据。对于边距上的点击，col 是从边距区域的左边缘开始测量的，而 `row` 是从边距区域的顶部开始测量的。

    image

如果单击位置有图像，则这是 `find-image` 返回的图像对象（请参阅定义图像）；否则这是零。

    dx, dy

这些是点击的像素坐标，相对于对象的左上角，即 `(0 . 0)` 。如果 `object` 为 `nil` ，代表缓冲区，则坐标相对于单击的字符字形的左上角。

    width, height

如果单击的是字符，无论是来自缓冲区文本还是来自覆盖或显示字符串，这些都是该字符字形的像素宽度和高度；否则它们是点击的对象的尺寸。

对于滚动条上的点击，位置具有以下形式：

    (window area (portion . whole) timestamp part)

    window

单击其滚动条的窗口。

    area

这是符号垂直滚动条。

    portion

从滚动条顶部到点击位置的像素数。在某些工具包上，包括 `GTK+` ，Emacs 无法提取此数据，因此该值始终为 `0` 。

    whole

滚动条的总长度（以像素为单位）。在某些工具包上，包括 `GTK+` ，Emacs 无法提取此数据，因此该值始终为 `0` 。

    timestamp

事件发生的时间，以毫秒为单位。在某些工具包上，包括 `GTK+` ，Emacs 无法提取此数据，因此该值始终为 `0` 。

    part

发生单击的滚动条部分。它是句柄（滚动条句柄）、上句柄（句柄上方区域）、下句柄（句柄下方区域）、向上（滚动条一端的向上箭头）、或向下（滚动条一端的向下箭头）。

对于框架的内部边框（参见框架布局）、框架的工具栏（参见工具栏）或标签栏的点击，位置具有以下形式：

    (frame part (X . Y) timestamp)

    frame

单击其内部边框或工具栏或选项卡栏的框架。

    part

被点击的框架部分。这可以是以下之一：

    tool-bar

框架有一个工具栏，事件在工具栏区域。

    tab-bar

框架有一个标签栏，事件在标签栏区域。

    left-edge
    top-edge
    right-edge
    bottom-edge

点击是在相应的边界上，距离边界最近的角至少有一个规范字符的偏移量。

    top-left-corner
    top-right-corner
    bottom-right-corner
    bottom-left-corner

单击是在内部边框的相应角上。

    nil

框架没有内部边框，并且事件不在选项卡栏或工具栏上。这通常发生在文本模式框架上。如果框架没有将其 `drag-internal-border` 参数（请参阅鼠标拖动参数）设置为非零值，则这也可能发生在具有内部边框的 `GUI` 框架上。


<a id="org9c50597"></a>

### 22.7.5 拖动事件

使用 `Emacs` ，您甚至可以在不换衣服的情况下进行拖动事件。每次用户按下鼠标按钮，然后在释放按钮之前将鼠标移动到不同的字符位置时，都会发生拖动事件。像所有鼠标事件一样，拖动事件在 `Lisp` 中表示为列表。列表记录了鼠标的起始位置和最终位置，如下所示：

    (event-type
     (window1 START-POSITION)
     (window2 END-POSITION))

对于拖动事件，符号事件类型的名称包含前缀 `拖动-` 。例如，在按住按钮 `2` 的情况下拖动鼠标会生成一个 `drag-mouse-2` 事件。事件的第二个和第三个元素给出了拖动的开始和结束位置，作为鼠标位置列表（请参阅单击事件）。您可以以相同的方式访问任何鼠标事件的第二个元素。但是，拖动事件可能会在最初选择的帧边界之外结束。在这种情况下，第三个元素的位置列表包含该框架而不是窗口。

`drag-` 前缀跟在修饰键前缀之后，例如 `C-` 和 `M-` 。

如果 `read-key-sequence` 接收到一个没有键绑定的拖动事件，并且相应的单击事件确实有一个绑定，它会将拖动事件更改为拖动开始位置的单击事件。这意味着您不必区分单击和拖动事件，除非您愿意。


<a id="orge7b9c0f"></a>

### 22.7.6 按钮按下事件

当用户释放鼠标按钮时，会发生单击和拖动事件。它们不能更早发生，因为在释放按钮之前无法区分单击和拖动。

如果您想在按下按钮后立即采取行动，则需要处理按钮按下事件。15 这些事件会在按下按钮后立即发生。它们由看起来与点击事件完全相同的列表表示（请参阅点击事件），只是事件类型符号名称包含前缀 `down-` 。 `down-` 前缀跟在 `C-` 和 `M-` 等修饰键前缀之后。

函数 `read-key-sequence` 忽略任何没有命令绑定的按钮按下事件；因此，Emacs 命令循环也会忽略它们。这意味着您不必担心定义按钮按下事件，除非您希望它们执行某些操作。定义按钮按下事件的通常原因是您可以跟踪鼠标运动（通过读取运动事件），直到按钮被释放。请参阅运动事件。
脚注
(15)

Button-down 是阻力的保守对立面。


<a id="orga7c4d86"></a>

### 22.7.7 重复事件

如果您在不移动鼠标的情况下快速连续多次按下相同的鼠标按钮，Emacs 会为第二次和后续按下生成特殊的重复鼠标事件。

最常见的重复事件是双击事件。当你点击一个按钮两次时，Emacs 会产生一个双击事件；该事件在您释放按钮时发生（对于所有单击事件都是正常的）。

双击事件的事件类型包含前缀'double-'。因此，在按住 `meta` 的情况下双击鼠标的第二个按钮会进入 `Lisp` 程序，即 `M-double-mouse-2` 。如果双击事件没有绑定，则使用对应的普通点击事件的绑定来执行。因此，除非您真的想要，否则您无需注意双击功能。

当用户执行双击时，Emacs 首先生成一个普通的单击事件，然后是一个双击事件。因此，必须设计双击事件的命令绑定，假设单击命令已经运行。它必须从单击的结果开始产生所需的双击结果。

这很方便，如果双击的含义以某种方式建立在单击的含义之上——这是推荐的双击用户界面设计实践。

如果您单击一个按钮，然后再次按下它并在按住该按钮的情况下开始移动鼠标，那么当您最终释放该按钮时会收到一个双击事件。它的事件类型包含 `双拖动` 而不是 `拖动` 。如果一个双拖事件没有绑定，Emacs 会寻找一个替代的绑定，就好像这个事件是一个普通的拖拽一样。

在双击或双击事件之前，当用户第二次按下按钮时，Emacs 会生成一个双击事件。它的事件类型包含'double-down' 而不仅仅是'down'。如果双击事件没有绑定，Emacs 会寻找替代绑定，就好像该事件是普通的按钮按下事件一样。如果它也没有以这种方式找到绑定，则忽略 `double-down` 事件。

总而言之，当你点击一个按钮然后马上再次按下它时，Emacs 会生成一个向下事件和一个第一次单击的单击事件，当你再次按下按钮时会生成一个双击事件，最后是双击或双拖事件。

如果您单击一个按钮两次然后再次按下它，所有这些都是快速连续的，Emacs 会生成一个三下事件，然后是三下单击或三次拖动。这些事件的事件类型包含 `triple` 而不是 `double` 。如果任何三重事件没有绑定，Emacs 将使用它将用于相应的双事件的绑定。

如果您单击一个按钮三次或更多次，然后再次按下该按钮，则超过第三次的按下事件都是三重事件。Emacs 没有针对四元组、五元组等事件的单独事件类型。但是，您可以查看事件列表以准确了解按下按钮的次数。

    Function: event-click-count event ¶

此函数返回导致事件的连续按下按钮的次数。如果 `event` 是双击、双击或双击事件，则值为 `2` 。如果 `event` 是三重事件，则值为 `3` 或更大。如果 `event` 是普通的鼠标事件（不是重复事件），则值为 `1` 。

    User Option: double-click-fuzz ¶

要生成重复事件，连续按下鼠标按钮必须在大致相同的屏幕位置。double-click-fuzz 的值指定鼠标在两次连续单击之间可以移动（水平或垂直）以进行双击的最大像素数。

该变量也是鼠标移动算作拖动的阈值。

    User Option: double-click-time ¶

要生成重复事件，连续按下按钮之间的毫秒数必须小于双击时间的值。将双击时间设置为 `nil`  会完全禁用多击检测。将其设置为 `t` 会删除时间限制；然后，Emacs 仅按位置检测多次点击。


<a id="org58f5a08"></a>

### 22.7.8 运动事件

Emacs 有时会生成鼠标运动事件来描述没有任何按钮活动的鼠标运动。鼠标运动事件由如下所示的列表表示：

    (mouse-movement POSITION)

position 是一个鼠标位置列表（请参阅单击事件），指定鼠标光标的当前位置。与拖动事件的结束位置一样，此位置列表可能表示初始选定帧边界之外的位置，在这种情况下，列表包含该帧而不是窗口。

特殊形式的跟踪鼠标可以在其体内生成运动事件。在跟踪鼠标形式之外，Emacs 不会仅仅为鼠标的运动生成事件，并且这些事件不会出现。请参阅鼠标跟踪。

    Variable: mouse-fine-grained-tracking ¶

当非零时，即使是非常小的移动也会生成鼠标运动事件。否则，只要鼠标光标仍然指向文本中的相同字形，就不会生成运动事件。


<a id="org5ff7b6e"></a>

### 22.7.9 焦点事件

窗口系统为用户提供了控制哪个窗口获得键盘输入的通用方法。这种窗口的选择称为焦点。当用户在 `Emacs` 帧之间切换时，会产生一个焦点事件。在全局键映射中，焦点事件的正常定义是在 `Emacs` 中选择一个新帧，正如用户所期望的那样。请参阅输入焦点，其中还描述了与焦点事件相关的钩子。

焦点事件在 `Lisp` 中表示为如下所示的列表：

    (switch-frame new-frame)

其中 `new-frame` 是切换到的帧。

一些 `X` 窗口管理器的设置使得只需将鼠标移入窗口就足以将焦点设置在那里。通常，在某种其他类型的输入到达之前，Lisp 程序不需要知道焦点的变化。Emacs 仅当用户在新帧中实际键入键盘键或按下鼠标按钮时才会生成焦点事件；只是在帧之间移动鼠标不会产生焦点事件。

键序列中间的焦点事件会使序列乱码。所以 `Emacs` 永远不会在键序列的中间生成焦点事件。如果用户在键序列的中间（即在前缀键之后）更改焦点，那么 `Emacs` 会重新排序事件，以便焦点事件出现在多事件键序列之前或之后，而不是在其中。


<a id="org2ab4259"></a>

### 22.7.10 其他系统事件

其他一些事件类型代表系统内的事件。

    (delete-frame (frame))

这种事件表明用户给窗口管理器一个命令来删除一个特定的窗口，这个窗口恰好是一个 `Emacs` 框架。

删除帧事件的标准定义是删除帧。

    (iconify-frame (frame))

这种事件表明用户使用窗口管理器图标化了框架。它的标准定义是忽略；由于框架已经被图标化，Emacs 没有工作要做。此事件类型的目的是让您可以根据需要跟踪此类事件。

    (make-frame-visible (frame))

这种事件表明用户使用窗口管理器取消了框架。它的标准定义是忽略；由于框架已经可见，Emacs 没有工作要做。

    (wheel-up position)

    (wheel-down position)

这些类型的事件是通过移动鼠标滚轮生成的。position 元素是一个鼠标位置列表（请参阅单击事件），指定事件发生时鼠标光标的位置。

此类事件仅在某些类型的系统上生成。在某些系统上，改为使用 `mouse-4` 和 `mouse-5` 。对于可移植代码，使用 `mwheel.el` 中定义的变量 `mouse-wheel-up-event` 和 `mouse-wheel-down-event` 来确定鼠标滚轮的预期事件类型。

    (drag-n-drop position files)

当在 `Emacs` 外部的应用程序中选择一组文件，然后将其拖放到 `Emacs` 框架上时，会生成此类事件。

元素位置是描述事件位置的列表，格式与鼠标单击事件中使用的格式相同（请参阅单击事件），文件是拖放的文件名列表。处理此事件的常用方法是访问这些文件。

目前，仅在某些类型的系统上会生成此类事件。

    help-echo

当鼠标指针移动到具有帮助回显文本属性的缓冲区文本部分时，会生成此类事件。生成的事件具有以下形式：

    (help-echo frame help window object pos)

事件参数的确切含义以及这些参数用于显示帮助回显文本的方式在 `Text help-echo` 中进行了描述。

    sigusr1

    sigusr2

这些事件是在 `Emacs` 进程收到信号 `SIGUSR1` 和 `SIGUSR2` 时生成的。它们不包含附加数据，因为信号不携带附加信息。它们对于调试很有用（请参阅在出现错误时进入调试器）。

要捕获用户信号，请将相应的事件绑定到特殊事件映射中的交互式命令（请参阅控制活动键盘映射）。该命令在没有参数的情况下被调用，并且特定的信号事件在 `last-input-event` 中可用（请参阅 `Miscellaneous Event Input Features` 。例如：

    (defun sigusr-handler ()
      (interactive)
      (message "Caught signal %S" last-input-event))
    
    (define-key special-event-map [sigusr1] 'sigusr-handler)

要测试信号处理程序，您可以让 `Emacs` 向自身发送信号：

    (signal-process (emacs-pid) 'sigusr1)

    language-change

当输入语言改变时，这种事件会在 `MS-Windows` 上生成。这通常意味着键盘按键将向 `Emacs` 发送不同语言的字符。生成的事件具有以下形式：

    (language-change frame codepage language-id)

这里的 `frame` 是输入语言改变时的当前帧；codepage 是新的代码页编号；language-id 是新输入语言的数字 `ID` 。对应于代码页的编码系统（参见编码系统）是 `cpcodepage` 或 `windows-codepage` 。要将语言 `ID` 转换为字符串（例如，将其用于各种与语言相关的功能，例如 `set-language-environment` ），请使用 `w32-get-locale-info` 函数，如下所示：

    ;; Get the abbreviated language name, such as "ENU" for English
    (w32-get-locale-info language-id)
    ;; Get the full English name of the language,
    ;; such as "English (United States)"
    (w32-get-locale-info language-id 4097)
    ;; Get the full localized name of the language
    (w32-get-locale-info language-id t)

如果其中一个事件到达键序列的中间（即在前缀键之后），那么 `Emacs` 会重新排序这些事件，以便该事件出现在多事件键序列之前或之后，而不是在其中。

其中一些特殊事件，例如 `delete-frame` ，默认调用 `Emacs` 命令；其他人不受约束。如果你想安排一个特殊事件来调用命令，你可以通过 `special-event-map` 来实现。然后，您绑定到该映射中的功能键的命令可以检查在 `last-input-event` 中调用它的完整事件。请参阅特别活动。


<a id="orge48315c"></a>

### 22.7.11 事件示例

如果用户在同一位置按下并释放鼠标左键，则会生成如下事件序列：

    (down-mouse-1 (#<window 18 on NEWS> 2613 (0 . 38) -864320))
    (mouse-1      (#<window 18 on NEWS> 2613 (0 . 38) -864180))

在按住控制键的同时，用户可能会按住第二个鼠标按钮，并将鼠标从一行拖到下一行。这会产生两个事件，如下所示：

    (C-down-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219))
    (C-drag-mouse-2 (#<window 18 on NEWS> 3440 (0 . 27) -731219)
    		(#<window 18 on NEWS> 3510 (0 . 28) -729648))

在按住 `meta` 和 `shift` 键的同时，用户可能会按下窗口模式行上的第二个鼠标按钮，然后将鼠标拖到另一个窗口中。这会产生如下一对事件：

    (M-S-down-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844))
    (M-S-drag-mouse-2 (#<window 18 on NEWS> mode-line (33 . 31) -457844)
    		  (#<window 20 on carlton-sanskrit.tex> 161 (33 . 3)
    		   -453816))

具有输入焦点的框架可能不会占据整个屏幕，用户可能会将鼠标移到框架范围之外。在 `track-mouse` 特殊形式中，会产生如下事件：

    (mouse-movement (#<frame *ielm* 0x102849a30> nil (563 . 205) 532301936))

要处理 `SIGUSR1` 信号，请定义一个交互函数，并将其绑定到信号 `usr1` 事件序列：

    (defun usr1-handler ()
      (interactive)
      (message "Got USR1 signal"))
    (global-set-key [signal usr1] 'usr1-handler)


<a id="orgfdf5c3d"></a>

### 22.7.12 分类事件

每个事件都有一个事件类型，它为键绑定目的对事件进行分类。对于键盘事件，事件类型等于事件值；因此，字符的事件类型是字符，而功能键符号的事件类型是符号本身。对于列表事件，事件类型是列表的 `CAR` 中的符号。因此，事件类型始终是符号或字符。

在涉及键绑定的情况下，相同类型的两个事件是等价的；因此，它们总是运行相同的命令。但是，这并不一定意味着它们会做同样的事情，因为某些命令会查看整个事件来决定要做什么。例如，某些命令使用鼠标事件的位置来决定在缓冲区中的哪个位置进行操作。

有时更广泛的事件分类是有用的。例如，您可能想询问事件是否涉及 `META` 键，而不管使用了哪个其他键或鼠标按钮。

提供了函数 `event-modifiers` 和 `event-basic-type` 来方便地获取这些信息。

    Function: event-modifiers event ¶

此函数返回事件具有的修饰符列表。修饰符是符号；它们包括 `shift` 、control、meta、alt、hyper 和 `super` 。此外，鼠标事件符号的修饰符列表始终包含单击、拖动和向下之一。对于双重或三重事件，它还包含双重或三重。

参数事件可以是整个事件对象，或者只是一个事件类型。如果 `event` 是一个从未在当前 `Emacs` 会话中作为输入读取的事件中使用过的符号，那么 `event-modifiers` 可以返回 `nil` ，即使 `event` 实际上有修饰符。

这里有些例子：

    (event-modifiers ?a)
         ⇒ nil
    (event-modifiers ?A)
         ⇒ (shift)
    (event-modifiers ?\C-a)
         ⇒ (control)
    (event-modifiers ?\C-%)
         ⇒ (control)
    (event-modifiers ?\C-\S-a)
         ⇒ (control shift)
    (event-modifiers 'f5)
         ⇒ nil
    (event-modifiers 's-f5)
         ⇒ (super)
    (event-modifiers 'M-S-f5)
         ⇒ (meta shift)
    (event-modifiers 'mouse-1)
         ⇒ (click)
    (event-modifiers 'down-mouse-1)
         ⇒ (down)

单击事件的修饰符列表明确包含单击，但事件符号名称本身不包含 `单击` 。类似地，ASCII 控制字符（例如 `C-a` ）的修饰符列表包含控制，即使通过 `read-char` 读取此类事件将返回值 `1` ，并且删除了控制修饰符位。

    Function: event-basic-type event ¶

此函数返回事件描述的键或鼠标按钮，并删除所有修饰符。事件参数与事件修饰符中的一样。例如：

    (event-basic-type ?a)
         ⇒ 97
    (event-basic-type ?A)
         ⇒ 97
    (event-basic-type ?\C-a)
         ⇒ 97
    (event-basic-type ?\C-\S-a)
         ⇒ 97
    (event-basic-type 'f5)
         ⇒ f5
    (event-basic-type 's-f5)
         ⇒ f5
    (event-basic-type 'M-S-f5)
         ⇒ f5
    (event-basic-type 'down-mouse-1)
         ⇒ mouse-1

    Function: mouse-movement-p object ¶

如果对象是鼠标移动事件，此函数返回非零。请参阅运动事件。

    Function: event-convert-list list ¶

此函数将修饰符名称列表和基本事件类型转换为指定所有这些的事件类型。基本事件类型必须是列表的最后一个元素。例如，

    (event-convert-list '(control ?a))
         ⇒ 1
    (event-convert-list '(control meta ?a))
         ⇒ -134217727
    (event-convert-list '(control super f1))
         ⇒ C-s-f1


<a id="orgee3b473"></a>

### 22.7.13 访问鼠标事件

本节介绍用于访问鼠标按钮或运动事件中的数据的便捷函数。可以使用相同的函数访问键盘事件数据，但不适用于键盘事件的数据元素为零或零。

以下两个函数返回鼠标位置列表（请参阅单击事件），指定鼠标事件的位置。

    Function: event-start event ¶

这将返回事件的起始位置。

如果 `event` 是单击或按钮按下事件，则返回事件的位置。如果 `event` 是一个拖动事件，则返回拖动的起始位置。

    Function: event-end event ¶

这将返回事件的结束位置。

如果 `event` 是一个拖动事件，则返回用户释放鼠标按钮的位置。如果 `event` 是单击或按钮按下事件，则该值实际上是起始位置，这是此类事件的唯一位置。

    Function: posnp object ¶

如果 `object` 是鼠标位置列表，则此函数返回非 `nil` ，格式为 `Click Events` 中记录的格式）；否则为零。

这些函数将鼠标位置列表作为参数，并返回它的各个部分：

    Function: posn-window position ¶

返回该位置所在的窗口。如果位置表示事件启动的框架之外的位置，则返回该框架。

    Function: posn-area position ¶

返回记录在位置上的窗口区域。当事件发生在窗口的文本区域时，它返回 `nil` ；否则，它是标识事件发生区域的符号。

    Function: posn-point position ¶

返回位置中的缓冲区位置。当事件发生在窗口的文本区域、边缘区域或边缘时，这是一个指定缓冲区位置的整数。否则，该值未定义。

    Function: posn-x-y position ¶

返回位置中基于像素的 `x` 和 `y` 坐标，作为 `cons` 单元格 `(x . y)` 。这些坐标相对于 `posn-window` 给出的窗口。

此示例显示如何将窗口文本区域中的窗口相对坐标转换为帧相对坐标：

    (defun frame-relative-coordinates (position)
      "Return frame-relative coordinates from POSITION.
    POSITION is assumed to lie in a window text area."
      (let* ((x-y (posn-x-y position))
    	 (window (posn-window position))
    	 (edges (window-inside-pixel-edges window)))
        (cons (+ (car x-y) (car edges))
    	  (+ (cdr x-y) (cadr edges)))))

    Function: posn-col-row position ¶

此函数返回一个 `cons` 单元格 `(col.row)` ，其中包含与位置描述的缓冲区位置相对应的估计列和行。返回值以框架的默认字符宽度和默认行高（包括间距）为单位，由对应于位置的 `x` 和 `y` 值计算得出。（因此，如果实际字符具有非默认大小，则实际行和列可能与这些计算值不同。）

请注意，行从文本区域的顶部开始计算。如果位置给定的窗口具有标题行（请参阅窗口标题行）或制表符行，则它们不包括在行数中。

    Function: posn-actual-col-row position ¶

返回实际的行和列的位置，作为一个 `cons` 单元格（col.row）。这些值是位置给定的窗口中的实际行号和列号。有关详细信息，请参阅单击事件。如果 `position` 不包含实际位置值，该函数返回 `nil` ；在这种情况下，可以使用 `posn-col-row` 来获取近似值。

请注意，此函数不考虑显示字符的视觉宽度，例如制表符或图像占用的视觉列数。如果您需要规范字符单位的坐标，请改用 `posn-col-row` 。

    Function: posn-string position ¶

返回由位置描述的字符串对象，可以是 `nil` （这意味着位置描述缓冲区文本），或者是一个 `cons` 单元格（string .string-pos）。

    Function: posn-image position ¶

返回位置中的图像对象，可以是 `nil` （如果该位置没有图像），也可以是图像规范（图像 `...` ）。

    Function: posn-object position ¶

返回由位置描述的图像或字符串对象，可以是 `nil` （这意味着位置描述缓冲区文本）、图像（图像 `...` ）或 `cons` 单元格（字符串 `.string-pos` ）。

    Function: posn-object-x-y position ¶

返回相对于位置描述的对象左上角的基于像素的 `x` 和 `y` 坐标，作为 `cons` 单元格 `(dx . dy)` 。如果该位置描述了缓冲区文本，则返回最接近该位置的缓冲区文本字符的相对坐标。

    Function: posn-object-width-height position ¶

返回由位置描述的对象的像素宽度和高度，作为一个 `cons` 单元格（宽度。高度）。如果该位置描述了一个缓冲区位置，则返回该位置的字符大小。

    Function: posn-timestamp position ¶

返回位置的时间戳。这是事件发生的时间，以毫秒为单位。

这些函数计算给定特定缓冲区位置或屏幕位置的位置列表。您可以使用上述功能访问此职位列表中的数据。

    Function: posn-at-point &optional pos window ¶

此函数返回窗口中位置 `pos` 的位置列表。pos 默认指向窗口；窗口默认为选定的窗口。

如果 `pos` 在窗口中不可见，则 `posn-at-point` 返回 `nil` 。

    Function: posn-at-x-y x y &optional frame-or-window whole ¶

该函数返回指定的frame或window，frame-or-window中像素坐标x和y对应的位置信息，默认为选中的窗口。坐标 `x` 和 `y` 相对于所选窗口的文本区域。如果整体不为零，则 `x` 坐标相对于整个窗口区域，包括滚动条、边距和边缘。


<a id="org43ad411"></a>

### 22.7.14 访问滚动条事件

这些函数对于解码滚动条事件很有用。

    Function: scroll-bar-event-ratio event ¶

此函数返回滚动条事件在滚动条内的小数垂直位置。该值是一个 `cons` 单元格（部分。整体），其中包含两个整数，其比率是小数位置。

    Function: scroll-bar-scale ratio total ¶

此函数将（实际上）比率乘以总数，将结果四舍五入为整数。参数 `ratio` 不是一个数字，而是一对 `(num . denom)` ——通常是由 `scroll-bar-event-ratio` 返回的值。

此函数可方便地将滚动条上的位置缩放到缓冲区位置。以下是如何做到这一点：

    (+ (point-min)
       (scroll-bar-scale
          (posn-x-y (event-start event))
          (- (point-max) (point-min))))

回想一下，滚动条事件有两个整数形成一个比率，而不是一对 `x` 和 `y` 坐标。


<a id="org8a17c7f"></a>

### 22.7.15 将键盘事件放入字符串中

在大多数使用字符串的地方，我们将字符串概念化为包含文本字符——与缓冲区或文件中的相同类型的字符。有时 `Lisp` 程序使用概念上包含键盘字符的字符串；例如，它们可能是键序列或键盘宏定义。但是，出于历史兼容性的原因，将键盘字符存储在字符串中是一件复杂的事情，而且并不总是可能的。

我们建议新程序通过不在字符串中存储键盘事件来避免处理这些复杂性。以下是如何做到这一点：

当您计划将向量而不是用作查找键和定义键的参数时，请使用向量而不是字符串作为键序列。例如，您可以使用 `read-key-sequence-vector` 代替 `read-key-sequence` ，使用 `this-command-keys-vector` 代替 `this-command-keys` 。
使用向量来编写包含元字符的键序列常量，即使将它们直接传递给 `define-key` 。
当您必须查看可能是字符串的键序列的内容时，首先使用 `listify-key-sequence` （请参阅杂项事件输入功能）将其转换为列表。

复杂性源于键盘输入字符可以包含的修饰符位。除了 `Meta` 修饰符之外，这些修饰符位都不能包含在字符串中，并且 `Meta` 修饰符仅在特殊情况下才允许使用。

最早的 `GNU Emacs` 版本将元字符表示为 `128` 到 `255` 范围内的代码。当时，基本字符代码的范围是 `0` 到 `127` ，因此所有键盘字符代码确实适合字符串。许多 `Lisp` 程序在字符串常量中使用 `'\M-'` 来代表元字符，特别是在定义键和类似函数的参数中，键序列和事件序列总是表示为字符串。

当我们添加对超过 `127` 的更大基本字符代码的支持以及额外的修饰符位时，我们不得不更改元字符的表示。现在，表示字符中 `Meta` 修饰符的标志是 `2**27` ，这样的数字不能包含在字符串中。

为了支持在字符串常量中使用 `'\M-'` 的程序，有一些特殊规则可以在字符串中包含某些元字符。以下是将字符串解释为输入字符序列的规则：

如果键盘字符值在 `0` 到 `127` 范围内，则可以原样进入字符串。
这些字符的元变体，代码范围为 `2**27` 到 `2**27+127` ，也可以进入字符串，但您必须更改它们的数值。您必须设置 `2**7` 位而不是 `2**27` 位，从而产生介于 `128` 和 `255` 之间的值。只有单字节字符串可以包含这些代码。
256 以上的非 `ASCII` 字符可以包含在多字节字符串中。
其他键盘字符事件不能放入字符串中。这包括 `128` 到 `255` 范围内的键盘事件。

诸如 `read-key-sequence` 之类的构造键盘输入字符串的函数遵循以下规则：当事件不适合字符串时，它们构造向量而不是字符串。

当您在字符串中使用读取语法 `'\M-'` 时，它会生成 `128` 到 `255` 范围内的代码——如果您修改相应的键盘事件以将其放入字符串中，您会得到相同的代码。因此，无论它们如何进入字符串，字符串中的元事件都会始终如一地工作。

但是，大多数程序都可以通过遵循本节开头的建议来避免这些问题。


<a id="org0ffbe5a"></a>

## 22.8 读数输入

编辑器命令循环使用函数 `read-key-sequence` 读取键序列，该函数使用 `read-event` 。这些和其他事件输入函数也可用于 `Lisp` 程序。另请参阅 `Temporary Displays` 中的 `momentary-string-display` 和 `Waiting for Elapsed Time` 或 `Input` 。有关控制终端输入模式和调试终端输入的函数和变量，请参见终端输入。

有关更高级别的输入设施，请参阅 `Minibuffers` 。


<a id="org98f4345"></a>

### 22.8.1 按键序列输入

命令循环通过调用 `read-key-sequence` 一次读取输入一个键序列。Lisp 程序也可以调用这个函数；例如， `describe-key` 使用它来读取要描述的键。

    Function: read-key-sequence prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop ¶

此函数读取一个键序列并将其作为字符串或向量返回。它不断读取事件，直到它积累了一个完整的键序列；也就是说，足以使用当前活动的键盘映射指定非前缀命令。（请记住，以鼠标事件开始的键序列是使用鼠标所在窗口中缓冲区的键映射读取的，而不是当前缓冲区。）

如果事件都是字符并且都可以放入字符串中，则 `read-key-sequence` 返回字符串（请参阅将键盘事件放入字符串中）。否则，它返回一个向量，因为一个向量可以包含所有类型的事件——字符、符号和列表。字符串或向量的元素是键序列中的事件。

读取键序列包括以各种方式翻译事件。请参阅用于翻译事件序列的键映射。

参数提示要么是在回显区域中作为提示显示的字符串，要么是 `nil` ，表示不显示提示。参数 `continue-echo` 如果不是 `nil` ，则表示将此键回显为前一个键的延续。

通常，如果原始事件未定义且小写等效项已定义，则任何大写事件都会转换为小写。参数 `dont-downcase-last` ，如果非零，则表示不将最后一个事件转换为小写。这适用于读取要定义的键序列。

参数 `switch-frame-ok` ，如果非 `nil` ，则意味着如果用户在输入任何内容之前切换帧，则此函数应处理 `switch-frame` 事件。如果用户在按键序列的中间或序列开始时切换帧但 `switch-frame-ok` 为 `nil` ，则事件将推迟到当前按键序列之后。

参数命令循环，如果非零，意味着这个键序列正在被一个接一个地读取命令的东西读取。如果调用者只读取一个键序列，则它应该为 `nil` 。

在以下示例中，Emacs 显示提示符 `？`   在回声区域，然后用户键入 `Cx Cf` 。

    (read-key-sequence "?")
    
    ---------- Echo Area ----------
    ?C-x C-f
    ---------- Echo Area ----------
    
         ⇒ "^X^F"

函数 `read-key-sequence` 抑制退出：使用此函数读取时键入的 `Cg` 与任何其他字符一样工作，并且不设置退出标志。请参阅退出。

    Function: read-key-sequence-vector prompt &optional continue-echo dont-downcase-last switch-frame-ok command-loop ¶

这与 `read-key-sequence` 类似，只是它始终将键序列作为向量返回，而不是作为字符串返回。请参阅将键盘事件放入字符串中。

如果输入字符是大写的（或具有 `shift` 修饰符）并且没有键绑定，但它的小写等效项有一个，则 `read-key-sequence` 将字符转换为小写。请注意，lookup-key 不会以这种方式执行大小写转换。

当读取输入导致这种移位翻译时，Emacs 将变量 `this-command-keys-shift-translated` 设置为非零值。如果 `Lisp` 程序在被移位转换键调用时需要修改其行为，则可以检查此变量。例如，函数句柄移位选择检查此变量的值以确定如何激活或停用该区域（请参阅句柄移位选择）。

函数 `read-key-sequence` 也转换了一些鼠标事件。它将未绑定的拖动事件转换为单击事件，并完全丢弃未绑定的按钮按下事件。它还重新调整焦点事件和杂项窗口事件，使它们永远不会与任何其他事件一起出现在键序列中。

当鼠标事件发生在窗口或框架的特殊部分（例如模式行或滚动条）时，事件类型没有什么特别之处——它与通常表示鼠标按钮和修改键组合的符号相同。关于窗口部分的信息保存在事件的其他地方——坐标中。但是 `read-key-sequence` 将这些信息翻译成虚构的前缀键，所有这些都是符号：tab-line，header-line，horizo​​ntal-scroll-bar，menu-bar，tab-bar，mode-line，vertical-line，垂直滚动条、左边距、右边距、左边缘、右边缘、右分隔线和底部分隔线。您可以通过使用这些虚构的前缀键定义键序列来定义特殊窗口部分中鼠标单击的含义。

例如，如果您调用 `read-key-sequence` 然后在窗口的模式行上单击鼠标，您会得到两个事件，如下所示：

    (read-key-sequence "Click on the mode line: ")
         ⇒ [mode-line
    	 (mouse-1
    	  (#<window 6 on NEWS> mode-line
    	   (40 . 63) 5959987))]

    Variable: num-input-keys ¶

这个变量的值是到目前为止在这个 `Emacs` 会话中处理的键序列的数量。这包括从终端读取的键序列和从正在执行的键盘宏中读取的键序列。


<a id="orga81bdfe"></a>

### 22.8.2 读取一个事件

命令输入的最低级别函数是 `read-event` 、read-char 和 `read-char-exclusive` 。

如果您需要使用 `minibuffer` 读取字符的函数，请使用 `read-char-from-minibuffer` （请参阅询问多项选择题）。

    Function: read-event &optional prompt inherit-input-method seconds ¶

该函数读取并返回命令输入的下一个事件，必要时等待事件可用。

返回的事件可能直接来自用户，也可能来自键盘宏。它不被键盘的输入编码系统解码（参见终端 `I/O` 编码）。

如果可选参数 `prompt` 不是 `nil` ，它应该是一个字符串，作为提示显示在回显区域中。如果 `prompt` 为 `nil`  或字符串 `'""'` ，则 `read-event` 不显示任何消息表明它正在等待输入；相反，它通过回显来提示：它显示导致当前命令或被当前命令读取的事件的描述。见回声区。

如果inherit-input-method 不为 `nil` ，则使用当前输入法（如果有）来输入非ASCII 字符。否则，将禁用输入法处理以读取此事件。

如果 `cursor-in-echo-area` 不为 `nil` ，则 `read-event` 将光标临时移动到 `echo` 区域，到那里显示的任何消息的末尾。否则 `read-event` 不会移动光标。

如果 `seconds` 不为零，它应该是一个数字，指定等待输入的最长时间，以秒为单位。如果在那段时间内没有输入到达，read-event 停止等待并返回 `nil` 。浮点秒意味着等待小数秒。有些系统只支持整数秒；在这些系统上，秒是向下舍入的。如果 `seconds` 为 `nil` ，则 `read-event` 等待输入到达所需的时间。

如果 `seconds` 为 `nil` ，则 `Emacs` 在等待用户输入到达时被认为是空闲的。空闲定时器——那些使用 `run-with-idle-timer` 创建的定时器（见空闲定时器）——可以在这段时间内运行。但是，如果 `seconds` 不为零，则空闲状态保持不变。如果调用 `read-event` 时 `Emacs` 是 `non-idle` ，则在 `read-event` 的整个操作过程中保持 `non-idle` ；如果 `Emacs` 处于空闲状态（如果调用发生在空闲计时器内，则可能发生这种情况），它保持空闲状态。

如果 `read-event` 得到一个定义为帮助字符的事件，那么在某些情况下 `read-event` 直接处理该事件而不返回。请参阅帮助功能。某些称为特殊事件的其他事件也直接在读取事件中处理（请参阅特殊事件）。

如果您调用 `read-event` 然后按右箭头功能键，会发生以下情况：

    (read-event)
         ⇒ right

    Function: read-char &optional prompt inherit-input-method seconds ¶

该函数读取并返回一个字符输入事件。如果用户生成一个非字符事件（即鼠标点击或功能键事件），read-char 会发出错误信号。参数的工作方式与读取事件中的一样。

如果事件有修饰符，Emacs 会尝试解析它们并返回相应字符的代码。例如，如果用户键入 `Ca` ，则函数返回 `1` ，即 `C-a` 字符的 `ASCII` 码。如果某些修饰符无法反映在字符代码中，read-char 将在返回的事件中保留未解析的修饰符位设置。例如，如果用户键入 `CMa` ，该函数将返回 `134217729` ，十六进制的 `8000001` ，即设置了 `Meta` 修饰符位的 `C-a` 。此值不是有效的字符代码：它未通过 `characterp` 测试（请参阅字符代码）。使用 `event-basic-type` （参见 `Classifying Events` ）恢复删除修饰符位的字符代码；使用 `event-modifiers` 来测试 `read-char` 返回的字符事件中的修饰符。

在下面的第一个示例中，用户键入字符 `1` （ASCII 代码 `49` ）。第二个示例显示了一个键盘宏定义，它使用 `eval-expression` 从 `minibuffer` 调用 `read-char` 。read-char 读取键盘宏的下一个字符，即 `1` 。然后 `eval-expression` 在回显区域显示其返回值。

    (read-char)
         ⇒ 49
    
    
    ;; We assume here you use M-: to evaluate this.
    (symbol-function 'foo)
         ⇒ "^[:(read-char)^M1"
    
    (execute-kbd-macro 'foo)
         -| 49
         ⇒  nil

    Function: read-char-exclusive &optional prompt inherit-input-method seconds ¶

该函数读取并返回一个字符输入事件。如果用户生成的事件不是字符事件，read-char-exclusive 将忽略它并读取另一个事件，直到它得到一个字符。参数的工作方式与读取事件中的一样。返回值可能包括修饰符位，与 `read-char` 一样。

上述功能均不抑制退出。

    Variable: num-nonmacro-input-events ¶

这个变量保存了到目前为止从终端接收到的输入事件的总数——不包括由键盘宏生成的那些。

我们强调，与 `read-key-sequence` 不同，函数 `read-event` 、read-char 和 `read-char-exclusive` 不执行 `Keymaps for Translating Sequences of Events` 中描述的翻译。如果您希望读取考虑这些翻译的单个键（例如，读取终端中的功能键或 `xterm-mouse-mode` 中的鼠标事件），请使用函数 `read-key` ：

    Function: read-key &optional prompt disable-fallbacks ¶

此函数读取单个密钥。它介于 `read-key-sequence` 和 `read-event` 之间。与前者不同，它读取单个键，而不是键序列。与后者不同的是，它不返回原始事件，而是根据 `input-decode-map` 、local-function-key-map 和 `key-translation-map` 对用户输入进行解码和翻译（参见 `Keymaps for Translating Sequences of Events` ） ~.

~ 参数提示要么是在回显区域中作为提示显示的字符串，要么是 `nil` ，表示不显示提示。

如果参数 `disable-fallbacks` 不为零，则不应用 `read-key-sequence` 中未绑定键的常用回退逻辑。这意味着不会丢弃鼠标按下和多击事件，并且不会应用 `local-function-key-map` 和 `key-translation-map` 。如果 `nil`  或未指定，则唯一禁用的回退是最后一个事件的小写。

    Function: read-char-choice prompt chars &optional inhibit-quit ¶

此函数使用 `read-key` 读取并返回单个字符。它忽略任何不是 `chars` 成员的输入，即接受的字符列表。可选地，它在等待有效输入时也会忽略键盘退出事件。如果在调用 `read-char-choice` 时将 `help-form` （参见帮助函数）绑定到非 `nil`  值，则按 `help-char` 会导致它评估 `help-form` 并显示结果。然后它继续等待有效的输入字符，或键盘退出。

    Function: read-multiple-choice prompt choices &optional help-string ¶

向用户询问多项选择题。prompt 应该是一个将作为提示显示的字符串。

选择是一个列表，其中每个条目中的第一个元素是要输入的字符，第二个元素是提示时要显示的条目的短名称（如果有空间，它可能会缩短），第三个是可选条目是一个较长的解释，如果用户请求更多帮助，它将显示在帮助缓冲区中。

如果可选参数 `help-string` 不是 `nil` ，它应该是一个对所有选项有更详细描述的字符串。当用户键入 `?` 时，它将显示在帮助缓冲区中，而不是默认的自动生成的描述中。

返回值是来自选择的匹配值。

    (read-multiple-choice
     "Continue connecting?"
     '((?a "always" "Accept certificate for this and future sessions.")
       (?s "session only" "Accept certificate this session only.")
       (?n "no" "Refuse to use certificate, close connection.")))

read-multiple-choice-face 用于在图形终端上突出显示名称字符串中的匹配字符。


<a id="orga2e9fb6"></a>

### 22.8.3 修改和翻译输入事件

Emacs 根据额外的键盘修饰符修改它读取的每个事件，然后通过键盘翻译表（如果适用）翻译它，然后从读取事件返回它。

    Variable: extra-keyboard-modifiers ¶

这个变量让 `Lisp` 程序 `按下` 键盘上的修饰键。值是一个字符。只有角色的修饰符很重要。每次用户键入键盘键时，它都会改变，就好像这些修饰键被按住一样。例如，如果将 `extra-keyboard-modifiers` 绑定到 `?\C-\Ma` ，那么在绑定范围内键入的所有键盘输入字符都将应用 `control` 和 `meta` 修饰符。字符 `?\C-@` ，相当于整数 `0` ，在此目的中不算作控制字符，而是作为没有修饰符的字符。因此，将 `extra-keyboard-modifiers` 设置为零会取消任何修改。

当使用窗口系统时，程序可以通过这种方式按下任何修饰键。否则，只能虚拟按下 `CTL` 和 `META` 键。

请注意，此变量仅适用于真正来自键盘的事件，对鼠标事件或任何其他事件没有影响。

    Variable: keyboard-translate-table ¶

这个终端本地变量是键盘字符的翻译表。它使您可以在不更改任何命令绑定的情况下重新调整键盘上的键。它的值通常是一个字符表，否则为零。（它也可以是字符串或向量，但这被认为是过时的。）

如果keyboard-translate-table 是一个char-table（参见Char-Tables），那么从键盘读取的每个字符都会在这个char-table 中查找。如果找到的值不是 `nil` ，则使用它来代替实际输入的字符。

请注意，此翻译是从终端读取字符后发生的第一件事。记录保存功能，如最近键和运球文件记录翻译后的字符。

另请注意，此翻译是在将字符提供给输入法之前完成的（请参阅输入法）。如果要在输入法操作后翻译字符，请使用 `translation-table-for-input` （请参阅字符翻译）。

    Function: keyboard-translate from to ¶

此函数修改keyboard-translate-table 将字符代码从转换为字符代码。如有必要，它会创建键盘翻译表。

下面是一个使用keyboard-translate-table让Cx、Cc和Cv执行剪切、复制和粘贴操作的例子：

    (keyboard-translate ?\C-x 'control-x)
    (keyboard-translate ?\C-c 'control-c)
    (keyboard-translate ?\C-v 'control-v)
    (global-set-key [control-x] 'kill-region)
    (global-set-key [control-c] 'kill-ring-save)
    (global-set-key [control-v] 'yank)

在支持扩展 `ASCII` 输入的图形终端上，您仍然可以通过使用 `shift` 键键入其中一个字符来获得标准 `Emacs` 含义。就键盘翻译而言，这使其成为不同的字符，但具有相同的通常含义。

有关在 `read-key-sequence` 级别翻译事件序列的机制，请参阅用于翻译事件序列的键映射。


<a id="org56624ca"></a>

### 22.8.4 调用输入法

事件读取函数调用当前输入法，如果有的话（请参阅输入法）。如果 `input-method-function` 的值为非 `nil` ，则应该是一个函数；当 `read-event` 读取一个没有修饰位的打印字符（包括 `SPC` ）时，它调用该函数，将字符作为参数传递。

    Variable: input-method-function ¶

如果这是非零，它的值指定当前输入法功能。

警告：不要将此变量与 `let` 绑定。它通常是缓冲区本地的，如果你在读取输入时绑定它（这正是你绑定它的时候），在 `Emacs` 等待时异步切换缓冲区将导致值在错误的缓冲区中恢复。

输入法函数应返回应用作输入的事件列表。（如果列表为 `nil` ，则表示没有输入，因此 `read-event` 等待另一个事件。）这些事件在 `unread-command-events` 中的事件之前处理（请参阅杂项事件输入功能）。输入法函数返回的事件不会再次传递给输入法函数，即使它们正在打印没有修饰符位的字符。

如果输入法函数调用 `read-event` 或 `read-key-sequence` ，它应该先将 `input-method-function` 绑定到 `nil` ，以防止递归。

读取按键序列的第二个和后续事件时不调用输入法函数。因此，这些字符不受输入法处理。输入法函数应该测试overriding-local-map和overriding-terminal-local-map的值；如果这些变量中的任何一个不为零，则输入方法应将其参数放入列表中并返回该列表而不进行进一步处理。


<a id="orgb71bf4c"></a>

### 22.8.5 引用字符输入

您可以使用函数 `read-quoted-char` 要求用户指定一个字符，并允许用户方便地指定一个控件或元字符，无论是字面还是八进制字符代码。命令quoted-insert 使用此功能。

    Function: read-quoted-char &optional prompt ¶

此函数与 `read-char` 类似，只是如果读取的第一个字符是八进制数字 `(0-7)` ，它会读取任意数量的八进制数字（但如果找到非八进制数字则停止），并返回表示的字符通过那个数字字符代码。如果终止八进制数字序列的字符是 `RET` ，则将其丢弃。此函数返回后，任何其他终止字符都将用作输入。

读取第一个字符时会抑制退出，以便用户可以输入 `Cg` 。请参阅退出。

如果提供了提示，则它指定一个用于提示用户的字符串。提示字符串始终显示在回显区域中，后跟一个 `-` 。

在以下示例中，用户键入八进制数 `177` （十进制为 `127` ）。

    (read-quoted-char "What character")
    
    ---------- Echo Area ----------
    What character 1 7 7-
    ---------- Echo Area ----------
    
         ⇒ 127


<a id="org391eda0"></a>

### 22.8.6 杂项事件输入功能

本节介绍如何在不使用它们的情况下提前查看事件、如何检查待处理的输入以及如何丢弃待处理的输入。另请参阅函数 `read-passwd` （请参阅读取密码）。

    Variable: unread-command-events ¶

此变量保存等待作为命令输入读取的事件列表。事件按照它们在列表中出现的顺序使用，并在使用时一一删除。

该变量是必需的，因为在某些情况下，函数会读取一个事件，然后决定不使用它。将事件存储在此变量中会导致它被命令循环或函数正常处理以读取命令输入。

例如，实现数字前缀参数的函数读取任意数量的数字。当它发现一个非数字事件时，它必须取消读取该事件，以便它可以被命令循环正常读取。同样，增量搜索使用此功能在搜索中未读没有特殊含义的事件，因为这些事件应该退出搜索然后正常执行。

从键序列中提取事件以将它们放入未读命令事件中的可靠且简单的方法是使用 `listify-key-sequence` （见下文）。

通常，您将事件添加到此列表的前面，以便首先重新读取最近未读的事件。

从此列表中读取的事件通常不会添加到当前命令的键序列（由例如 `this-command-keys` 返回），因为事件在第一次读取时已经添加了一次。(t . event) 形式的元素强制将事件添加到当前命令的键序列中。

从此列表中读取的元素通常由记录保存功能记录（请参阅记录输入）并在定义键盘宏时（请参阅键盘宏）。但是，表单元素 `(no-record . event)` 会导致事件正常处理而不记录它。

    Function: listify-key-sequence key ¶

此函数将字符串或向量键转换为单个事件的列表，您可以将其放入未读命令事件中。

    Function: input-pending-p &optional check-timers ¶

此函数确定当前是否有任何命令输入可供读取。它立即返回，如果有可用的输入则返回值 `t` ，否则返回 `nil` 。在极少数情况下，当没有可用输入时，它可能会返回 `t` 。

如果可选参数 `check-timers` 不为 `nil` ，那么如果没有可用的输入，Emacs 就会运行任何准备好的计时器。请参阅延迟执行的计时器。

    Variable: last-input-event ¶

此变量记录最后读取的终端输入事件，无论是作为命令的一部分还是由 `Lisp` 程序显式读取。

在下面的示例中，Lisp 程序读取字符 `1` ，ASCII 码 `49` 。它成为 `last-input-event` 的值，而 `Ce` （我们假设使用 `Cx Ce` 命令来评估这个表达式）仍然是 `last-command` 的值-事件。

    (progn (print (read-char))
           (print last-command-event)
           last-input-event)
         -| 49
         -| 5
         ⇒ 49

    Macro: while-no-input body… ~¶

~ 此构造运行主体表单并返回最后一个表单的值——但前提是没有输入到达。如果在执行主体表单期间有任何输入到达，它将中止它们（工作很像退出）。while-no-input 形式如果被真正的退出中止，则返回 `nil` ，如果因其他输入的到来而中止，则返回 `t` 。

如果身体的一部分将禁止退出绑定到非零，则在这些部分期间输入的到达不会导致中止，直到该部分结束。

如果您希望能够将 `body` 计算的所有可能值与两种中止条件区分开来，请编写如下代码：

    (while-no-input
      (list
        (progn . body)))

    Variable: while-no-input-ignore-events ¶

此变量允许设置在无输入时应忽略哪些特殊事件。它是一个事件符号列表（参见事件示例）。

    Function: discard-input ¶

此函数丢弃终端输入缓冲区的内容并取消可能在定义过程中的任何键盘宏。它返回零。

在以下示例中，用户可以在开始评估表单后立即键入多个字符。在 `sleep-for` 完成睡眠后，discard-input 会丢弃在睡眠期间键入的所有字符。

    (progn (sleep-for 2)
           (discard-input))
         ⇒  nil


<a id="org84c9ab2"></a>

## 22.9 特别活动

某些特殊事件在非常低的级别上进行处理——一旦它们被读取。read-event 函数自己处理这些事件，并且从不返回它们。相反，它一直等待第一个非特殊事件并返回该事件。

特殊事件不会回显，它们永远不会组合成键序列，并且它们永远不会出现在 `last-command-event` 或 `(this-command-keys)` 的值中。它们不会丢弃数字参数，它们不能被未读命令事件读取，它们可能不会出现在键盘宏中，并且在定义键盘宏时它们不会记录在键盘宏中。

然而，特殊事件确实会在读取后立即出现在 `last-input-event` 中，这是事件定义找到实际事件的方式。

事件类型 `iconify-frame` 、make-frame-visible、delete-frame、drag-n-drop、language-change 和 `sigusr1` 等用户信号通常以这种方式处理。定义如何处理特殊事件（以及哪些事件是特殊事件）的键映射位于变量 `special-event-map` 中（请参阅控制活动键映射）。


<a id="org0fbfc16"></a>

## 22.10 等待经过时间或输入

等待功能旨在等待一定的时间过去或直到有输入。例如，您可能希望在计算过程中暂停，以便用户有时间查看显示。sat-for 暂停并更新屏幕，如果有输入则立即返回，而 `sleep-for` 暂停而不更新屏幕。

    Function: sit-for seconds &optional nodisp ¶

此函数执行重新显示（假设没有来自用户的待处理输入），然后等待几秒钟，或者直到输入可用。静坐的通常目的是让用户有时间阅读您显示的文本。如果 `sit-for` 一直等待而没有输入到达，则该值为 `t` （请参阅杂项事件输入功能）。否则，该值为 `nil` 。

参数 `seconds` 不必是整数。如果它是浮点数，sit-for 会等待一小部分秒数。有些系统只支持整数秒；在这些系统上，秒是向下舍入的。

表达式 `(sit-for 0)` 等价于 `(redisplay)` ，即，如果没有挂起的输入，它会请求重新显示，没有任何延迟。请参阅强制重新显示。

如果 `nodisp` 不为零，则 `sit-for` 不会重新显示，但只要输入可用（或超时时间过去），它仍然会返回。

在批处理模式下（请参阅批处理模式），即使来自标准输入描述符的输入也不能中断静坐。因此它等价于 `sleep-for` ，如下所述。

也可以使用三个参数调用 `sit-for` ，如 `(sit-for seconds millisec nodisp)` ，但这被认为已过时。

    Function: sleep-for seconds &optional millisec ¶

此功能只是暂停几秒钟而不更新显示。它不注意可用的输入。它返回零。

参数 `seconds` 不必是整数。如果是浮点数，sleep-for 会等待一小部分秒数。有些系统只支持整数秒；在这些系统上，秒是向下舍入的。

可选参数毫秒指定额外的等待时间，以毫秒为单位。这会增加以秒为单位的时间段。如果系统不支持等待几分之一秒，那么如果您指定非零毫秒，则会出现错误。

当您希望保证延迟时，请使用 `sleep-for` 。

有关获取当前时间的功能，请参阅时间。


<a id="orgb67ed5e"></a>

## 22.11 退出

在 `Lisp` 函数运行时键入 `Cg` 会导致 `Emacs` 退出它正在执行的任何操作。这意味着控制返回到最里面的活动命令循环。

在命令循环等待键盘输入时键入 `Cg` 不会导致退出；它充当普通输入字符。在最简单的情况下，你是看不出区别的，因为 `Cg` 通常会运行命令 `keyboard-quit` ，其效果是退出。但是，当 `Cg` 跟随前缀键时，它们组合起来形成一个未定义的键。效果是取消前缀键以及任何前缀参数。

在 `minibuffer` 中，Cg 有不同的定义：它中止出 `minibuffer` 。这实际上意味着它退出了 `minibuffer` ，然后退出。（简单地退出会返回到 `minibuffer` 中的命令循环。） `Cg` 在命令阅读器读取输入时不直接退出的原因是，它的含义可以通过这种方式在 `minibuffer` 中重新定义。跟随前缀键的 `Cg` 不会在 `minibuffer` 中重新定义，它具有取消前缀键和前缀参数的正常效果。如果 `Cg` 总是直接退出，这也是不可能的。

当 `Cg` 直接退出时，它通过将变量 `quit-flag` 设置为 `t` 来实现。Emacs 在适当的时候检查这个变量，如果它不是 `nil`  就退出。以任何方式设置 `quit-flag` 非 `nil`  都会导致退出。

在 `C` 代码级别，退出不可能发生在任何地方。仅在检查退出标志的特殊地方。原因是在其他地方退出可能会导致 `Emacs` 内部状态不一致。因为退出被延迟到安全的地方，所以退出不会让 `Emacs` 崩溃。

某些函数，如 `read-key-sequence` 或 `read-quoted-char` 会完全阻止退出，即使它们等待输入。Cg 不是退出，而是作为请求的输入。在 `read-key-sequence` 的情况下，这有助于在命令循环中带来 `Cg` 的特殊行为。在 `read-quoted-char` 的情况下，这是为了让 `Cq` 可以用来引用 `Cg` 。

您可以通过将变量 `inhibitor-quit` 绑定到非 `nil`  值来防止退出 `Lisp` 函数的一部分。然后，尽管 `Cg` 仍然像往常一样将 `quit-flag` 设置为 `t` ，但通常的结果 `-` 退出 `-` 被阻止了。最终，inhibit-quit 将再次变为 `nil` ，例如当它的绑定在 `let` 形式结束时展开。此时，如果 `quit-flag` 仍为非 `nil` ，则请求的退出立即发生。当您希望确保退出不会发生在程序的关键部分时，此行为是理想的。

在某些函数（例如 `read-quoted-char` ）中，Cg 以不涉及退出的特殊方式处理。这是通过在禁止退出绑定到 `t` 的情况下读取输入并在禁止退出再次变为 `nil`  之前将退出标志设置为 `nil`  来完成的。这段 `read-quoted-char` 定义的摘录显示了这是如何完成的；它还表明在输入的第一个字符之后允许正常退出。

    (defun read-quoted-char (&optional prompt)
      "…documentation…"
      (let ((message-log-max nil) done (first t) (code 0) char)
        (while (not done)
          (let ((inhibit-quit first)
    	    …)
    	(and prompt (message "%s-" prompt))
    	(setq char (read-event))
    	(if inhibit-quit (setq quit-flag nil)))
          …set the variable code…)
        code))

    Variable: quit-flag ¶

如果这个变量不为 `nil` ，那么 `Emacs` 会立即退出，除非 `inhibitor-quit` 不为 `nil` 。键入 `Cg` 通常会设置退出标志非零，而不管禁止退出。

    Variable: inhibit-quit ¶

此变量确定当 `quit-flag` 设置为 `nil`  以外的值时 `Emacs` 是否应该退出。如果 `inhibitor-quit` 为非 `nil` ，则 `quit-flag` 没有特殊效果。

    Macro: with-local-quit body… ~¶

~ 此宏按顺序执行主体形式，但允许在主体内至少局部退出，即使在此构造之外禁止退出非零。它返回正文中最后一个表单的值，除非通过退出退出，在这种情况下它返回 `nil` 。

如果在进入 `with-local-quit` 时禁止退出为 `nil` ，它只执行主体，设置退出标志会导致正常退出。但是，如果禁止退出是非零，从而延迟普通退出，则非零退出标志会触发一种特殊的本地退出。这将结束 `body` 的执行并退出 `with-local-quit` 主体，而 `quit-flag` 仍然非 `nil` ，因此一旦允许就会发生另一个（普通）退出。如果在 `body` 的开头 `quit-flag` 已经是非 `nil` ，则本地退出立即发生，并且 `body` 根本不执行。

该宏主要用于可以从计时器、进程过滤器、进程哨兵、命令前挂钩、命令后挂钩和其他通常与 `t` 绑定的地方调用的函数。

    Command: keyboard-quit ¶

该函数用 `(signal 'quit  ~nil` )~ 表示退出条件。这和戒烟一样。（参见错误中的信号。）

要在不中止键盘宏定义或执行的情况下退出，您可以发出 `minibuffer-quit` 条件信号。这与退出条件几乎相同，只是命令循环中的错误处理在不退出键盘宏定义或执行的情况下对其进行处理。

您可以指定 `Cg` 以外的字符用于退出。请参阅输入模式中的函数 `set-input-mode` 。


<a id="org96a77ce"></a>

## 22.12 前缀命令参数

大多数 `Emacs` 命令可以使用前缀参数，即在命令本身之前指定的数字。（不要将前缀参数与前缀键混淆。）前缀参数始终由一个值表示，该值可能为 `nil` ，这意味着当前没有前缀参数。每个命令都可以使用前缀参数或忽略它。

前缀参数有两种表示形式：原始和数字。编辑器命令循环在内部使用原始表示，存储信息的 `Lisp` 变量也是如此，但命令可以请求任何一种表示。

以下是原始前缀参数的可能值：

 `nil` ，表示没有前缀参数。它的数值是 `1` ，但许多命令都将 `nil`  和整数 `1` 区分开来。
一个整数，代表它自己。
一个元素的列表，它是一个整数。这种形式的前缀参数是由一个或一系列没有数字的 `C-us` 产生的。数值是列表中的整数，但有些命令会区分这样的列表和单独的整数。
符号-。这表明输入了 `M-` 或 `Cu -` ，没有后面的数字。等效的数值是 `-1` ，但有些命令会区分整数 `-1` 和符号 `-` 。

我们通过使用各种前缀调用以下函数来说明这些可能性：

    (defun display-prefix (arg)
      "Display the value of the raw prefix arg."
      (interactive "P")
      (message "%s" arg))

以下是使用各种原始前缀参数调用 `display-prefix` 的结果：

          M-x display-prefix  -| nil
    
    C-u     M-x display-prefix  -| (4)
    
    C-u C-u M-x display-prefix  -| (16)
    
    C-u 3   M-x display-prefix  -| 3
    
    M-3     M-x display-prefix  -| 3      ; (Same as C-u 3.)
    
    C-u -   M-x display-prefix  -| -
    
    M--     M-x display-prefix  -| -      ; (Same as C-u -.)
    
    C-u - 7 M-x display-prefix  -| -7
    
    M-- 7   M-x display-prefix  -| -7     ; (Same as C-u -7.)

Emacs 使用两个变量来存储前缀参数：prefix-arg 和 `current-prefix-arg` 。为其他命令设置前缀参数的命令（例如通用参数）将它们存储在前缀参数中。相反， `current-prefix-arg` 将前缀参数传达给当前命令，因此设置它对未来命令的前缀参数没有影响。

通常，命令在交互式规范中指定用于前缀参数的表示形式，无论是数字还是原始。（请参阅使用交互。）或者，函数可以直接在变量 `current-prefix-arg` 中查看前缀参数的值，但这不太干净。

    Function: prefix-numeric-value arg ¶

此函数返回有效的原始前缀参数值 `arg` 的数值含义。参数可以是符号、数字或列表。如果为 `nil` ，则返回值 `1` ；如果是-，则返回值-1；如果是数字，则返回该数字；如果它是一个列表，则返回该列表的 `CAR` （应该是一个数字）。

    Variable: current-prefix-arg ¶

此变量保存当前命令的原始前缀参数。命令可以直接检查它，但访问它的常用方法是使用（交互式 `P` ）。

    Variable: prefix-arg ¶

此变量的值是下一个编辑命令的原始前缀参数。为以下命令指定前缀参数的命令（例如通用参数）通过设置此变量来工作。

    Variable: last-prefix-arg ¶

上一个命令使用的原始前缀参数值。

存在以下命令来为以下命令设置前缀参数。不要因为任何其他原因打电话给他们。

    Command: universal-argument ¶

此命令读取输入并为以下命令指定前缀参数。除非您知道自己在做什么，否则不要自己调用此命令。

    Command: digit-argument arg ¶

此命令添加到以下命令的前缀参数。参数 `arg` 是该命令之前的原始前缀参数；它用于计算更新的前缀参数。除非您知道自己在做什么，否则不要自己调用此命令。

    Command: negative-argument arg ¶

此命令添加到下一个命令的数字参数。参数 `arg` 是该命令之前的原始前缀参数；它的值被否定以形成新的前缀参数。除非您知道自己在做什么，否则不要自己调用此命令。


<a id="orgc8a4849"></a>

## 22.13 递归编辑

Emacs 启动时会自动进入 `Emacs` 命令循环。命令循环的这种顶级调用永远不会退出；只要 `Emacs` 运行，它就会一直运行。Lisp 程序也可以调用命令循环。由于这会激活不止一次的命令循环，我们称之为递归编辑。递归编辑级别具有暂停调用它的任何命令并允许用户在恢复该命令之前进行任意编辑的效果。

递归编辑期间可用的命令与顶级编辑循环中可用的命令相同，并在键盘映射中定义。只有少数特殊命令退出递归编辑级别；其他人完成后返回递归编辑级别。（退出的特殊命令总是可用的，但是当递归编辑没有进行时它们什么都不做。）

所有命令循环，包括递归循环，都设置了通用错误处理程序，以便从命令循环运行的命令中的错误不会退出循环。

Minibuffer 输入是一种特殊的递归编辑。它有一些特殊的皱纹，例如启用 `minibuffer` 和 `minibuffer` 窗口的显示，但比您想象的要少。某些键在 `minibuffer` 中的行为不同，但这只是因为 `minibuffer` 的本地映射；如果你切换窗口，你会得到通常的 `Emacs` 命令。

要调用递归编辑级别，请调用函数 `recursive-edit` 。该函数包含命令循环；它还包含对带有标签 `exit` 的 `catch` 的调用，这使得可以通过 `throw` 退出递归编辑级别（请参阅显式非本地退出：catch 和 `throw` ）。抛出 `value` 会导致 `recursive-edit` 退出，以便控制返回到上一级的命令循环。这称为中止，由 `C-] (abort-recursive-edit)` 完成。同样，您可以抛出一个字符串值以使递归编辑信号出错，并将此字符串打印为消息。如果你抛出一个函数，recursive-edit 将在返回之前不带参数地调用它。抛出任何其他值，将使递归编辑正常返回到调用它的函数。命令 `CMc (exit-recursive-edit)` 执行此操作。

大多数应用程序不应该使用递归编辑，除非作为使用 `minibuffer` 的一部分。通常将当前缓冲区的主模式临时更改为特殊的主模式对用户来说更方便，它应该有一个命令返回到以前的模式。（Rmail 中的 `e` 命令使用这种技术。）或者，如果您希望为用户提供不同的文本以递归地编辑，请在特殊模式下创建并选择一个新缓冲区。在这种模式下，定义一个命令来完成处理并返回到上一个缓冲区。（Rmail 中的 `m` 命令执行此操作。）

递归编辑在调试中很有用。您可以将调试调用作为一种断点插入到函数定义中，以便在函数到达那里时可以环顾四周。debug 调用递归编辑，但也提供调试器的其他功能。

当您在 `query-replace` 中键入 `Cr` 或使用 `Cx q (kbd-macro-query)` 时，也会使用递归编辑级别。

    Command: recursive-edit ¶

此函数调用编辑器命令循环。它由 `Emacs` 的初始化自动调用，让用户开始编辑。当从 `Lisp` 程序调用时，它进入递归编辑级别。

如果当前缓冲区与所选窗口的缓冲区不同，递归编辑将保存并恢复当前缓冲区。否则，如果您切换缓冲区，则您切换到的缓冲区在递归编辑返回后是当前的。

在下面的示例中，函数 `simple-rec` 首先前进一个单词，然后进入递归编辑，在回显区域打印出一条消息。然后用户可以进行任何所需的编辑，然后键入 `CMc` 退出并继续执行 `simple-rec` 。

    (defun simple-rec ()
      (forward-word 1)
      (message "Recursive edit in progress")
      (recursive-edit)
      (forward-word 1))
         ⇒ simple-rec
    (simple-rec)
         ⇒ nil

    Command: exit-recursive-edit ¶

该函数从最里面的递归编辑（包括 `minibuffer` 输入）中退出。它的定义是有效的（抛出'exit nil）。

    Command: abort-recursive-edit ¶

此函数通过在退出递归编辑后发出 `quit` 信号来中止请求最内层递归编辑（包括 `minibuffer` 输入）的命令。它的定义是有效的（throw 'exit t）。请参阅退出。

    Command: top-level ¶

该函数退出所有递归编辑级别；它不返回值，因为它完全跳出任何计算直接回到主命令循环。

    Function: recursion-depth ¶

此函数返回递归编辑的当前深度。当没有递归编辑处于活动状态时，它返回 `0` 。

禁用命令会将命令标记为需要用户确认才能执行。禁用用于可能使初学者感到困惑的命令，以防止他们意外使用命令。

禁用命令的低级机制是在命令的 `Lisp` 符号上放置一个非 `nil`  禁用属性。这些属性通常由用户的初始化文件（参见初始化文件）使用 `Lisp` 表达式设置，如下所示：

    (put 'upcase-region 'disabled t)

对于一些命令，这些属性默认存在（如果您愿意，可以在初始化文件中删除它们）。

如果 `disabled` 属性的值是字符串，则说明命令已禁用的消息包括该字符串。例如：

    (put 'delete-region 'disabled
         "Text deleted this way cannot be yanked back!\n")

有关交互式调用禁用命令时发生的情况的详细信息，请参见 `GNU Emacs` 手册中的禁用。禁用命令对从 `Lisp` 程序中将其作为函数调用没有影响。

    Command: enable-command command ¶

从现在开始允许在没有特别确认的情况下执行命令（一个符号），并更改用户的 `init` 文件（请参阅 `The Init File` ），以便将其应用于未来的会话。

    Command: disable-command command ¶

从现在开始需要特别确认才能执行命令，并更改用户的 `init` 文件，以便将其应用于未来的会话。

    Variable: disabled-command-function ¶

这个变量的值应该是一个函数。当用户以交互方式调用禁用命令时，将调用此函数而不是禁用命令。它可以使用 `this-command-keys` 来确定用户键入什么来运行命令，从而找到命令本身。

该值也可能为零。然后所有命令都可以正常工作，甚至是禁用的命令。

默认情况下，该值是一个询问用户是否继续的函数。


<a id="org2cfc126"></a>

## 22.15 命令历史

命令循环保留已执行的复杂命令的历史记录，以便于重复这些命令。复杂命令是交互式参数读取使用迷你缓冲区的命令。这包括任何 `Mx` 命令、任何 `M-:` 命令以及任何其交互规范从 `minibuffer` 中读取参数的命令。在命令本身执行期间显式使用迷你缓冲区不会导致命令被认为是复杂的。

    Variable: command-history ¶

该变量的值是最近的复杂命令的列表，每个都表示为要评估的形式。它在编辑会话期间继续累积所有复杂命令，但是当它达到最大大小时（请参阅 `Minibuffer History` ），随着新元素的添加，最旧的元素将被删除。

    command-history
    ⇒ ((switch-to-buffer "chistory.texi")
        (describe-key "^X^[")
        (visit-tags-table "~/emacs/src/")
        (find-tag "repeat-complex-command"))

这个历史列表实际上是 `minibuffer` 历史的一个特例（参见 `Minibuffer History` ），有一个特殊的转折：元素是表达式而不是字符串。

有许多命令专门用于编辑和调用以前的命令。命令 `repeat-complex-command` 和 `list-command-history` 在用户手册中有描述（参见 `GNU Emacs` 手册中的重复）。在 `minibuffer` 中，可以使用常用的 `minibuffer` 历史命令。


<a id="orgda4a446"></a>

## 22.16 键盘宏

键盘宏是输入事件的固定序列，可以将其视为命令并定义键。键盘宏的 `Lisp` 表示是包含事件的字符串或向量。不要将键盘宏与 `Lisp` 宏混淆（参见宏）。

    Function: execute-kbd-macro kbdmacro &optional count loopfunc ¶

此函数将 `kbdmacro` 作为一系列事件执行。如果 `kbdmacro` 是一个字符串或向量，那么其中的事件将完全按照用户输入的方式执行。该序列不应是单个键序列；通常，键盘宏定义由多个连接的键序列组成。

如果 `kbdmacro` 是一个符号，则使用它的函数定义代替 `kbdmacro` 。如果那是另一个符号，则重复此过程。最终结果应该是一个字符串或向量。如果结果不是符号、字符串或向量，则会发出错误信号。

参数计数是重复计数；kbdmacro 执行了很多次。如果 `count` 被省略或为零，kbdmacro 将执行一次。如果为 `0` ，kbdmacro 会反复执行，直到遇到错误或搜索失败。

如果 `loopfunc` 不是 `nil` ，它是一个在宏的每次迭代之前被调用的函数，没有参数。如果 `loopfunc` 返回 `nil` ，则停止执行宏。

有关使用 `execute-kbd-macro` 的示例，请参阅阅读一个事件。

    Variable: executing-kbd-macro ¶

此变量包含定义当前正在执行的键盘宏的字符串或向量。如果当前没有宏正在执行，则为 `nil` 。命令可以测试此变量，以便在从执行宏运行时表现不同。不要自己设置这个变量。

    Variable: defining-kbd-macro ¶

当且仅当定义了键盘宏时，此变量才非零。一个命令可以测试这个变量，以便在定义宏时表现不同。该值在附加到现有宏的定义时附加。命令 `start-kbd-macro` 、kmacro-start-macro 和 `end-kbd-macro` 设置这个变量——不要自己设置。

该变量始终是当前终端的本地变量，并且不能是缓冲区本地的。请参阅多个终端。

    Variable: last-kbd-macro ¶

这个变量是最近定义的键盘宏的定义。它的值是一个字符串或向量，或 `nil` 。

该变量始终是当前终端的本地变量，并且不能是缓冲区本地的。请参阅多个终端。

    Variable: kbd-macro-termination-hook ¶

这个正常的钩子在键盘宏终止时运行，不管是什么导致它终止（到达宏结束或过早结束宏的错误）。

