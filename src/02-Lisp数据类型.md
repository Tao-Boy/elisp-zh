
# 2 Lisp 数据类型

`Lisp` 对象是 `Lisp` 程序使用和操作的一段数据。对于我们的目的，类型或数据类型是一组可能的对象。

每个对象至少属于一种类型。相同类型的对象具有相似的结构，通常可以在相同的上下文中使用。类型可以重叠，对象可以属于两种或多种类型。因此，我们可以询问对象是否属于特定类型，但不能询问对象的类型。

Emacs 中内置了一些基本的对象类型。这些，所有其他类型的构造，被称为原始类型。每个对象都属于一种且仅一种原始类型。这些类型包括 `intege` 、 `float` 、 `cons` 、 `symbol` 、 `string` 、 `vector` 、 `hash-table` 、 `subr` 、 `byte-code function` 和 `record` ，以及与编辑相关的几种特殊类型，如缓冲区。（请参阅编辑类型。）

每个原始类型都有一个相应的 `Lisp` 函数，用于检查对象是否是该类型的成员。

`Lisp` 与许多其他语言的不同之处在于它的对象是自类型化的：每个对象的原始类型都隐含在对象本身中。例如，如果一个对象是一个向量，那么没有任何东西可以将它视为一个数字； `Lisp` 知道它是一个向量，而不是一个数字。

在大多数语言中，程序员必须声明每个变量的数据类型，并且类型是编译器知道的，但不会在数据中表示出来。Emacs Lisp 中不存在这样的类型声明。Lisp 变量可以具有任何类型的值，并且它会记住您存储在其中的任何值，类型和所有内容。（实际上，少数 `Emacs Lisp` 变量只能接受某种类型的值。请参阅带限制值的变量。）

本章描述了 `GNU Emacs Lisp` 中每种标准类型的用途、打印表示和阅读语法。关于如何使用这些类型的详细信息可以在后面的章节中找到。


<a id="org72b59fd"></a>

## 2.1 打印表示和读取语法

对象的打印表示是 `Lisp` 打印机（函数 `prin` ）为该对象生成的输出格式。每种数据类型都有唯一的打印表示。对象的读取语法是 `Lisp` 阅读器（函数 `rea` ）为该对象接受的输入格式。这不一定是唯一的； 许多种类的对象有不止一种语法。请参阅阅读和打印 `Lisp` 对象。

在大多数情况下，对象的打印表示也是对象的读取语法。然而，有些类型没有读语法，因为在 `Lisp` 程序中将这些类型的对象作为常量输入是没有意义的。这些对象以散列符号打印，由字符 `#<` 、描述性字符串（通常是类型名称后跟对象名称）和结束符号 `>` 组成。例如：

    (current-buffer)
          ⇒ #<buffer objects.texi>

哈希表示法根本无法读取，因此 `Lisp` 阅读器在遇到 '#<' 时会发出错误无效读取语法的信号。

在其他语言中，表达式是文本； 它没有其他形式。在 `Lisp` 中，表达式主要是 `Lisp` 对象，其次是作为对象读取语法的文本。很多时候不需要强调这个区别，但是一定要放在脑后，不然偶尔会很迷茫。

当您以交互方式评估表达式时，Lisp 解释器首先读取它的文本表示，生成一个 `Lisp` 对象，然后评估该对象（请参阅评估）。但是，评估和阅读是不同的活动。Reading 返回所读文本所代表的 `Lisp` 对象；  该对象以后可能会或可能不会被评估。有关读取的描述，请参阅输入函数，读取对象的基本函数。


<a id="org9e68efb"></a>

## 2.2 特殊读语法

Emacs Lisp 通过特殊的散列符号表示许多特殊的对象和结构。

    ‘#<…>’

没有读取语法的对象是这样显示的（请参阅 `Printed Representation` 和读取语法）。

    ‘##’

名称为空字符串的内部符号的打印表示形式（请参阅符号类型）。

    ‘#'’

这是函数的快捷方式，请参阅匿名函数。

    ‘#:’

名称为 `foo` 的非内部符号的打印表示是 '#:foo'（请参阅符号类型）。

    ‘#N’

打印循环结构时，此构造用于表示结构循环回到自身的位置，'N' 是起始列表计数：

    (let ((a (list 1)))
      (setcdr a a))
    => (1 . #0)

    ‘#N=’
    ‘#N#’

'#N=' 给出对象的名称，而 `'#N#'` 表示该对象，因此在读回对象时，它们将是同一个对象而不是副本（请参阅循环对象的读取语法）。

    ‘#xN’

'N' 表示为十六进制数 ('#x2a')。

    ‘#oN’

'N' 表示为八进制数 ('#o52')。

    ‘#bN’

'N' 表示为二进制数 ('#b101010')。

    ‘#(…)’

字符串文本属性（请参阅字符串中的文本属性）。

    ‘#^’

一个字符表（请参阅字符表类型）。

    ‘#s(hash-table …)’

哈希表（请参阅哈希表类型）。

    ‘?C’

一个字符（请参阅基本字符语法）。

    ‘#$’

字节编译文件中的当前文件名（请参阅文档字符串和编译）。这并不意味着在 `Emacs Lisp` 源文件中使用。

    ‘#@N’

跳过接下来的 `N` 个字符（见评论）。这在字节编译文件中使用，并不意味着在 `Emacs Lisp` 源文件中使用。


<a id="org7032f29"></a>

## 2.3 注释

注释是写在程序中的文本，仅供阅读程序的人使用，对程序的含义没有影响。在 `Lisp` 中，如果未转义的分号 `(';')` 不在字符串或字符常量内，则它会开始注释。注释继续到行尾。Lisp 阅读器会丢弃注释；  它们不会成为 `Lisp` 对象的一部分，这些对象代表 `Lisp` 系统中的程序。

'#@count' 结构会跳过下一个 `count` 字符，对于程序生成的包含二进制数据的注释很有用。Emacs Lisp 字节编译器在其输出文件中使用它（参见字节编译）。但是，它不适用于源文件。

有关格式化评论的约定，请参阅撰写评论的技巧。


<a id="org59c91e0"></a>

## 2.4 编程类型

Emacs Lisp 中的类型一般分为两类：与 `Lisp` 编程有关的类型，以及与编辑有关的类型。前者以一种或另一种形式存在于许多 `Lisp` 实现中。后者是 `Emacs Lisp` 独有的。


<a id="orgdc33a20"></a>

### 2.4.1 整数类型

在底层，有两种整数——称为fixnums的小整数和称为bignums的大整数。

fixnum 的值范围取决于机器。最小范围是 `-536,870,912` 到 `536,870,91` （30 位；即 `-2**29` 到 2\*\*29 - 1），但许多机器提供的范围更广。

Bignums 可以具有任意精度。溢出 `fixnum` 的操作将改为返回 bignum。

所有数字都可以用 `eql` 或 `=` 进行比较； ~ fixnums~ 也可以与 `eq` 进行比较。要测试一个整数是 `fixnum` 还是 `bignu` ，您可以将其与 `most-negative-fixnum` 和 `most-positive-fixnum` 进行比较，或者您可以在任何对象上使用便利谓词 `fixnump` 和 bignump。

整数的读取语法是一个（以十为基数）数字序列，开头有一个可选的符号，结尾有一个可选的句点。Lisp 解释器生成的打印表示从不具有前导 `+` 或结尾 `.` 。

    -1               ; The integer -1.
    1                ; The integer 1.
    1.               ; Also the integer 1.
    +1               ; Also the integer 1.

有关详细信息，请参阅数字。


<a id="org4c74bd1"></a>

### 2.4.2 浮点型

浮点数是科学记数法的计算机等价物； 您可以将浮点数视为分数加上 `10` 的幂。有效数字的精确数量和可能的指数范围是特定于机器的； `Emacs` 使用C数据类型double来存储值，在内部它记录的是 `2` 的幂，而不是 `10` 的幂。

浮点数的打印表示需要一个小数点（后面至少有一个数字），一个指数，或两者兼而有之。例如'1500.0', '+15e2', '15.0e+2', '+1500000e-3', '.15e4' 是浮点数1500的五种写法，它们都是等价的.

有关详细信息，请参阅数字。


<a id="org81ce445"></a>

### 2.4.3 字符类型

Emacs Lisp 中的字符只不过是一个整数。换句话说，字符由它们的字符代码表示。例如，字符 `A` 表示为整数 65。

程序中偶尔会使用单个字符，但更常见的是使用字符串，它是由字符组成的序列。请参阅字符串类型。

字符串和缓冲区中的字符目前限制在 `0` 到 `4194303` 的范围内——22 位（参见字符代码）。代码 `0` 到 `127` 是 `ASCII` 代码； 其余的是非 `ASCII` （请参阅非 `ASCII` 字符）。代表键盘输入的字符范围更广，可以对修饰键（如 `Contro` 、Meta 和 Shift）进行编码。

为了消息的缘故，有一些特殊的函数可以生成人类可读的字符文本描述。请参阅描述帮助消息的字符。

1.  2.4.3.1 基本字符语法

    由于字符实际上是整数，因此字符的打印表示是十进制数。这也是字符的一种可能的读取语法，但在 `Lisp` 程序中以这种方式编写字符并不是清晰的编程。您应该始终使用 `Emacs Lisp` 为字符提供的特殊读取语法格式。这些语法格式以问号开头。
    
    字母数字字符的通常读取语法是问号后跟字符； 因此， `?A` 表示字符 A， `?B` 表示字符 B， `?a` 表示字符 a。
    
    例如：
    
        ?Q ⇒ 81     ?q ⇒ 113
    
    您可以对标点字符使用相同的语法。但是，如果标点符号在 `Lisp` 中具有特殊的句法含义，则必须用 `'\'` 将其引用。例如，'?\\(' 是左括号字符的书写方式。同样，如果字符是 `'\` ，则必须使用第二个 `'\'` 来引用它：'?\\\\'。
    
    您可以将字符 `control-` 、退格、制表符、换行符、垂直制表符、换页、空格、回车、del 和转义表示为 `'?\a` 、'?\b'、'?\t'、'?\\ n'、'?\v'、'?\f'、'?\s'、'?\r'、'?\d' 和 `'?\e` 。（'?\s' 后跟一个破折号有不同的含义——它将 `Super` 修饰符应用于后面的字符。）因此，
    
        ?\a ⇒ 7                 ; control-g, C-g
        ?\b ⇒ 8                 ; backspace, BS, C-h
        ?\t ⇒ 9                 ; tab, TAB, C-i
        ?\n ⇒ 10                ; newline, C-j
        ?\v ⇒ 11                ; vertical tab, C-k
        ?\f ⇒ 12                ; formfeed character, C-l
        ?\r ⇒ 13                ; carriage return, RET, C-m
        ?\e ⇒ 27                ; escape character, ESC, C-[
        ?\s ⇒ 32                ; space character, SPC
        ?\\ ⇒ 92                ; backslash character, \
        ?\d ⇒ 127               ; delete character, DEL
    
    这些以反斜杠开头的序列也称为转义序列，因为反斜杠扮演转义字符的角色； 这与字符 `ESC` 无关。'\s' 用于字符常量； 在字符串常量中，只写空格。
    
    在没有特殊转义含义的任何字符之前允许使用反斜杠，并且无害； 因此，'?\\+' 等价于 `'?+` 。没有理由在大多数字符之前添加反斜杠。但是，您必须在任何字符 `'()[]\;"'` 之前添加反斜杠，并且应该在任何字符 ``'|'`#.,'`` 之前添加反斜杠，以避免混淆用于编辑 `Lisp` 的 `Emacs` 命令代码。您还应该在类似于前面提到的 `ASCII` 字符的 `Unicode` 字符之前添加反斜杠，以避免混淆阅读您的代码的人。Emacs 将突出显示一些非转义的常见混淆字符，例如 `'''` 以鼓励这一点。您还可以添加在空格字符（例如空格、制表符、换行符和换页符）之前的反斜杠。但是，使用易于阅读的转义序列之一（例如 `'\t'` 或 '\s'）而不是实际的空格字符（例如一个制表符或一个空格。（如果你写反斜杠后跟一个空格，你应该在字符常量后面写一个额外的空格来将它与下面的文本分开。）

2.  2.4.3.2 通用转义语法

    除了特殊重要控制字符的特定转义序列之外，Emacs 还提供了几种类型的转义语法，您可以使用它们来指定非 `ASCII` 文本字符。
    
    1.  您可以通过其 `Unicode` 名称指定字符（如果有）。?\N{NAME} 表示名为 `NAME` 的 `Unicode` 字符。因此，'?\N{LATIN SMALL LETTER A WITH GRAVE}' 等价于 ?à 并表示 `Unicode` 字符 U+00E0。为了简化输入多行字符串，您可以将名称中的空格替换为非空的空白序列（例如，换行符）。
    2.  您可以通过其 `Unicode` 值指定字符。?\N{U+X} 表示具有 `Unicode` 代码点 `X` 的字符，其中 `X` 是十六进制数。此外，?\uxxxx 和 `?\Uxxxxxxxx` 分别表示代码点 `xxxx` 和 `xxxxxxx` ，其中每个 `x` 是单个十六进制数字。例如，?\N{U+E0}、?\u00e0 和 `?\U000000E0` 都等价于 `à` 和 `'?\N{LATIN SMALL LETTER A WITH GRAVE}` 。Unicode 标准仅定义代码点至 `'U+10ffff` ，因此如果您指定的代码点高于此，Emacs 会发出错误信号。
    3.  您可以通过十六进制字符代码指定字符。十六进制转义序列由反斜杠、 `x` 和十六进制字符代码组成。因此，'?\x41' 是字符，'?\x1' 是字符 `Ca` ，而 ?\xe0 是字符 à（带有重音的 a）。您可以使用任意数量的十六进制数字，因此您可以用这种方式表示任何字符代码。
    4.  您可以通过八进制字符代码指定字符。一个八进制转义序列由一个反斜杠后跟最多三个八进制数字组成； 因此，字符 `A` 为 `?\101` ，字符 `Ca` 为 `?\001` ，字符 `Cb` 为 `?\00` 。只能以这种方式指定八进制代码 `777` 以内的字符。
    
    这些转义序列也可以用在字符串中。请参阅字符串中的非 `ASCII` 字符。

3.  2.4.3.3 控制字符语法

    可以使用另一种读取语法来表示控制字符。这由一个问号后跟一个反斜杠、插入符号和相应的非控制字符组成，无论是大写还是小写。例如，'?\\<sup>I</sup>' 和 `'?\^i'` 都是字符 `Ci` 的有效读取语法，该字符的值为 9。
    
    您可以使用 `'C-'` 代替 `'^` ； 因此，'?\C-i' 等价于 `'?\^I'` 和 '?\\<sup>i</sup>'：
    
        ?\^I ⇒ 9     ?\C-I ⇒ 9
    
    在字符串和缓冲区中，唯一允许的控制字符是那些存在于 `ASCII` 中的字符； 但出于键盘输入目的，您可以使用 `C-` 将任何字符转换为控制字符。这些非 `ASCII` 控制字符的字符代码包括 `2**26` 位以及对应的非控制字符的代码。并非所有文本终端都可以生成非 `ASCII` 控制字符，但使用 `X` 和其他窗口系统可以直接生成它们。
    
    由于历史原因，Emacs 将 `DEL` 字符视为 `?` 的控制等价物：
    
        ?\^? ⇒ 127     ?\C-? ⇒ 127
    
    因此，目前无法使用'\C-'来表示字符 `Control-` ，它是 `X` 下有意义的输入字符。改变这一点并不容易，因为各种 `Lisp` 文件都以这种方式引用 DEL。
    
    为了表示要在文件或字符串中找到的控制字符，我们推荐使用 `'^'` 语法； 对于键盘输入中的控制字符，我们更喜欢 `C-` 语法。你用哪一个不影响程序的意思，但可能会指导阅读它的人的理解。

4.  2.4.3.4 元字符语法

    元字符是使用 `META` 修饰键键入的字符。表示此类字符的整数设置了 `2**27` 位。我们为此修饰符和其他修饰符使用高位，以使广泛的基本字符代码成为可能。
    
    在字符串中，附加在 `ASCII` 字符上的 `2**7` 位表示元字符； 因此，可以放入字符串中的元字符的编码范围从 `128` 到 `255` ，并且是普通 `ASCII` 字符的元版本。有关字符串中 `META` 处理的详细信息，请参阅将键盘事件放入字符串中。
    
    元字符的读取语法使用 `'\M-'` 。例如， `'?\M-A'` 代表 `M` 。您可以将 `'\M-'` 与八进制字符代码（见下文）、'\C-' 或任何其他字符语法一起使用。因此，您可以将 `MA` 写为 `'?\M-A'` 或 `'?\M-\101` 。同样，您可以将 `CMb` 写为 `'?\M-\C-b` 、'?\C-\M-b' 或 '?\M-\\002'。

5.  2.4.3.5 其他字符修饰符位

    图形字符的大小写由其字符代码表示； 例如， `ASCII` 区分字符 `a` 和 `A` 。但是 `ASCII` 无法表示控制字符是大写还是小写。Emacs 使用 `2**25` 位来指示在键入控制字符时使用了 `shift` 键。这种区别只有在图形显示上才有可能，例如 `X` 上的 `GUI` 显示； 文本终端不报告区别。移位位的 `Lisp` 语法是 `'\S-` ； 因此，'?\C-&sect;-o' 或 `'?\C-\S-O'` 表示 `shift-control-o` 字符。
    
    X Window 系统定义了另外三个可以在字符中设置的修饰符位： `hyper` 、 `super` 和 `al` 。这些位的语法是 '\H-'、'\s-' 和 '\A-'。（在这些前缀中大小写很重要。）因此，'?\H-\M-\A-x' 代表 Alt-Hyper-Meta-x。（注意，'\s' 后面没有'-' 表示空格字符。）从数值上看，位值是 2\*\*22 用于 alt，2\*\*23 用于 super，2\*\*24 用于 hyper。


<a id="org4824140"></a>

### 2.4.4 符号类型

GNU Emacs Lisp 中的符号是一个有名字的对象。符号名称用作符号的打印表示。在普通的 `Lisp` 使用中，使用一个 obarray（请参阅创建和内部符号），一个符号的名称是唯一的——没有两个符号具有相同的名称。

符号可以用作变量、函数名或保存属性列表。或者它可能仅用于与所有其他 `Lisp` 对象不同，以便可以可靠地识别它在数据结构中的存在。在给定的上下文中，通常只打算使用这些用途中的一种。但是您可以独立地以所有这些方式使用一个符号。

名称以冒号 `(':')` 开头的符号称为关键字符号。这些符号自动充当常量，通常仅通过将未知符号与一些特定替代符号进行比较来使用。请参阅永不改变的变量。

符号名称可以包含任何字符。大多数符号名称由字母、数字和标点符号 `-+=*/` 组成。这样的名称不需要特殊的标点； 只要名称看起来不像数字，名称的字符就足够了。（如果是，请在名称的开头写一个 `\` 以强制解释为符号。）字符 `_`!@$%^&:<>{}?~   很少使用，但也不需要特殊的标点符号。任何其他字符都可以包含在符号名称中，方法是使用反斜杠对其进行转义。然而，与它在字符串中的使用相反，符号名称中的反斜杠只是简单地引用反斜杠后面的单个字符。例如，在字符串中， `'\t'` 代表制表符； 然而，在符号名称中， `'\t'` 仅仅引用了字母 't'。要使名称中包含制表符的符号，您必须实际使用制表符（前面带有反斜杠）。但很少有做这样的事情。

Common Lisp 注意：在 `Common Lisp` 中，小写字母总是折叠成大写字母，除非它们被明确转义。在 `Emacs Lisp` 中，大写和小写字母是不同的。

以下是符号名称的几个示例。请注意，第四个示例中的 `+` 被转义以防止它被读取为数字。在第六个示例中这不是必需的，因为名称的其余部分使其作为数字无效。

    foo                 ; A symbol named ‘foo’.
    FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
    
    1+                  ; A symbol named ‘1+’
    		     ;   (not ‘+1’, which is an integer).
    
    \+1                 ; A symbol named ‘+1’
    		     ;   (not a very readable name).
    
    \(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).
    +-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
    		     ;   These characters need not be escaped.

作为符号名称作为其打印表示的规则的一个例外， `##` 是名称为空字符串的内部符号的打印表示。此外， `'#:foo'` 是名称为 `foo` 的非内部符号的打印表示。（通常，Lisp 阅读器会实习所有符号；请参阅创建和实习符号。）


<a id="orga60f4fd"></a>

### 2.4.5 序列类型

序列是表示一组有序元素的 `Lisp` 对象。Emacs Lisp 中有两种序列：列表和数组。

列表是最常用的序列。列表可以包含任何类型的元素，并且可以通过添加或删除元素轻松更改其长度。有关列表的更多信息，请参阅下一小节。

数组是固定长度的序列。它们进一步细分为字符串、向量、字符表和布尔向量。向量可以包含任何类型的元素，而字符串元素必须是字符，而布尔向量元素必须是 `t` 或  `nil` 。字符表类似于向量，只是它们由任何有效的字符代码索引。字符串中的字符可以像缓冲区中的字符一样具有文本属性（请参阅文本属性），但向量不支持文本属性，即使它们的元素恰好是字符。

列表、字符串和其他数组类型也有重要的相似之处。例如，所有元素的长度都为 `l` ，并且所有元素都有可以从零索引到 `l` 减一的元素。有几个函数，称为序列函数，可以接受任何类型的序列。例如，函数长度报告任何类型的序列的长度。请参阅序列、数组和向量。

通常不可能两次读取相同的序列，因为序列总是在读取时重新创建。如果您将一个序列的读取语法阅读两次，您将得到两个内容相同的序列。有一个例外：空列表 `()` 总是代表同一个对象， `nil` 。


<a id="org042da60"></a>

### 2.4.6 缺点单元格和列表类型

一个 `cons` 单元是一个由两个槽组成的对象，称为 `CAR` 槽和 `CDR` 槽。每个插槽可以容纳任何 `Lisp` 对象。我们还说这个 `cons` 单元的 `CAR` 是它的 `CAR` 槽当前持有的任何对象，对于 `CDR` 也是如此。

列表是一系列 `cons` 单元，它们链接在一起，以便每个 `cons` 单元的 `CDR` 槽保存下一个 `cons` 单元或空列表。空列表实际上是符号 `nil` 。有关详细信息，请参阅列表。因为大多数 cons 单元被用作列表的一部分，所以我们将任何由 `cons` 单元组成的结构称为列表结构。

给 `C` 程序员的注意事项：因此，Lisp 列表作为由 `cons` 单元组成的链表工作。因为 `Lisp` 中的指针是隐式的，所以我们不区分保存值和指向值的 `cons` 单元槽。

因为 `cons` 单元对 `Lisp` 来说非常重要，所以我们也有一个词来表示不是 `cons` 单元的对象。这些对象称为原子。

列表的读取语法和打印表示是相同的，并且由左括号、任意数量的元素和右括号组成。以下是列表示例：

    (A 2 "A")            ; A list of three elements.
    ()                   ; A list of no elements (the empty list).
    nil                  ; A list of no elements (the empty list).
    ("A ()")             ; A list of one element: the string "A ()".
    (A ())               ; A list of two elements: A and the empty list.
    (A nil)              ; Equivalent to the previous.
    ((A B C))            ; A list of one element
    		       ;   (which is a list of three elements).

读取后，括号内的每个对象都成为列表的一个元素。也就是说，为每个元素制作一个 `cons` 单元格。cons cell的CAR slot保存元素，它的CDR slot指向list的下一个cons cell，它保存list中的下一个元素。最后一个 `cons` 信元的 `CDR` 时隙设置为空。

CAR 和 `CDR` 的名称来源于 `Lisp` 的历史。最初的 `Lisp` 实现在 `IBM 704` 计算机上运行，​​它将字分成两部分，地址和减量； `CAR` 是提取寄存器地址部分内容的指令，而 `CDR` 是提取减量内容的指令。相比之下，cons 单元以创建它们的函数 `cons` 命名，而 `cons` 又因其目的而命名，即构建单元。

1.  2.4.6.1 以框图形式绘制列表

    列表可以通过图表来说明，其中 `cons` 单元显示为成对的框，就像多米诺骨牌一样。（Lisp 读者无法阅读这样的插图；与文本符号不同，人类和计算机都可以理解，盒子插图只能由人类理解。）这张图片代表三元素列表（玫瑰紫毛茛）：
    
        --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup
    
    在此图中，每个框代表一个可以容纳或引用任何 `Lisp` 对象的插槽。每对框代表一个 `cons` 单元格。每个箭头表示对 `Lisp` 对象的引用，可以是原子或另一个 `cons` 单元。
    
    在此示例中，保存第一个 `cons` 单元的 `CAR` 的第一个框引用或保存了玫瑰（一个符号）。第二个盒子，保存第一个 `cons` 单元的 `CD` ，指的是下一对盒子，第二个 `cons` 单元。第二个cons cell的CAR是紫色的，它的CDR是第三个cons cell。第三个（也是最后一个）cons 单元的 `CDR` 为零。
    
    这是同一列表的另一个图表（玫瑰紫毛茛），以不同的方式绘制：
    
        ---------------       ----------------       -------------------
        | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
        | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
        |       |       |     |        |       |     |           |       |
        ---------------       ----------------       -------------------
    
    没有元素的列表是空列表； 它与符号 `nil` 相同。换句话说，  `nil` 既是符号又是列表。
    
    这是列表 (A ())，或等效的 (A nil)，用方框和箭头表示：
    
         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> A        --> nil
    
    这是一个更复杂的插图，显示了三元素列表（（松针）橡木枫），其中第一个元素是二元素列表：
    
         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
          |             --> oak      --> maple
          |
          |     --- ---      --- ---
           --> |   |   |--> |   |   |--> nil
        	  --- ---      --- ---
        	   |            |
        	   |            |
        	    --> pine     --> needles
    
    第二个框符号中表示的相同列表如下所示：
    
         --------------       --------------       --------------
        | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
        |   o   |   o------->| oak   |   o------->| maple |  nil |
        |   |   |      |     |       |      |     |       |      |
         -- | ---------       --------------       --------------
            |
            |
            |        --------------       ----------------
            |       | car   | cdr  |     | car     | cdr  |
             ------>| pine  |   o------->| needles |  nil |
        	      |       |      |     |         |      |
        	       --------------       ----------------

2.  2.4.6.2 点对符号

    点对表示法是用于明确表示 `CAR` 和 `CDR` 的 `cons` 单元格的通用语法。在这种语法中，(a . b) 代表一个 `cons` 单元，其 `CAR` 是对象，其 `CDR` 是对象。点对符号比列表语法更通用，因为 `CDR` 不必是列表。但是，在列表语法可以工作的情况下，它会更加麻烦。在点对符号中，列表'(1 2 3)' 写为'(1 . (2 . (3 . nil)))'。对于以 `nil` 结尾的列表，您可以使用任何一种表示法，但列表表示法通常更清晰、更方便。打印列表时，仅当 `cons` 单元的 `CDR` 不是列表时才使用点对符号。
    
    这是一个使用方框来说明点对符号的示例。这个例子显示了这对（玫瑰.紫罗兰）：
    
         --- ---
        |   |   |--> violet
         --- ---
          |
          |
           --> rose
    
    您可以将点对表示法与列表表示法结合起来，以方便地表示具有非 `nil` 最终 `CDR` 的 `cons` 单元链。您在列表的最后一个元素之后写一个点，然后是最后一个 `cons` 单元格的 CDR。例如，（玫瑰紫.毛茛）等价于（玫瑰.（紫罗兰.毛茛））。该对象如下所示：
    
        --- ---      --- ---
          |   |   |--> |   |   |--> buttercup
           --- ---      --- ---
            |            |
            |            |
               --> rose     --> violet
    
    语法（rose.violet.buttercup）是无效的，因为它没有任何含义。如果有的话，它会说将毛茛放在 `CDR` 已经用于紫罗兰色的 `cons` 单元的 `CDR` 中。
    
    列表（玫瑰紫）等价于（玫瑰。（紫罗兰色）），如下所示：
    
         --- ---      --- ---
        |   |   |--> |   |   |--> nil
         --- ---      --- ---
          |            |
          |            |
           --> rose     --> violet
    
    类似地，三元素列表 `(rose Purple buttercup)` 等价于 (rose . (violet . (buttercup)))。它看起来像这样：
    
         --- ---      --- ---      --- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         --- ---      --- ---      --- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup
    
    作为 `(ab . c)` 和 `(a . (b . c))` 等效的一个有点特殊的副作用，为了保持一致性，这意味着如果你在这里用空序列替换 `b` ，那么它遵循 `(a . c)` 和(a . ( . c)) 也是等价的。这也意味着 `(.c)` 等价于 c，但很少使用。

3.  2.4.6.3 关联列表类型

    关联列表或 `alist` 是一个特殊构造的列表，其元素是 `cons` 单元格。在每个元素中，CAR 被认为是一个键，而 `CDR` 被认为是一个关联的值。（在某些情况下，关联值存储在 `CDR` 的 `CAR` 中。）关联列表通常用作堆栈，因为在列表的前面添加或删除关联很容易。
    
    例如，
    
        (setq alist-of-colors
        	'((rose . red) (lily . white) (buttercup . yellow)))
    
    将变量 `alist-of-colors` 设置为包含三个元素的列表。在第一个元素中，rose 是键，red 是值。
    
    有关 `alist` 的进一步说明以及适用于 `alist` 的函数，请参阅关联列表。有关另一种查找表，请参阅哈希表，它在处理大量键时要快得多。


<a id="org4916ed4"></a>

### 2.4.7 数组类型

数组由任意数量的槽组成，用于保存或引用其他 `Lisp` 对象，排列在连续的内存块中。访问数组的任何元素所花费的时间大致相同。相反，访问列表中的元素需要的时间与列表中元素的位置成正比。（访问列表末尾的元素比访问列表开头的元素需要更长的时间。）

Emacs 定义了四种类型的数组：字符串、向量、布尔向量和字符表。

字符串是字符数组，向量是任意对象数组。布尔向量只能包含 `t` 或  `nil`  。这些类型的数组可以有任何长度，直到最大的固定数，受系统架构限制和可用内存的限制。字符表是由任何有效字符代码索引的稀疏数组； 他们可以持有任意对象。

数组的第一个元素的索引为零，第二个元素的索引为 ~ ~ ，依此类推。这称为零原点索引。例如，一个由四个元素组成的数组的索引为 ~ ~ 、1、2 和 3。可能的最大索引值比数组的长度小 1。一旦创建了一个数组，它的长度就固定了。

所有 `Emacs Lisp` 数组都是一维的。（大多数其他编程语言都支持多维数组，但它们不是必需的；嵌套一维数组可以获得相同的效果。）每种类型的数组都有自己的读取语法； 有关详细信息，请参阅以下部分。

数组类型是序列类型的子集，包含字符串类型、向量类型、bool-vector类型和char-table类型。


<a id="org51a5c88"></a>

### 2.4.8 字符串类型

字符串是一个字符数组。字符串在 `Emacs` 中有多种用途，正如在文本编辑器中所预期的那样； ~ 例如，作为 `Lisp` 符号的名称，作为用户的消息，以及表示从缓冲区中提取的文本。Lisp 中的字符串是常量：对字符串的求值返回相同的字符串。

有关对字符串进行操作的函数，请参见字符串和字符。

1.  2.4.8.1 字符串的语法

    字符串的读取语法是双引号、任意数量的字符和另一个双引号， `like this` 。要在字符串中包含双引号，请在其前面加上反斜杠； ~ 因此，"\\"" 是一个只包含一个双引号字符的字符串。同样，您可以通过在它前面加上另一个反斜杠来包含一个反斜杠，例如： `this \\ is a single embedded backslash` 。
    
    换行符在字符串的读取语法中并不特殊； ~ 如果你在双引号之间写一个新行，它就会变成字符串中的一个字符。但是转义的换行符——前面有'\\'的换行符——不会成为字符串的一部分； ~ 即，Lisp 阅读器在读取字符串时会忽略转义的换行符。转义的空格 `\` 同样被忽略。
    
        "It is useful to include newlines
        in documentation strings,
        but the newline is \
        ignored if escaped."
               ⇒ "It is useful to include newlines
        in documentation strings,
        but the newline is ignored if escaped.

2.  2.4.8.2 字符串中的非 `ASCII` 字符

    Emacs 字符串中的非 `ASCII` 字符有两种文本表示：多字节和单字节（请参阅文本表示）。粗略地说，单字节字符串存储原始字节，而多字节字符串存储人类可读的文本。单字节字符串中的每个字符都是一个字节，即其​​值介于 `0` 到 `255` 之间。相比之下，多字节字符串中的每个字符的值可能介于 `0` 到 `4194303` 之间（参见字符类型）。在这两种情况下，大于 `127` 的字符都是非 `ASCII` 字符。
    
    您可以按字面意思在字符串常量中包含非 `ASCII` 字符。如果从多字节源读取字符串常量，例如多字节缓冲区或字符串，或者将作为多字节访问的文件，则 `Emacs` 将每个非 `ASCII` 字符读取为多字节字符并自动将字符串变为多字节字符串。如果字符串常量是从单字节源读取的，那么 `Emacs` 会将非 `ASCII` 字符读取为单字节，并使字符串成为单字节。
    
    您可以使用转义序列将其写为字符代码，而不是按字面意思将字符写入多字节字符串。有关转义序列的详细信息，请参阅通用转义语法。
    
    如果您在字符串常量中使用任何 `Unicode` 样式的转义序列 `'\uNNNN'` 或 `'\U00NNNNNN` （即使是 `ASCII` 字符），Emacs 会自动假定它是多字节的。
    
    您还可以在字符串常量中使用十六进制转义序列 `('\xn')` 和八进制转义序列 `('\n'` 。但要注意：如果字符串常量包含十六进制或八进制转义序列，并且这些转义序列都指定单字节字符（即小于 `25` ），并且字符串中没有其他文字非 `ASCII` 字符或 `Unicode` 样式的转义序列，然后 `Emacs` 自动假定它是一个单字节字符串。也就是说，它假定字符串中出现的所有非 `ASCII` 字符都是 `8` 位原始字节。
    
    在十六进制和八进制转义序列中，转义字符代码可能包含可变数量的数字，因此不是有效的十六进制或八进制数字的第一个后续字符终止转义序列。如果字符串中的下一个字符可以解释为十六进制或八进制数字，请写入 `\` （反斜杠和空格）以终止转义序列。例如，'\xe0\\' 代表一个字符，'a' 带有重音符号。字符串常量中的 `'\'` 就像反斜杠换行符； 它不会为字符串贡献任何字符，但它会终止任何前面的十六进制转义。

3.  2.4.8.3 字符串中的非打印字符

    您可以在字符串常量中使用与字符常量相同的反斜杠转义序列（但不要使用以字符常量开头的问号）。例如，您可以编写一个包含非打印字符 `tab` 和 `Ca` 的字符串，它们之间有逗号和空格，例如： `\t, \Ca` 。有关字符读取语法的说明，请参阅字符类型。
    
    但是，并非所有可以使用反斜杠转义序列编写的字符在字符串中都有效。字符串可以包含的唯一控制字符是 `ASCII` 控制字符。字符串在 `ASCII` 控制字符中不区分大小写。
    
    正确地说，字符串不能包含元字符； ~ 但是当字符串被用作键序列时，有一个特殊的约定提供了一种方法来表示字符串中 `ASCII` 字符的元版本。如果使用 `'\M-'` 语法来指示字符串常量中的元字符，这将设置字符串中字符的 `2**7` 位。如果字符串用于定义键或查找键，则此数字代码将转换为等效的元字符。请参阅字符类型。
    
    字符串不能包含具有 `hype` 、super 或 `alt` 修饰符的字符。

4.  2.4.8.4 字符串中的文本属性

    除了字符本身之外，字符串还可以保存它所包含的字符的属性。这使得在字符串和缓冲区之间复制文本的程序无需特别努力即可复制文本的属性。请参阅文本属性，了解文本属性的含义。具有文本属性的字符串使用特殊的读取和打印语法：
    
        #("characters" property-data...)
    
    其中 `property-data` 由零个或多个元素组成，以三个为一组，如下所示：
    
        beg end plist
    
    元素 `beg` 和 `end` 是整数，它们共同指定字符串中的索引范围； `plist` 是该范围的属性列表。例如，
    
        #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
    
    表示文本内容为 `'foo bar'` 的字符串，其中前三个字符具有值为粗体的面属性，后三个字符具有值为斜体的面属性。（第四个字符没有文本属性，所以它的属性列表是  `nil`  。实际上没有必要以 `nil` 作为属性列表来提及范围，因为任何范围内未提及的任何字符都将默认没有属性。）


<a id="org3b6656b"></a>

### 2.4.9 向量类型

向量是任何类型元素的一维数组。访问向量的任何元素都需要一定的时间。（在列表中，元素的访问时间与元素到列表开头的距离成正比。）

矢量的打印表示由左方括号、元素和右方括号组成。这也是读取语法。像数字和字符串一样，向量被认为是评估的常数。

    [1 "two" (three)]      ; A vector of three elements.
           ⇒ [1 "two" (three)]

有关使用向量的函数，请参阅向量。


<a id="org49e3fed"></a>

### 2.4.10 字符表类型

char-table 是任何类型的元素的一维数组，由字符代码索引。字符表有一些额外的特性，使它们在涉及为字符代码分配信息的许多工作中更有用——例如，字符表可以有一个要继承的父级、一个默认值和少量额外的插槽来用于特殊用途。char-table 还可以为整个字符集指定单个值。

字符表的打印表示就像一个向量，只是在开头有一个额外的 `#^` 。1

有关对字符表进行操作的特殊功能，请参见字符表。字符表的用途包括：

-   案例表（见案例表）。
-   字符类别表（参见类别）。
-   显示表格（请参阅显示表格）。
-   语法表（请参阅语法表）。


<a id="orgd0ee0ef"></a>

### 2.4.11 Bool-Vector 类型

bool-vector 是一个一维数组，其元素必须为 `t` 或  `nil`  。

布尔向量的打印表示类似于字符串，只是它以 `'#&'` 开头，后跟长度。后面的字符串常量实际上将 `bool-vector` 的内容指定为位图——字符串中的每个字符包含 `8` 位，它们指定 `bool-vector` 的下 `8` 个元素（1 代表 ~ ~ ，0 代表  `nil`  ）。字符的最低有效位对应于布尔向量中的最低索引。

    (make-bool-vector 3 t)
       ⇒ #&3"^G"
    (make-bool-vector 3 nil)
       ⇒ #&3"^@"

这些结果是有意义的，因为 `C-g` 的二进制代码是 `11` ，而 `C-@` 是代码为 `0` 的字符。

如果长度不是 `8` 的倍数，则打印的表示会显示额外的元素，但这些额外的元素实际上并没有什么区别。例如，在下一个示例中，两个布尔向量相等，因为只使用了前 `3` 位：

    (equal #&3"\377" #&3"\007")
           ⇒ t


<a id="org59f00df"></a>

### 2.4.12 哈希表类型

哈希表是一种非常快速的查找表，有点像 alist，因为它将键映射到相应的值，但要快得多。哈希表的打印表示指定了它的属性和内容，如下所示：

    (make-hash-table)
         ⇒ #s(hash-table size 65 test eql rehash-size 1.5
    			       rehash-threshold 0.8125 data ())

有关哈希表的更多信息，请参阅哈希表。


<a id="org11eec82"></a>

### 2.4.13 功能类型

Lisp 函数是可执行代码，就像其他编程语言中的函数一样。在 `Lisp` 中，与大多数语言不同，函数也是 `Lisp` 对象。Lisp 中的非编译函数是 `lambda` 表达式：即第一个元素是符号 `lambda` 的列表（请参阅 `Lambda` 表达式）。

在大多数编程语言中，不可能有没有名称的函数。在 `Lisp` 中，函数没有内在名称。lambda 表达式可以作为函数调用，即使它没有名称； ~ 为了强调这一点，我们也称它为匿名函数（参见匿名函数）。Lisp 中的命名函数只是一个在其函数单元中具有有效函数的符号（请参阅定义函数）。

大多数时候，当函数的名称以 `Lisp` 程序中的 `Lisp` 表达式编写时，就会调用函数。但是，您可以在运行时构造或获取函数对象，然后使用原始函数 `funcall` 和 `apply` 调用它。请参阅调用函数。


<a id="org784d8cb"></a>

### 2.4.14 宏类型

Lisp 宏是扩展 `Lisp` 语言的用户定义结构。它被表示为一个与函数非常相似的对象，但具有不同的参数传递语义。Lisp 宏具有列表的形式，其第一个元素是符号宏，其 `CDR` 是 `Lisp` 函数对象，包括 `lambda` 符号。

Lisp 宏对象通常使用内置的 `defmacro` 宏定义，但任何以 `macro` 开头的列表就 `Emacs` 而言都是宏。有关如何编写宏的说明，请参阅宏。

警告：Lisp 宏和键盘宏（参见键盘宏）是完全不同的东西。当我们不加限定地使用 `宏` 这个词时，我们指的是 `Lisp` 宏，而不是键盘宏。


<a id="org1cc3a66"></a>

### 2.4.15 原始函数类型

原始函数是可从 `Lisp` 调用但用 `C` 编程语言编写的函数。原始函数也称为子函数或内置函数。（ `subr` 这个词是从 `subroutine` 派生的。）大多数原始函数在调用它们时都会评估它们的所有参数。不评估其所有参数的原始函数称为特殊形式（请参阅特殊形式）。

函数是否是原始函数对函数的调用者无关紧要。但是，如果您尝试使用用 `Lisp` 编写的函数重新定义原语，这确实很重要。原因是可以直接从 `C` 代码调用原始函数。从 `Lisp` 调用重新定义的函数将使用新定义，但从 `C` 代码调用仍可能使用内置定义。因此，我们不鼓励重新定义原始函数。

术语函数指的是所有 `Emacs` 函数，无论是用 `Lisp` 还是 `C` 编写的。有关用 `Lisp` 编写的函数的信息，请参阅函数类型。

原始函数没有读取语法，并以散列表示法打印子例程的名称。

    (symbol-function 'car)          ; Access the function cell
    				  ;   of the symbol.
         ⇒ #<subr car>
    (subrp (symbol-function 'car))  ; Is this a primitive function?
         ⇒ t                       ; Yes.


<a id="org030d072"></a>

### 2.4.16 字节码函数类型

字节码函数对象是通过字节编译 `Lisp` 代码产生的（参见字节编译）。在内部，字节码函数对象很像一个向量。但是，当它出现在函数调用中时，求值器会特别处理这种数据类型。请参阅字节码函数对象。

字节码函数对象的打印表示和读取语法类似于向量，在开头的 `[` 之前有一个附加的 `#` 。


<a id="org9b288fa"></a>

### 2.4.17 记录类型

记录很像一个向量。但是，第一个元素用于保存由 `type-of` 返回的类型。记录的目的是允许程序员创建具有未内置于 `Emacs` 中的新类型的对象。

有关使用记录的功能，请参阅记录。


<a id="orgf2c8c34"></a>

### 2.4.18 类型描述符

类型描述符是保存有关类型信息的记录。record 中的 `slot 1` 必须是一个命名类型的符号，type-of 依靠这个来返回记录对象的类型。Emacs 没有使用其他类型的描述符槽； ~ 它们可供 `Lisp` 扩展免费使用。

类型描述符的一个示例是 `cl-structure-class` 的任何实例。


<a id="orgaef3484"></a>

### 2.4.19 自动加载类型

自动加载对象是一个列表，其第一个元素是符号自动加载。它存储为符号的函数定义，用作实际定义的占位符。autoload 对象表示真正的定义位于 `Lisp` 代码文件中，必要时应该加载该文件。它包含文件的名称，以及有关实际定义的一些其他信息。

加载文件后，符号应该有一个不是自动加载对象的新函数定义。然后调用新定义，就好像它一开始就在那里一样。从用户的角度来看，函数调用按预期工作，使用加载文件中的函数定义。

自动加载对象通常使用函数 `autoload` 创建，该函数将对象存储在符号的函数单元格中。有关详细信息，请参阅自动加载。


<a id="orgaf088f6"></a>

### 2.4.20 终结器类型

终结器对象帮助 `Lisp` 代码在不再需要的对象之后进行清理。终结器拥有一个 `Lisp` 函数对象。当垃圾回收通过后终结器对象变得不可访问时，Emacs 调用终结器的关联函数对象。在决定终结器是否可访问时，Emacs 不会计算来自终结器对象本身的引用，从而允许您使用终结器而不必担心意外捕获对终结器本身的引用。

终结器中的错误会打印到 `*Messages` 。Emacs 只运行给定终结器对象的关联函数一次，即使该函数失败。

    Function: make-finalizer function

制作一个将运行函数的终结器。当返回的终结器对象变得无法访问时，将在垃圾回收后调用函数。如果终结器对象只能通过来自终结器对象的引用来访问，则在决定是否运行函数时，它不算是可达的。函数将为每个终结器对象运行一次。


<a id="orgf7e72a4"></a>

## 2.5 编辑类型

上一节中的类型用于一般编程目的，其中大部分是大多数 `Lisp` 方言所共有的。Emacs Lisp 提供了几种附加的数据类型，用于与编辑相关的目的。


<a id="orgd5ec29b"></a>

### 2.5.1 缓冲区类型

缓冲区是保存可编辑文本的对象（请参阅缓冲区）。大多数缓冲区保存磁盘文件的内容（请参阅文件），因此可以对其进行编辑，但有些缓冲区用于其他目的。大多数缓冲区也意味着用户可以看到，因此有时会在窗口中显示（参见 `Window` ）。但是缓冲区不需要显示在任何窗口中。每个缓冲区都有一个称为点的指定位置（请参阅位置）； 大多数编辑命令作用于点附近的当前缓冲区的内容。在任何时候，一个缓冲区都是当前缓冲区。

缓冲区的内容很像字符串，但缓冲区的使用不像 `Emacs Lisp` 中的字符串，可用的操作也不同。例如，您可以将文本有效地插入现有缓冲区，更改缓冲区的内容，而将文本插入字符串需要连接子字符串，结果是一个全新的字符串对象。

许多标准的 `Emacs` 函数操作或测试当前缓冲区中的字符； 本手册的一整章专门用于描述这些功能（见正文）。

其他几个数据结构与每个缓冲区相关联：

-   本地语法表（参见语法表）；
-   本地键盘映射（请参阅键盘映射）； 和，
-   缓冲区局部变量绑定列表（请参阅缓冲区局部变量）。
-   叠加（参见叠加）。
-   缓冲区中文本的文本属性（请参阅文本属性）。

本地键映射和变量列表包含单独覆盖全局绑定或值的条目。这些用于自定义不同缓冲区中程序的行为，而无需实际更改程序。

缓冲区可能是间接的，这意味着它共享另一个缓冲区的文本，但呈现方式不同。请参阅间接缓冲区。

缓冲区没有读取语法。它们以哈希表示法打印，显示缓冲区名称。

    (current-buffer)
           ⇒ #<buffer objects.texi>


<a id="orgf813635"></a>

### 2.5.2 标记类型

标记表示特定缓冲区中的位置。因此，标记有两个组成部分：一个用于缓冲区，另一个用于位置。缓冲区文本中的更改会根据需要自动重新定位位置值，以确保标记始终指向缓冲区中相同的两个字符之间。

标记没有读取语法。它们以散列表示法打印，给出当前字符位置和缓冲区名称。

    (point-marker)
           ⇒ #<marker at 10779 in objects.texi>

有关如何测试、创建、复制和移动标记的信息，请参阅标记。


<a id="org56d863c"></a>

### 2.5.3 窗口类型

一个窗口描述了 `Emacs` 用来显示缓冲区的屏幕部分。每个活动窗口（请参阅 `Emacs Windows` 的基本概念）都有一个关联的缓冲区，其内容出现在该窗口中。相比之下，给定的缓冲区可能出现在一个窗口、没有窗口或多个窗口中。窗口在屏幕上被分组为框架； 每个窗口只属于一帧。请参见帧类型。

尽管可能同时存在多个窗口，但在任何时候都会将一个窗口指定为选定窗口（请参阅选择窗口）。这是 `Emacs` 准备好执行命令时（通常）显示光标的窗口。选定的窗口通常会显示当前缓冲区（请参阅当前缓冲区），但不一定如此。

Windows 没有读取语法。它们以哈希表示法打印，给出窗口编号和正在显示的缓冲区的名称。窗口编号的存在是为了唯一标识窗口，因为任何给定窗口中显示的缓冲区都可能经常更改。

    (selected-window)
           ⇒ #<window 1 on objects.texi>

有关在 `Windows` 上工作的功能的描述，请参阅 Windows。


<a id="org0a3bb6c"></a>

### 2.5.4 帧类型

框架是包含一个或多个 `Emacs` 窗口的屏幕区域； ~ 我们还使用术语 `帧` 来指代 `Emacs` 用来指代屏幕区域的 `Lisp` 对象。

帧没有读取语法。它们以哈希表示法打印，给出框架的标题，加上它的核心地址（用于唯一地识别帧）。

    (selected-frame)
           ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>

有关适用于帧的功能的描述，请参阅帧。


<a id="org9296fdb"></a>

### 2.5.5 终端类型

终端是能够显示一个或多个 `Emacs` 帧的设备（请参阅帧类型）。

终端没有读取语法。它们以散列符号打印，给出终端的序号及其 `TTY` 设备文件名。

    (get-device-terminal nil)
           ⇒ #<terminal 1 on /dev/tty>


<a id="org3dcefe4"></a>

### 2.5.6 窗口配置类型

窗口配置在框架中存储有关窗口位置、大小和内容的信息，因此您可以稍后重新创建相同的窗口排列。

窗口配置没有读取语法； 他们的打印语法看起来像'#<window-configuration>'。有关与窗口配置相关的几个功能的描述，请参见窗口配置。


<a id="org16f7dc3"></a>

### 2.5.7 帧配置类型

框架配置存储有关所有框架中窗口的位置、大小和内容的信息。它不是原始类型——它实际上是一个列表，其 `CAR` 为帧配置，其 `CDR` 为 `alis` 。每个 `alist` 元素描述一个帧，该帧显示为该元素的 CAR。

有关与框架配置相关的几个功能的描述，请参见框架配置。


<a id="org48098d0"></a>

### 2.5.8 流程类型

进程一词通常表示正在运行的程序。Emacs 本身就是在这种进程中运行的。但是，在 `Emacs Lisp` 中，进程是一个 `Lisp` 对象，它指定由 `Emacs` 进程创建的子进程。shell、GDB、ftp 和编译器等程序在 `Emacs` 的子进程中运行，扩展了 `Emacs` 的功能。Emacs 子进程从 `Emacs` 获取文本输入并将文本输出返回给 `Emacs` 以供进一步操作。Emacs 也可以向子进程发送信号。

进程对象没有读取语法。它们以哈希表示法打印，并给出进程的名称：

    (process-list)
           ⇒ (#<process shell>)

有关创建、删除、返回有关信息、向进程发送输入或信号以及从进程接收输出的函数的信息，请参阅进程。


<a id="org1b2b5bb"></a>

### 2.5.9 线程类型

Emacs 中的一个线程代表 `Emacs Lisp` 执行的一个单独线程。它运行自己的 `Lisp` 程序，拥有自己的当前缓冲区，并且可以将子进程锁定到它，即只有该线程可以接受其输出的子进程。请参阅线程。

线程对象没有读取语法。它们以哈希表示法打印，给出线程的名称（如果它已被赋予名称）或其在核心中的地址：

    (all-threads)
        ⇒ (#<thread 0176fc40>)


<a id="org054b647"></a>

### 2.5.10 互斥体类型

互斥锁是线程可以拥有和不拥有的排他锁，以便在它们之间进行同步。请参阅互斥体。

互斥对象没有读取语法。它们以哈希表示法打印，给出互斥体的名称（如果它已被命名）或其在核心中的地址：

    (make-mutex "my-mutex")
        ⇒ #<mutex my-mutex>
    (make-mutex)
        ⇒ #<mutex 01c7e4e0>


<a id="org77bf48e"></a>

### 2.5.11 条件变量类型

条件变量是一种用于比互斥锁支持的更复杂的线程同步的设备。一个线程可以等待一个条件变量，当其他线程通知该条件时被唤醒。

条件变量对象没有读取语法。它们以哈希表示法打印，给出条件变量的名称（如果它已被命名）或其在核心中的地址：

    (make-condition-variable (make-mutex))
        ⇒ #<condvar 01c45ae8>


<a id="org15a7b91"></a>

### 2.5.12 流类型

流是可以用作字符源或接收器的对象——既可以为输入提供字符，也可以接受它们作为输出。许多不同的类型可以这样使用：标记、缓冲区、字符串和函数。大多数情况下，输入流（字符源）从键盘、缓冲区或文件中获取字符，而输出流（字符接收器）将字符发送到缓冲区（例如 `*Help*` 缓冲区）或回显区域。

对象  `nil`  除了它的其他含义外，还可以用作流。它代表变量标准输入或标准输出的值。此外，作为流的对象 `t` 指定使用 `minibuffer` 的输入（请参阅 Minibuffers）或回声区域中的输出（请参阅回声区域）。

流没有特殊的打印表示或读取语法，并且可以打印为任何原始类型。

有关与流相关的函数的描述，包括解析和打印函数，请参阅阅读和打印 `Lisp` 对象。


<a id="orgffe48d5"></a>

### 2.5.13 键盘映射类型

键盘映射将用户键入的键映射到命令。此映射控制如何执行用户的命令输入。键映射实际上是一个列表，其 `CAR` 是符号键映射。

有关创建键映射、处理前缀键、本地和全局键映射以及更改键绑定的信息，请参阅键映射。


<a id="orga44dbb4"></a>

### 2.5.14 覆盖类型

覆盖指定应用于缓冲区的一部分的属性。每个覆盖适用于缓冲区的指定范围，并包含一个属性列表（一个列表，其元素是交替的属性名称和值）。覆盖属性用于临时以不同的显示样式呈现缓冲区的一部分。覆盖没有读取语法，并以哈希表示法打印，给出缓冲区名称和位置范围。

有关如何创建和使用叠加层的信息，请参阅叠加层。


<a id="org6e2ea91"></a>

### 2.5.15 字体类型

字体指定如何在图形终端上显示文本。实际上存在三种不同的字体类型——字体对象、字体规范和字体实体——每一种都有略微不同的属性。它们都没有读取语法； ~ 它们的打印语法分别类似于 `'#<font-object>` 、'#<font-spec>' 和 `'#<font-entity>` 。有关这些 `Lisp` 对象的描述，请参阅低级字体表示。


<a id="org25fbea7"></a>

## 2.6 循环对象的读语法

要表示 `Lisp` 对象复合体中的共享或循环结构，您可以使用阅读器构造 `'#n='` 和 '#n#'。

在对象之前使用#n= 标记它以供以后参考； ~ 随后，您可以使用#n# 在另一个地方引用相同的对象。这里，n 是某个整数。例如，这里是如何制作一个列表，其中第一个元素作为第三个元素重复出现：

    (#1=(a) b #1#)

这不同于像这样的普通语法

    ((a) b (a))

这将导致列表的第一个和第三个元素看起来相似但不是同一个 `Lisp` 对象。这显示了差异：

    (prog1 nil
      (setq x '(#1=(a) b #1#)))
    (eq (nth 0 x) (nth 2 x))
         ⇒ t
    (setq x '((a) b (a)))
    (eq (nth 0 x) (nth 2 x))
         ⇒ nil

您还可以使用相同的语法来创建一个循环结构，它作为一个元素出现在其内部。这是一个例子：

    #1=(a #1#)

这将创建一个列表，其第二个元素是列表本身。您可以通过以下方式看到它确实有效：

    (prog1 nil
      (setq x '#1=(a #1#)))
    (eq x (cadr x))
         ⇒ t

如果将变量 `print-circle` 绑定到非零值，Lisp 打印机可以生成此语法来记录 `Lisp` 对象中的循环和共享结构。请参阅影响输出的变量。


<a id="orge977235"></a>

## 2.7 类型谓词

Emacs Lisp 解释器本身不会在调用函数时对传递给函数的实际参数执行类型检查。它不能这样做，因为 `Lisp` 中的函数参数没有声明的数据类型，就像在其他编程语言中那样。因此，由单个函数来测试每个实际参数是否属于该函数可以使用的类型。

所有内置函数都会在适当的时候检查其实际参数的类型，并在参数类型错误时发出错误类型参数错误信号。例如，如果您将参数传递给 `+` 它无法处理，则会发生以下情况：

    (+ 2 'a)
         error→ Wrong type argument: number-or-marker-p, a

如果您希望您的程序以不同的方式处理不同的类型，则必须进行显式类型检查。检查对象类型的最常用方法是调用类型谓词函数。Emacs 对每种类型都有一个类型谓词，以及一些类型组合的谓词。

类型谓词函数有一个参数； 如果参数属于适当的类型，则返回 `t` ，否则返回  `nil`  。遵循谓词函数的一般 `Lisp` 约定，大多数类型谓词的名称以 `p` 结尾。

这是一个使用谓词 `listp` 来检查列表和 `symbolp` 来检查符号的示例。

    (defun add-on (x)
      (cond ((symbolp x)
    	 ;; If X is a symbol, put it on LIST.
    	 (setq list (cons x list)))
    	((listp x)
    	 ;; If X is a list, add its elements to LIST.
    	 (setq list (append x list)))
    	(t
    	 ;; We handle only symbols and lists.
    	 (error "Invalid argument %s in add-on" x))))

这是一个按字母顺序排列的预定义类型谓词表，其中包含对更多信息的引用。

    atom

请参阅atom。

    arrayp

请参阅arrayp。

    bignump

请参阅floatp。

    bool-vector-p

请参阅bool-vector-p。

    booleanp

请参阅booleanp。

    bufferp

请参阅bufferp。

    byte-code-function-p

请参阅byte-code-function-p。

    case-table-p

请参阅case-table-p。

    char-or-string-p

请参阅char-or-string-p。

    char-table-p

请参阅char-table-p。

    commandp

请参阅commandp。

    condition-variable-p

请参阅condition-variable-p。

    consp

请参阅consp。

    custom-variable-p

请参阅custom-variable-p。

    fixnump

请参阅floatp。

    floatp

请参阅floatp。

    fontp

请参阅Low-Level Font Representation。

    frame-configuration-p

请参阅frame-configuration-p。

    frame-live-p

请参阅frame-live-p。

    framep

请参阅framep。

    functionp

请参阅functionp。

    hash-table-p

请参阅hash-table-p。

    integer-or-marker-p

请参阅integer-or-marker-p。

    integerp

请参阅integerp。

    keymapp

请参阅keymapp。

    keywordp

请参阅Variables that Never Change。

    listp

请参阅listp。

    markerp

请参阅markerp。

    mutexp

请参阅mutexp。

    nlistp

请参阅nlistp。

    number-or-marker-p

请参阅number-or-marker-p。

    numberp

请参阅numberp。

    overlayp

请参阅overlayp。

    processp

请参阅processp。

    recordp

请参阅recordp。

    sequencep

请参阅sequencep。

    string-or-null-p

请参阅string-or-null-p。

    stringp

请参阅stringp。

    subrp

请参阅subrp。

    symbolp

请参阅symbolp。

    syntax-table-p

请参阅syntax-table-p。

    threadp

请参阅threadp。

    vectorp

请参阅vectorp。

    wholenump

请参阅wholenump。

    window-configuration-p

请参阅window-configuration-p。

    window-live-p

请参阅window-live-p。

    windowp

请参阅windowp。

检查对象类型的最通用方法是调用函数 `type-o` 。回想一下，每个对象都属于一种且仅一种原始类型； `type-of` 告诉你是哪一个（参见 `Lisp` 数据类型）。但是 `type-of` 对非原始类型一无所知。在大多数情况下，使用类型谓词比使用 `type-of` 更方便。

    Function: type-of object

此函数返回一个符号，命名对象的原始类型。该值是以下符号之一： `bool-vecto` 、buffer、char-table、compiled-function、condition-variable、cons、finalizer、float、font-entity、font-object、font-spec、frame、hash-table、integer 、标记、互斥体、覆盖、进程、字符串、subr、符号、线程、向量、窗口或窗口配置。但是，如果 `object` 是一条记录，则返回其第一个 `slot` 指定的类型； 记录。

    (type-of 1)
         ⇒ integer
    
    (type-of 'nil)
         ⇒ symbol
    (type-of '())    ; () is nil.
         ⇒ symbol
    (type-of '(x))
         ⇒ cons
    (type-of (record 'foo))
         ⇒ foo


<a id="org281a4cd"></a>

## 2.8 等式谓词

在这里，我们描述了测试两个对象之间是否相等的函数。其他函数测试特定类型对象（例如字符串）之间的内容是否相等。对于这些谓词，请参阅描述数据类型的相应章节。

    Function: eq object1 object2

如果 `object1` 和 `object2` 是同一个对象，此函数返回 ~ ~ ，否则返回  `nil`  。

如果 `object1` 和 `object2` 是同名的符号，它们通常是同一个对象——但请参阅创建和内部符号以了解例外情况。对于其他非数字类型（例如，列表、向量、字符串），具有相同内容或元素的两个参数不一定彼此 eq：只有当它们是相同的对象时它们才是 eq，这意味着内容的变化一个的内容将反映在另一个内容的相同变化上。

    (eq 'foo 'foo)
         ⇒ t
    
    
    (eq ?A ?A)
         ⇒ t
    
    
    (eq 3.0 3.0)
         ⇒ t or nil
    ;; Equal floats may or may not be the same object.
    
    
    (eq (make-string 3 ?A) (make-string 3 ?A))
         ⇒ nil
    
    
    (eq "asdf" "asdf")
         ⇒ t or nil
    ;; Equal string constants or may not be the same object.
    
    
    (eq '(1 (2 (3))) '(1 (2 (3))))
         ⇒ nil
    
    
    (setq foo '(1 (2 (3))))
         ⇒ (1 (2 (3)))
    (eq foo foo)
         ⇒ t
    (eq foo '(1 (2 (3))))
         ⇒ nil
    
    
    (eq [(1 2) 3] [(1 2) 3])
         ⇒ nil
    
    
    (eq (point-marker) (point-marker))
         ⇒ nil

make-symbol 函数返回一个 `uninterned` 符号，与在 `Lisp` 表达式中写入名称时使用的符号不同。具有相同名称的不同符号不是 eq。请参阅创建和嵌入符号。

    (eq (make-symbol "foo") 'foo)
         ⇒ nil

Emacs Lisp 字节编译器可能会将相同的文字对象（例如文字字符串）折叠成对同一对象的引用，其效果是字节编译的代码会将此类对象比较为 eq，而同一代码的解释版本则不会。因此，您的代码不应该依赖具有相同文字内容的对象，要么是 eq，要么不是 eq，它应该使用比较对象内容的函数，例如 equal，如下所述。同样，您的代码不应修改文字对象（例如，将文本属性放在文字字符串上），因为这样做可能会影响相同内容的其他文字对象，如果字节编译器折叠它们。

    Function: equal object1 object2

如果 `object1` 和 `object2` 具有相等的分量，则此函数返回 `t` ，否则返回  `nil`  。eq 测试它的参数是否是同一个对象，而 `equal` 则在不同的参数内部查找它们的元素或内容是否相同。因此，如果两个对象是 eq，它们是相等的，但反过来并不总是正确的。

    (equal 'foo 'foo)
         ⇒ t
    
    
    (equal 456 456)
         ⇒ t
    
    
    (equal "asdf" "asdf")
         ⇒ t
    
    (eq "asdf" "asdf")
         ⇒ nil
    
    
    (equal '(1 (2 (3))) '(1 (2 (3))))
         ⇒ t
    
    (eq '(1 (2 (3))) '(1 (2 (3))))
         ⇒ nil
    
    
    (equal [(1 2) 3] [(1 2) 3])
         ⇒ t
    
    (eq [(1 2) 3] [(1 2) 3])
         ⇒ nil
    
    
    (equal (point-marker) (point-marker))
         ⇒ t
    
    
    (eq (point-marker) (point-marker))
         ⇒ nil

字符串的比较区分大小写，但不考虑文本属性——它只比较字符串中的字符。请参阅文本属性。使用 `equal-include-properties` 也可以比较文本属性。出于技术原因，当且仅当单字节字符串和多字节字符串包含相同的字符代码序列并且所有这些代码都在 `0` 到 `127 (ASCII)` 范围内时，它们才相等。

    (equal "asdf" "ASDF")
         ⇒ nil

equal 函数递归地比较对象的内容，如果它们是整数、字符串、标记、向量、布尔向量、字节码函数对象、字符表、记录或字体对象。只有当它们是 `eq` 时，其他对象才被认为是相等的。例如，两个不同的缓冲区永远不会被认为是相等的，即使它们的文本内容相同。

对于相等，相等是递归定义的； ~ 例如，给定两个 `cons` 单元格 `x` 和 ，(equal xy) 当且仅当以下两个表达式都返回 `t` 时返回 t：

    (equal (car x) (car y))
    (equal (cdr x) (cdr y))

因此，比较循环列表可能会导致导致错误的深度递归，这可能会导致违反直觉的行为，例如 `(equal ab)` 返回 `t` 而 `(equal ba)` 表示错误。

    Function: equal-including-properties object1 object2

此函数在所有情况下都表现得像相等，但还要求两个字符串相等，它们具有相同的文本属性。

    (equal "asdf" (propertize "asdf" 'asdf t))
         ⇒ t
    
    (equal-including-properties "asdf"
    			    (propertize "asdf" 'asdf t))
         ⇒ nil


<a id="orga4e13db"></a>

## 2.9 可变性

一些 `Lisp` 对象永远不应该改变。例如，Lisp 表达式 `aaa` 产生一个字符串，但你不应该改变它的内容。并且有些对象是不能改变的； ~ 例如，虽然您可以通过计算一来创建一个新数字，但 `Lisp` 不提供更改现有数字值的操作。

其他 `Lisp` 对象是可变的：通过涉及副作用的破坏性操作来更改它们的值是安全的。例如，可以通过将标记移动到其他位置来更改现有标记。

尽管数字永远不会改变并且所有标记都是可变的，但有些类型的成员有些是可变的，有些则不是。这些类型包括 `conse` 、vectors 和 `string` 。例如，虽然 `"cons"` 和 `(symbol-name 'cons)` 都产生不应更改的字符串，但 `(copy-sequence "cons")` 和 `(make-string 3 ?a)` 都产生可以通过以下方式更改的可变字符串后来调用了资产。

如果可变对象是被评估的表达式的一部分，则它不再是可变的。例如：

    (let* ((x (list 0.5))
           (y (eval (list 'quote x))))
      (setcar x 1.5) ;; The program should not do this.
      y)

尽管列表 `(0.5)` 在创建时是可变的，但它不应该通过 `setcar` 进行更改，因为它是给 `eval` 的。相反的情况不会发生：不应更改的对象之后永远不会变得可变。

如果程序试图更改不应该更改的对象，则结果行为是不确定的：Lisp 解释器可能会发出错误信号，或者它可能会崩溃或以其他方式出现不可预测的行为。 2

当类似的常量作为程序的一部分出现时，Lisp 解释器可能会通过重用现有常量或其组件来节省时间或空间。例如， `(eq "abc" "abc")` 如果解释器只创建字符串文字 `"abc"` 的一个实例，则返回 ，如果它创建两个实例，则返回  `nil`  。应该编写 Lisp 程序，以便无论是否使用此优化，它们都能正常工作。

脚注 (2)

这是为 `Common Lisp` 和 `C` 等语言为常量指定的行为，这与 `JavaScript` 和 `Python` 等语言不同，在这些语言中，如果程序试图更改不可变对象，则需要解释器发出错误信号。理想情况下，Emacs Lisp 解释器将朝后一个方向发展。

