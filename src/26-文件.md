
# 26 文件

本章描述了用于查找、创建、查看、保存以及以其他方式处理文件和目录的 `Emacs Lisp` 函数和变量。缓冲区中描述了其他一些与文件相关的功能，备份和自动保存中描述了与备份和自动保存相关的功能。

许多文件函数采用一个或多个作为文件名的参数。文件名是一个字符串。这些函数中的大多数使用函数 `expand-file-name` 扩展文件名参数，以便正确处理 `以及相对文件名（包括 ~../` 和空字符串）。请参阅扩展文件名的函数。

此外，某些魔术文件名是经过特殊处理的。例如，当指定了远程文件名时，Emacs 通过适当的协议通过网络访问该文件。请参阅 `GNU Emacs` 手册中的远程文件。此处理在非常低的级别完成，因此您可以假设本章中描述的所有函数都接受魔术文件名作为文件名参数，除非另有说明。有关详细信息，请参阅使某些文件名 `神奇` 。

当文件 `I/O` 函数发出 `Lisp` 错误信号时，它们通常使用条件文件错误（请参阅编写代码以处理错误）。在大多数情况下，错误消息是根据语言环境系统消息语言环境从操作系统获得的，并使用编码系统语言环境编码系统（请参阅语言环境）进行解码。


<a id="org615271a"></a>

## 26.1 访问文件

访问文件意味着将文件读入缓冲区。完成后，我们说缓冲区正在访问该文件，并将该文件称为缓冲区的访问文件。

文件和缓冲区是两个不同的东西。文件是永久记录在计算机中的信息（除非您将其删除）。另一方面，缓冲区是 `Emacs` 内部的信息，将在编辑会话结束时（或当您终止缓冲区时）消失。当缓冲区访问文件时，它包含从文件复制的信息。缓冲区中的副本是您使用编辑命令修改的内容。对缓冲区的更改不会更改文件； ~ 要使更改永久化，您必须保存缓冲区，这意味着将更改的缓冲区内容复制回文件中。

尽管文件和缓冲区之间存在区别，但人们通常在指缓冲区时指代文件，反之亦然。实际上，我们会说 `我正在编辑一个文件` ，而不是 `我正在编辑一个缓冲区，我将很快将其保存为同名文件` 。人类通常不需要明确区分。但是，在处理计算机程序时，最好记住区别。


<a id="orge0a42de"></a>

### 26.1.1 文件访问函数

本节介绍通常用于访问文件的函数。由于历史原因，这些函数的名称以 `find-` 而不是 `visit-` 开头。有关访问缓冲区的已访问文件名或通过其已访问文件名查找现有缓冲区的函数和变量，请参阅缓冲区文件名。

在 `Lisp` 程序中，如果您想查看文件的内容但不改变它，最快的方法是在临时缓冲区中使用 `insert-file-contents` 。访问该文件不是必需的，并且需要更长的时间。请参阅从文件中读取。

    Command: find-file filename &optional wildcards ¶

此命令选择一个访问文件文件名的缓冲区，如果存在则使用现​​有缓冲区，否则创建一个新缓冲区并将文件读入其中。它还返回该缓冲区。

除了一些技术细节之外，find-file 函数的主体基本上等同于：

    (switch-to-buffer (find-file-noselect filename nil nil wildcards))

（请参阅在窗口中切换到缓冲区中的切换到缓冲区。）

如果通配符不为零（在交互式调用中总是如此），则 `find-file` 扩展文件名中的通配符并访问所有匹配的文件。

当 `find-file` 以交互方式调用时，它会提示输入 `minibuffer` 中的文件名。

    
    Command: find-file-literally filename ¶

此命令访问文件名，就像 `find-file` 一样，但它不执行任何格式转换（请参阅文件格式转换）、字符代码转换（请参阅编码系统）或行尾转换（请参阅行尾转换）。访问文件的缓冲区是单字节的，它的主要模式是基本模式，与文件名无关。文件中的文件局部变量规范（参见文件局部变量）被忽略，并且由于 `require-final-newline` （参见 `require-final-newline` ）而导致的自动解压和在文件末尾添加换行符也被禁用。

请注意，如果 `Emacs` 已经有一个缓冲区以非字面方式访问同一个文件，它不会从字面上访问同一个文件，而只是切换到现有的缓冲区。如果您想确保从字面上访问文件的内容，您应该创建一个临时缓冲区，然后使用 `insert-file-contents-literally` 将文件内容读入其中（请参阅从文件中读取）。

    
    Function: find-file-noselect filename &optional nowarn rawfile wildcards ¶

这个函数是所有文件访问函数的核心。它返回一个访问文件文件名的缓冲区。如果您愿意，您可以将缓冲区设置为当前缓冲区或将其显示在窗口中，但此功能不会这样做。

如果存在缓冲区，则该函数返回一个现有缓冲区； ~ 否则它会创建一个新缓冲区并将文件读入其中。当 `find-file-noselect` 使用现有缓冲区时，它首先验证文件自上次访问或保存在该缓冲区中以来没有更改。如果文件已更改，此函数会询问用户是否重新读取已更改的文件。如果用户说 `是` ，则先前在缓冲区中所做的任何编辑都将丢失。

读取文件涉及解码文件的内容（请参阅编码系统），包括行尾转换和格式转换（请参阅文件格式转换）。如果通配符不为零，则 `find-file-noselect` 扩展文件名中的通配符并访问所有匹配的文件。

此函数在各种特殊情况下显示警告或建议消息，除非可选参数 `nowarn` 为非零。例如，如果它需要创建一个缓冲区，并且没有名为 `filename` 的文件，它会在回显区域显示消息 `（新文件）` ，并将缓冲区留空。

find-file-noselect 函数通常在读取文件后调用 `after-find-file` （参见访问子程序）。该函数设置缓冲区主模式，解析局部变量，如果存在比刚刚访问的文件更新的自动保存文件，则警告用户，并通过运行 `find-file-hook` 中的函数来完成。

如果可选参数 `rawfile` 不为 `nil` ，则不调用 `after-find-file` ，并且在失败的情况下不运行 `find-file-not-found-functions` 。更重要的是，一个非零原始文件值会抑制编码系统转换和格式转换。

find-file-noselect 函数通常返回正在访问文件文件名的缓冲区。但是，如果实际使用并扩展了通配符，它​​会返回访问各种文件的缓冲区列表。

    (find-file-noselect "/etc/fstab")
         ⇒ #<buffer fstab>

    
    Command: find-file-other-window filename &optional wildcards ¶

此命令选择访问文件文件名的缓冲区，但在选定窗口以外的窗口中执行此操作。它可以使用另一个现有的窗口或拆分一个窗口；请参阅在窗口中切换到缓冲区。

当以交互方式调用此命令时，它会提示输入文件名。

    
    Command: find-file-read-only filename &optional wildcards ¶

此命令选择访问文件文件名的缓冲区，如 `find-file` ，但它将缓冲区标记为只读。有关相关函数和变量，请参阅只读缓冲区。

当以交互方式调用此命令时，它会提示输入文件名。

    
    User Option: find-file-wildcards ¶

如果此变量不为 `nil` ，则各种查找文件命令会检查通配符并访问与它们匹配的所有文件（当以交互方式调用或当它们的通配符参数为非 `nil`  时）。如果这个选项是 `nil` ，那么 `find-file` 命令会忽略它们的通配符参数并且从不特别对待通配符。

    
    User Option: find-file-hook ¶

此变量的值是访问文件后要调用的函数列表。文件的局部变量规范（如果有）将在钩子运行之前处理。运行钩子函数时，访问文件的缓冲区是当前的。

这个变量是一个普通的钩子。请参阅挂钩。

    
    Variable: find-file-not-found-functions ¶

此变量的值是当 `find-file` 或 `find-file-noselect` 传递一个不存在的文件名时要调用的函数列表。find-file-noselect 一旦检测到不存在的文件就会调用这些函数。它按列表的顺序调用它们，直到其中一个返回非零。缓冲区文件名已设置。

这不是一个普通的钩子，因为使用了函数的值，并且在许多情况下只调用了一些函数。

    
    Variable: find-file-literally ¶

这个缓冲区局部变量，如果设置为非零值，则使保存缓冲区的行为就像缓冲区按字面意思访问其文件一样，即，没有任何类型的转换。命令 `find-file-literally` 设置此变量的本地值，但其他等效函数和命令也可以这样做，例如，避免在文件末尾自动添加换行符。该变量是永久局部变量，因此不受主模式变化的影响。


<a id="org5f2c3b2"></a>

### 26.1.2 访问子程序

find-file-noselect 函数使用两个在用户 `Lisp` 代码中有时很有用的重要子例程：create-file-buffer 和 `after-find-file` 。本节说明如何使用它们。

    Function: create-file-buffer filename ¶

该函数为访问文件名创建一个适当命名的缓冲区，并将其返回。如果该名称是空闲的，它将使用文件名（无目录）作为名称；否则，它会附加一个字符串，例如 `'<2>'` 以获取未使用的名称。另请参阅创建缓冲区。请注意，uniquify 库会影响此函数的结果。请参阅 `GNU Emacs` 手册中的 `Uniquify` 。

请注意：create-file-buffer 不会将新缓冲区与文件关联，也不会选择缓冲区。它也不使用默认的主要模式。

    
    
    (create-file-buffer "foo")
         ⇒ #<buffer foo>
    
    (create-file-buffer "foo")
         ⇒ #<buffer foo<2>>
    
    (create-file-buffer "foo")
         ⇒ #<buffer foo<3>>

此函数由 `find-file-noselect` 使用。它使用 `generate-new-buffer` （请参阅创建缓冲区）。

    Function: after-find-file &optional error warn noauto after-find-file-from-revert-buffer nomodes ¶

此函数设置缓冲区主模式，并解析局部变量（请参阅 `Emacs` 如何选择主模式）。它由 `find-file-noselect` 和默认的 `revert` 函数调用（请参阅 `Reverting` ）。

如果由于文件不存在而读取文件出错，但它的目录确实存在，则调用者应该传递一个非零值来表示错误。在这种情况下，after-find-file 会发出警告： `（新文件）` 。对于更严重的错误，调用者通常不应该调用 `after-find-file` 。

如果 `warn` 不为 `nil` ，则如果自动保存文件存在并且比访问的文件更新，则此函数会发出警告。

如果 `noauto` 不为零，则表示不启用或禁用自动保存模式。如果之前启用了该模式，则该模式将保持启用状态。

如果 `after-find-file-from-revert-buffer` 不为 `nil` ，则表示此调用来自 `revert-buffer` 。这没有直接影响，但是一些模式函数和钩子函数会检查这个变量的值。

如果 `nomodes` 不是 `nil` ，这意味着不改变缓冲区的主模式，不处理文件中的局部变量规范，也不运行 `find-file-hook` 。在某些情况下，revert-buffer 会使用此功能。

after-find-file 所做的最后一件事是调用列表 `find-file-hook` 中的所有函数。


<a id="org8f9863e"></a>

## 26.2 保存缓冲区

当你在 `Emacs` 中编辑一个文件时，你实际上是在一个正在访问该文件的缓冲区上工作——也就是说，文件的内容被复制到缓冲区中，而副本就是你编辑的内​​容。在保存缓冲区之前，对缓冲区的更改不会更改文件，这意味着将缓冲区的内容复制到文件中。从某种意义上说，不访问文件的缓冲区仍然可以 `保存` ，使用缓冲区本地 `write-contents-functions` 挂钩中的函数。

    Command: save-buffer &optional backup-option ¶

如果缓冲区自上次访问或保存后已被修改，则此函数将当前缓冲区的内容保存在其访问的文件中。否则它什么也不做。

save-buffer 负责制作备份文件。通常，backup-option 为 `nil` ，并且 `save-buffer` 仅当这是自访问文件后的第一次保存时才会创建备份文件。backup-option 的其他值要求在其他情况下制作备份文件：

使用 `4` 或 `64` 的参数，反映 `1` 或 `3` 个 `C-u` ，save-buffer 函数标记此版本的文件，以便在下次保存缓冲区时备份。
使用 `16` 或 `64` 的参数，反映 `2` 或 `3` 个 `C-u` ，save-buffer 函数在保存之前无条件地备份文件的先前版本。
参数为 `0` 时，无条件不制作任何备份文件。

    Command: save-some-buffers &optional save-silently-p pred ¶

此命令保存一些修改后的文件访问缓冲区。通常它会询问用户每个缓冲区。但是如果 `save-silently-p` 不为 `nil` ，它会保存所有文件访问缓冲区而不查询用户。

可选的 `pred` 参数提供了一个谓词，该谓词控制要询问的缓冲区（或者如果 `save-silently-p` 不为零，则静默保存）。如果 `pred` 为 `nil` ，这意味着使用 `save-some-buffers-default-predicate` 的值而不是 `pred` 。如果结果为 `nil` ，则意味着只询问文件访问缓冲区。如果它是 `t` ，这意味着还提供保存某些其他非文件缓冲区 `-` 那些具有非 `nil`  缓冲区本地值 `buffer-offer-save` 的缓冲区（请参阅 `Killing Buffers` ）。要求对保存非文件缓冲区说 `是` 的用户指定要使用的文件名。save-buffers-kill-emacs 函数将值 `t` 传递给 `pred` 。

如果谓词既不是 `t` 也不是 `nil` ，那么它应该是一个没有参数的函数。它将在每个缓冲区中调用以决定是否提供保存该缓冲区。如果它在某个缓冲区中返回一个非零值，这意味着确实提供了保存该缓冲区。

    Command: write-file filename &optional confirm ¶

此函数将当前缓冲区写入文件 `filename` ，使缓冲区访问该文件，并将其标记为未修改。然后它根据文件名重命名缓冲区，如有必要，附加一个类似 `'<2>'` 的字符串以创建唯一的缓冲区名称。它通过调用 `set-visited-file-name` （请参阅缓冲区文件名）和保存缓冲区来完成大部分工作。

如果确认是非零，这意味着在覆盖现有文件之前要求确认。交互地，需要确认，除非用户提供前缀参数。

如果 `filename` 是目录名称（请参阅目录名称），则 `write-file` 使用目录 `filename` 中访问文件的名称。如果缓冲区没有访问文件，则使用缓冲区名称代替。

保存缓冲区会运行几个挂钩。它还执行格式转换（请参阅文件格式转换）。请注意，下面描述的这些挂钩仅由保存缓冲区运行，它们不会由将缓冲区文本写入文件的其他原语和函数运行，特别是自动保存（请参阅自动保存）不会运行这些挂钩.

    Variable: write-file-functions ¶

此变量的值是在将缓冲区写入其访问文件之前要调用的函数列表。如果其中一个返回非 `nil` ，则认为该文件已写入，并且不会调用其余函数，也不会执行用于写入文件的常用代码。

如果 `write-file-functions` 中的函数返回非 `nil` ，则它负责制作备份文件（如果合适的话）。为此，请执行以下代码：

    (or buffer-backed-up (backup-buffer))

您可能希望保存备份缓冲区返回的文件模式值并使用它（如果非零）来设置您写入的文件的模式位。这是保存缓冲区通常所做的。请参阅制作备份文件。

write-file-functions 中的钩子函数还负责对数据进行编码（如果需要）：它们必须选择合适的编码系统和行尾转换（参见 `Lisp` 中的编码系统），执行编码（参见显式编码）和解码），并将 `last-coding-system-used` 设置为使用的编码系统（请参阅编码和 `I/O` ）。

如果您在缓冲区中本地设置此挂钩，则假定它与文件相关联或获取缓冲区内容的方式。因此，该变量被标记为永久局部变量，因此更改主模式不会改变缓冲区局部值。另一方面，调用 `set-visited-file-name` 将重置它。如果这不是您想要的，您可能希望改用 `write-contents-functions` 。

即使这不是一个普通的钩子，您也可以使用 `add-hook` 和 `remove-hook` 来操作列表。请参阅挂钩。

    Variable: write-contents-functions ¶

这就像 `write-file-functions` 一样工作，但它适用于与缓冲区内容相关的钩子，而不是与特定访问的文件或其位置相关的钩子，并且可用于为不访问文件的缓冲区创建任意保存过程一点也不。此类挂钩通常由主要模式设置，作为此变量的缓冲区本地绑定。每当设置此变量时，它都会自动变为缓冲区本地；切换到新的主要模式总是会重置此变量，但调用 `set-visited-file-name` 不会。

如果此钩子中的任何函数返回非 `nil` ，则认为文件已写入，其余的不会被调用，write-file-functions 中的函数也不会。

当使用这个钩子保存不访问文件的缓冲区（例如，特殊模式缓冲区）时，请记住，如果函数无法正确保存并返回 `nil`  值，save-buffer 将继续提示用户用于保存缓冲区的文件。如果这是不可取的，请考虑通过引发错误使函数失败。

    User Option: before-save-hook ¶

这个正常的钩子在缓冲区被保存到其访问的文件之前运行，无论是正常完成还是通过上述钩子之一完成。例如，copyright.el 程序使用此挂钩来确保您保存的文件在其版权声明中具有当前年份。

    User Option: after-save-hook ¶

这个普通的钩子在一个缓冲区被保存在它的访问文件中之后运行。

    User Option: file-precious-flag ¶

如果此变量不为 `nil` ，则 `save-buffer` 在保存时通过将新文件写入临时名称而不是它应该具有的名称来防止 `I/O` 错误，然后将其重命名为预期的名称。明确没有错误。此过程可防止因磁盘空间不足等问题导致文件无效。

作为副作用，备份必须通过复制进行。请参阅通过重命名或通过复制进行备份？。然而，与此同时，保存珍贵的文件总是会破坏您保存的文件与其他文件名之间的所有硬链接。

某些模式在特定缓冲区中为该变量提供非零缓冲区本地值。

    User Option: require-final-newline ¶

此变量确定是否可以写出不以换行符结尾的文件。如果变量的值是 `t` ，那么只要它还没有以 `1` 结尾，save-buffer 就会在缓冲区的末尾默默地添加一个换行符。如果值是访问，Emacs 会在访问文件后添加一个缺少的换行符。如果值为 `visit-save` ，Emacs 会在访问和保存时添加一个缺失的换行符。对于任何其他非 `nil`  值，每次出现这种情况时，save-buffer 都会询问用户是否添加换行符。

如果变量的值为 `nil` ，则 `save-buffer` 根本不添加换行符。 `nil` ~ 是默认值，但一些主要模式在特定缓冲区中将其设置为 `t` 。

另请参阅函数 `set-visited-file-name` （请参阅缓冲区文件名）。


<a id="org58b88cc"></a>

## 26.3 从文件中读取

要将文件的内容复制到缓冲区中，请使用函数 `insert-file-contents` 。（不要在 `Lisp` 程序中使用命令 `insert-file` ，因为它会设置标记。）

    Function: insert-file-contents filename &optional visit beg end replace ¶

此函数将文件 `filename` 的内容插入到当前缓冲区中的点之后。它返回绝对文件名和插入数据长度的列表。如果文件名不是可以读取的文件名，则会发出错误信号。

此函数根据定义的文件格式检查文件内容，并在适当时转换文件内容，并调用列表后插入文件函数中的函数。请参阅文件格式转换。通常，after-insert-file-functions 列表中的函数之一确定用于解码文件内容的编码系统（请参阅编码系统），包括行尾转换。但是，如果文件包含空字节，则默认情况下会在不进行任何代码转换的情况下对其进行访问。请参见禁止空字节检测。

如果 `visit` 不为 `nil` ，则此函数另外将缓冲区标记为未修改，并在缓冲区中设置各种字段，以便它正在访问文件文件名：这些字段包括缓冲区的访问文件名及其最后保存文件的修改时间。此功能由 `find-file-noselect` 使用，您可能不应该自己使用它。

如果 `beg` 和 `end` 不是 `nil` ，它们应该是字节偏移的数字，指定要插入的文件部分。在这种情况下，访问必须为零。例如，

    (insert-file-contents filename nil 0 500)

插入由文件的前 `500` 个字节编码的字符。

如果 `beg` 或 `end` 恰好在一个字符的多字节序列的中间，Emacs 的字符代码转换将插入一个或多个八位字符（也称为 `原始字节` ）（参见字符集）到缓冲区中。如果您想以这种方式读取文件的一部分，我们建议在调用此函数时将 `coding-system-for-read` 绑定到合适的值（请参阅为一个操作指定编码系统），并编写 `Lisp` 代码将检查边界处的原始字节，读取这些字节的整个序列，并将它们转换回有效字符。

如果参数 `replace` 不为 `nil` ，则表示将缓冲区的内容（实际上只是可访问部分）替换为文件的内容。这比简单地删除缓冲区内容并插入整个文件要好，因为（1）它保留了一些标记位置，（2）它在撤消列表中放置的数据更少。

可以使用 `insert-file-contents` 读取特殊文件（例如 `FIFO` 或 `I/O` 设备），只要 `replace` 和 `visit` 为 `nil` 。

    Function: insert-file-contents-literally filename &optional visit beg end replace ¶

此函数的工作方式与 `insert-file-contents` 类似，只是文件中的每个字节都是单独处理的，如果需要，可以转换为 `8` 位字符。它不运行after-insert-file-functions，也不做格式解码、字符代码转换、自动解压缩等。

如果要将文件名传递给另一个进程以便另一个程序可以读取该文件，请使用函数 `file-local-copy; ~ 请参阅使某些文件名 ~神奇` 。


<a id="org88db14b"></a>

## 26.4 写入文件

您可以使用 `append-to-file` 和 `write-region` 函数将缓冲区的内容或缓冲区的一部分直接写入磁盘上的文件。不要使用这些函数写入正在访问的文件；这可能会导致访问机制的混乱。

    Command: append-to-file start end filename ¶

此函数将当前缓冲区中由 `start` 和 `end` 分隔的区域的内容附加到文件 `filename` 的末尾。如果该文件不存在，则创建它。此函数返回零。

如果您无法写入或创建文件名，则会发出错误信号。

当从 `Lisp` 调用时，这个函数完全等价于：

    (write-region start end filename t)

    Command: write-region start end filename &optional append visit lockname mustbenew ¶

此函数将当前缓冲区中由 `start` 和 `end` 分隔的区域写入 `filename` 指定的文件中。

如果 `start` 为 `nil` ，则该命令将整个缓冲区内容（不仅仅是可访问部分）写入文件并忽略 `end` 。

如果 `start` 是字符串，则 `write-region` 写入或附加该字符串，而不是缓冲区中的文本。在这种情况下， `end` 被忽略。

如果 `append` 不为零，则指定的文本将附加到现有文件内容（如果有）。如果 `append` 是一个数字，write-region 会寻找从文件开头的那个字节偏移量，并从那里写入数据。

如果 `mustbenew` 不为零，则 `write-region` 会要求确认文件名是否命名了现有文件。如果 `mustbenew` 是符号 `excl` ，则 `write-region` 不要求确认，而是如果文件已存在，则发出错误文件已存在的信号。尽管 `write-region` 通常跟随符号链接并在符号链接悬空时创建指向文件，但如果 `mustbenew` 为 `excl` ，则它不跟随符号链接。

当 `mustbenew` 为 `excl` 时，对现有文件的测试使用特殊的系统功能。至少对于本地磁盘上的文件，其他程序不可能在 `Emacs` 之前创建同名文件，而 `Emacs` 没有注意到。

如果 `visit` 是 `t` ，那么 `Emacs` 会在缓冲区和文件之间建立关联：然后缓冲区正在访问该文件。它还将当前缓冲区的最后文件修改时间设置为文件名的修改时间，并将缓冲区标记为未修改。此功能由保存缓冲区使用，但您可能不应该自己使用它。

如果 `visit` 是一个字符串，它指定要访问的文件名。这样，您可以将数据写入一个文件（文件名），同时将缓冲区记录为访问另一个文件（访问）。参数 `visit` 用于回显区域消息，也用于文件锁定；访问存储在缓冲区文件名中。该特性用于实现file-precious-flag；除非您真的知道自己在做什么，否则不要自己使用它。

可选参数 `lockname` ，如果非 `nil` ，指定用于锁定和解锁的文件名，覆盖文件名和访问。

函数 `write-region` 将其写入的数据转换为由 `buffer-file-format` 指定的适当文件格式，并且还调用列表 `write-region-annotate-functions` 中的函数。请参阅文件格式转换。

通常，write-region 在回显区域显示消息 `Wrote filename` 。如果 `visit` 既不是 `t` 也不是 `nil`  也不是字符串，或者如果 `Emacs` 以批处理模式运行（请参阅批处理模式），则禁止此消息。此功能对于将文件用于内部目的的程序（用户不需要知道的文件）很有用。

    Variable: write-region-inhibit-fsync ¶

如果此变量的值为 `nil` ，则 `write-region` 在写入文件后使用 `fsync` 系统调用。虽然这会减慢 `Emacs` 的速度，但它降低了断电后数据丢失的风险。如果值为 `t` ，则 `Emacs` 不使用 `fsync` 。当 `Emacs` 是交互式的时，默认值为 `nil` ，当 `Emacs` 以批处理模式运行时，默认值为 `t` 。请参阅文件和辅助存储。

    Macro: with-temp-file file body… ~¶

with-temp-file~ 宏以临时缓冲区作为当前缓冲区来评估正文表单；然后，最后，它将缓冲区内容写入文件 `file` 。它在完成时终止临时缓冲区，恢复在 `with-temp-file` 表单之前的当前缓冲区。然后它返回正文中最后一个表单的值。

即使在通过 `throw` 或 `error` 异常退出的情况下也会恢复当前缓冲区（请参阅非本地退出）。

与 `with-temp-buffer` （请参阅 `Current Buffer` ）一样，此宏使用的临时缓冲区不会运行 `hooks kill-buffer-hook` 、kill-buffer-query-functions（请参阅 `Killing Buffers` ）和 `buffer-list-update-` 挂钩（请参阅缓冲区列表）。


<a id="org28cc92e"></a>

## 26.5 文件锁

当两个用户同时编辑同一个文件时，他们很可能会相互干扰。Emacs 试图通过在文件被修改时记录文件锁来防止这种情况的发生。然后，Emacs 可以检测到第一次尝试修改访问被另一个 `Emacs` 作业锁定的文件的缓冲区的尝试，并询问用户要做什么。文件锁实际上是一个文件，一个具有特殊名称的符号链接，存储在与您正在编辑的文件相同的目录中。该名称是通过将 `.#` 附加到缓冲区的文件名来构造的。符号链接的目标将采用 `user@host.pid:boot` 形式，其中 `user` 替换为当前用户名（来自 `user-login-name` ），host 替换为运行 `Emacs` 的主机的名称（来自系统-name)，带有 `Emacs` 进程 `ID` 的 `pid` ，以及自上次重启以来的启动时间。如果引导时间不可用，则省略 `:boot` 。（在不支持符号链接的文件系统上，将使用常规文件，其内容格式为 `user@host.pid:boot` 。）

当您使用 `NFS` 访问文件时，您和其他用户可能同时锁定同一个文件的可能性很小。如果发生这种情况，两个用户有可能同时进行更改，但 `Emacs` 仍然会警告第二个保存的用户。此外，检测访问磁盘上已更改文件的缓冲区的修改会捕获一些同时编辑的情况；请参阅缓冲区修改时间。

    Function: file-locked-p filename ¶

如果文件文件名未锁定，则此函数返回 `nil` 。如果它被这个 `Emacs` 进程锁定，它返回 `t` ，如果它被其他作业锁定，它返回锁定它的用户的名称。

    
    
    (file-locked-p "foo")
         ⇒ nil

    Function: lock-buffer &optional filename ¶

如果当前缓冲区被修改，此函数将锁定文件文件名。参数文件名默认为当前缓冲区的访问文件。如果当前缓冲区没有访问文件，或者没有被修改，或者选项 `create-lockfiles` 为 `nil` ，则什么都不做。

    Function: unlock-buffer ¶

如果缓冲区被修改，此函数将解锁当前缓冲区中正在访问的文件。如果缓冲区没有被修改，那么文件不应该被锁定，所以这个函数什么都不做。如果当前缓冲区没有访问文件或未锁定，它也不会执行任何操作。此函数通过调用 `display-warning` 来处理文件系统错误，否则忽略错误。

    User Option: create-lockfiles ¶

如果这个变量是 `nil` ，Emacs 不会锁定文件。

    User Option: lock-file-name-transforms ¶

默认情况下，Emacs 在与被锁定文件相同的目录中创建锁定文件。这可以通过自定义此变量来更改。Is 与 `auto-save-file-name-transforms` 具有相同的语法（请参阅自动保存）。例如，要让 `Emacs` 将所有锁定文件写入 `/var/tmp/` ，你可以这样说：

    (setq lock-file-name-transforms
          '(("\\`/.*/\\([^/]+\\)\\'" "/var/tmp/\\1" t)))

    Function: ask-user-about-lock file other-user ¶

当用户试图修改文件时调用此函数，但它被另一个名为 `other-user` 的用户锁定。此函数的默认定义要求用户说出要做什么。这个函数返回的值决定了 `Emacs` 下一步做什么：

t 值表示要获取文件上的锁。然后这个用户可以编辑文件而其他用户失去锁定。
 `nil`  值表示忽略锁定并让该用户无论如何编辑文件。
此函数可能会发出文件锁定错误的信号，在这种情况下，用户将要进行的更改不会发生。

此错误的错误消息如下所示：

    error→ ~File is locked: file other-user

~ 其中 `file` 是文件名， `other-user` 是锁定文件的用户名。

如果您愿意，您可以用您自己的版本替换 `ask-user-about-lock` 功能，以另一种方式做出决定。

    User Option: remote-file-name-inhibit-locks ¶

您可以通过将变量 `remote-file-name-inhibit-locks` 设置为 `t` 来阻止创建远程锁定文件。

    Command: lock-file-mode ¶

此命令以交互方式调用，切换当前缓冲区中 `create-lockfiles` 的本地值。


<a id="org3dd0245"></a>

## 26.6 文件信息

本节介绍用于检索有关文件（或目录或符号链接）的各种类型信息的函数，例如文件是否可读或可写，以及文件的大小。这些函数都采用文件名作为参数。除非另有说明，否则这些参数需要指定现有文件，否则会发出错误信号。

请注意以空格结尾的文件名。在某些文件系统（尤其是 `MS-Windows` ）上，文件名中的尾随空格字符会被自动忽略。


<a id="org44847f4"></a>

### 26.6.1 测试可访问性

这些函数测试访问文件以进行读取、写入或执行的权限。除非另有明确说明，否则它们遵循符号链接。请参阅区分文件种类。

在某些操作系统上，可以通过访问控制列表 `(ACL)` 等机制指定更复杂的访问权限集。请参阅扩展文件属性，了解如何查询和设置这些权限。

    Function: file-exists-p filename ¶

如果一个名为 `filename` 的文件似乎存在，此函数将返回 `t` 。这并不意味着您一定可以读取该文件，只是您可能会找出它的属性。（在 `GNU` 和其他类似 `POSIX` 的系统上，如果文件存在并且您对包含的目录具有执行权限，则无论文件本身的权限如何，都是如此。）

如果文件不存在，或者无法确定文件是否存在，则此函数返回 `nil` 。

目录是文件，因此 `file-exists-p` 可以在给定目录时返回 `t` 。但是，因为 `file-exists-p` 遵循符号链接，所以仅当目标文件存在时，它才返回 `t` 作为符号链接名称。

    Function: file-readable-p filename ¶

如果存在名为 `filename` 的文件并且您可以读取它，则此函数返回 `t` 。否则返回 `nil`  。

    Function: file-executable-p filename ¶

如果存在名为 `filename` 的文件并且您可以执行它，则此函数返回 `t` 。否则返回 `nil`  。在 `GNU` 和其他类似 `POSIX` 的系统上，如果文件是目录，则执行权限意味着您可以检查目录中文件的存在和属性，并在其模式允许的情况下打开这些文件。

    Function: file-writable-p filename ¶

如果文件 `filename` 可以由您编写或创建，则此函数返回 `t` ，否则返回 `nil` 。如果文件存在并且您可以写入，则文件是可写的。如果它不存在，它是可创建的，但它的父目录确实存在，您可以在该目录中写入。

在下面的示例中， `foo` 不可写，因为父目录不存在，即使用户可以创建这样的目录。

    (file-writable-p "~/no-such-dir/foo")
         ⇒ nil

    Function: file-accessible-directory-p dirname ¶

如果您有权打开目录中的文件名为 `dirname` 的现有文件，则此函数返回 `t` ；否则（例如，如果没有这样的目录），它返回 `nil` 。dirname 的值可以是目录名（例如 `/foo/` ），也可以是作为目录的文件的文件名（例如 `/foo` ，没有最后的斜杠）。

例如，从以下我们推断，任何尝试读取 `/foo/` 中的文件都会出错：

    (file-accessible-directory-p "/foo")
         ⇒ nil

    Macro: with-existing-directory body… ~¶

~ 此宏确保在执行正文之前将 `default-directory` 绑定到现有目录。如果 `default-directory` 已经存在，则首选，否则使用其他目录。例如，当调用要求它在存在的目录中运行的外部命令时，此宏可能很有用。不保证所选目录是可写的。

    Function: access-file filename string ¶

如果您可以读取文件名，则此函数返回 `nil` ；否则，它使用字符串作为错误消息文本来表示错误。

    Function: file-ownership-preserved-p filename &optional group ¶

如果删除文件文件名然后重新创建它会保持文件所有者不变，则此函数返回 `t` 。它还为不存在的文件返回 `t` 。

如果可选参数组不为零，则此函数还会检查文件的组是否未更改。

此函数不遵循符号链接。

    Function: file-modes filename &optional flag ¶

该函数返回文件名的模式位——一个总结其读、写和执行权限的整数。此函数遵循符号链接。如果文件不存在，则返回值为 `nil` 。

有关模式位的描述，请参阅 `GNU Coreutils` 手册中的文件权限。例如，如果低位为 `1` ，则该文件对所有用户都是可执行的；如果倒数第二位为 `1` ，则文件可被所有用户写入；等。最高可能值为 `4095` （八进制 `7777` ），表示每个人都有读、写和执行权限，为其他人和组设置 `SUID` 位，并设置粘性位。

默认情况下，此函数遵循符号链接。但是，如果可选参数标志是符号nofollow，如果它是符号链接，则此函数不跟随文件名；这可以帮助防止无意中在其他地方获取文件的模式位，并且与文件属性更一致（请参阅文件属性）。

有关可用于设置这些权限的 `set-file-modes` 功能，请参阅更改文件名和属性。

    (file-modes "~/junk/diffs" 'nofollow)
         ⇒ 492               ; Decimal integer.
    
    (format "%o" 492)
         ⇒ "754"             ; Convert to octal.
    
    
    (set-file-modes "~/junk/diffs" #o666 'nofollow)
         ⇒ nil
    
    
    $ ls -l diffs
    -rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs

MS-DOS 注意：在 `MS-DOS` 上，没有可执行文件模式位之类的东西。因此，如果文件名以标准可执行扩展名之一（例如 `.com` 、.bat、.exe 等）结尾，则 `file-modes` 认为文件是可执行文件。以 `POSIX` 标准 `#!` 开头的文件 `签` 名，例如 `shell` 和 `Perl` 脚本，也被认为是可执行的。为了与 `POSIX` 兼容，目录也被报告为可执行文件。文件属性也遵循这些约定（请参阅文件属性）。


<a id="org14ad54a"></a>

### 26.6.2 区分文件种类

本节介绍如何区分各种文件，例如目录、符号链接和普通文件。

符号链接通常出现在它们出现的任何地方。例如，为了解释文件名 `a/b/c` ，a、a/b 和 `a/b/c` 中的任何一个都可以是被跟随的符号链接，如果链接目标本身就是符号链接，则可能是递归的。但是，一些函数不跟随文件名末尾的符号链接（本例中为 `a/b/c` ）。据说这样的函数不遵循符号链接。

    Function: file-symlink-p filename ¶

如果文件 `filename` 是符号链接，则此函数不跟随它，而是将其链接目标作为字符串返回。（链接目标字符串不一定是目标的完整绝对文件名；确定链接指向的完整文件名很重要，见下文。）

如果文件 `filename` 不是符号链接，或者不存在，或者无法确定它是否是符号链接，则 `file-symlink-p` 返回 `nil` 。

以下是使用此功能的几个示例：

    (file-symlink-p "not-a-symlink")
         ⇒ nil
    
    (file-symlink-p "sym-link")
         ⇒ "not-a-symlink"
    
    (file-symlink-p "sym-link2")
         ⇒ "sym-link"
    
    (file-symlink-p "/bin")
         ⇒ "/pub/bin"

请注意，在第三个示例中，该函数返回了符号链接，但没有继续解析它，尽管该文件本身就是一个符号链接。这是因为此函数不遵循符号链接——遵循符号链接的过程不适用于文件名的最后一个组成部分。

该函数返回的字符串是符号链接中记录的内容；它可能包含也可能不包含任何主要目录。此函数不会扩展链接目标以生成完全限定的文件名，特别是如果链接目标不是绝对文件名，则不使用文件名参数的前导目录（如果有）。这是一个例子：

    (file-symlink-p "/foo/bar/baz")
         ⇒ "some-file"

在这里，虽然 `/foo/bar/baz` 作为完全限定的文件名给出，但结果不是，实际上根本没有任何前导目录。并且由于 `some-file` 本身可能是一个符号链接，因此您不能简单地为其添加前导目录，甚至不能天真地使用 `expand-file-name` （请参阅扩展文件名的函数）来生成其绝对文件名。

出于这个原因，如果您需要确定的不仅仅是文件是或不是符号链接的事实，那么这个函数很少有用。如果您确实需要链接目标的文件名，请使用 `file-chase-links` 或 `file-truename` ，如 `Truenames` 中所述。

    Function: file-directory-p filename ¶

如果 `filename` 是现有目录的名称，则此函数返回 `t` 。如果 `filename` 没有命名目录，或者无法确定它是否是目录，则返回 `nil` 。此函数遵循符号链接。

    
    
    (file-directory-p "~rms")
         ⇒ t
    
    (file-directory-p "~rms/lewis/files.texi")
         ⇒ nil
    
    (file-directory-p "~rms/lewis/no-such-file")
         ⇒ nil
    
    (file-directory-p "$HOME")
         ⇒ nil
    
    (file-directory-p
     (substitute-in-file-name "$HOME"))
         ⇒ t

    Function: file-regular-p filename ¶

如果文件 `filename` 存在并且是常规文件（不是目录、命名管道、终端或其他 `I/O` 设备），则此函数返回 `t` 。如果文件名不存在或不是常规文件，或者无法确定它是否是常规文件，则返回 `nil` 。此函数遵循符号链接。


<a id="org5553aaf"></a>

### 26.6.3 真名

文件的真实名称是您通过在所有级别跟踪符号链接直到没有剩余，然后简化掉 `。` 获得的名称。和 `..` 作为名称组件出现。这会产生一种文件的规范名称。文件并不总是具有唯一的真名；一个文件具有的不同真名的数量等于该文件的硬链接数量。但是，真实名称很有用，因为它们消除了作为名称变化原因的符号链接。

    Function: file-truename filename ¶

此函数返回文件文件名的真实名称。如果参数不是绝对文件名，则此函数首先将其扩展为默认目录。

此函数不扩展环境变量。只有替换文件名才能做到这一点。请参阅替代文件名的定义。

如果您可能需要遵循作为名称组件出现的 `..` 之前的符号链接，请调用 `file-truename` ，而无需事先直接或间接调用 `expand-file-name` 。否则，紧接在 `..` 之前的文件名组件将在调用 `file-truename` 之前被简化。为了消除调用expand-file-name 的需要，file-truename 以与expand-file-name 相同的方式处理'~'。

如果符号链接的目标具有远程文件名语法，则 `file-truename` 将其返回引用。请参阅扩展文件名的函数。

    Function: file-chase-links filename &optional limit ¶

此函数跟随符号链接，从文件名开始，直到找到一个不是符号链接名称的文件名。然后它返回该文件名。此函数不遵循父目录级别的符号链接。

如果您为限制指定一个数字，那么在遍历那么多链接之后，该函数只会返回它所拥有的内容，即使那仍然是一个符号链接。

为了说明 `file-chase-links` 和 `file-truename` 之间的区别，假设 `/usr/foo` 是到目录 `/home/foo` 的符号链接，而 `/home/foo/hello` 是一个普通文件（或者至少不是符号链接）或不存在。然后我们会有：

    (file-chase-links "/usr/foo/hello")
         ;; This does not follow the links in the parent directories.
         ⇒ "/usr/foo/hello"
    (file-truename "/usr/foo/hello")
         ;; Assuming that /home is not a symbolic link.
         ⇒ "/home/foo/hello"

    Function: file-equal-p file1 file2 ¶

如果文件 `file1` 和 `file2` 名称相同，则此函数返回 `t` 。这类似于比较它们的真名，除了远程文件名也以适当的方式处理。如果 `file1` 或 `file2` 不存在，则返回值未指定。

    Function: file-name-case-insensitive-p filename ¶

有时需要将文件名或其部分作为字符串进行比较，在这种情况下，了解底层文件系统是否不区分大小写很重要。如果文件 `filename` 在不区分大小写的文件系统上，则此函数返回 `t` 。它总是在 `MS-DOS` 和 `MS-Windows` 上返回 `t` 。在 `Cygwin` 和 `macOS` 上，文件系统可能不区分大小写，并且该函数尝试通过运行时测试确定区分大小写。如果测试没有结果，函数在 `Cygwin` 上返回 `t` ，在 `macOS` 上返回 `nil` 。

目前，此函数在 `MS-DOS` 、MS-Windows、Cygwin 和 `macOS` 以外的平台上始终返回 `nil` 。它不会检测已安装文件系统（例如 `Samba` 共享或 `NFS` 安装的 `Windows` 卷）的大小写不敏感。在远程主机上，它假定 `t` 用于 `'smb'` 方法。对于所有其他连接方法，执行运行时测试。

    Function: file-in-directory-p file dir ¶

如果 `file` 是目录 `dir` 或 `dir` 的子目录中的文件，则此函数返回 `t` 。如果 `file` 和 `dir` 是同一个目录，它也返回 `t` 。它比较两个目录的真名。如果 `dir` 没有命名现有目录，则返回值为 `nil` 。

    Function: vc-responsible-backend file ¶

此函数确定给定文件的负责 `VC` 后端。例如，如果 `emacs.c` 是 `Git` 跟踪的文件，则 `(vc-responsible-backend "emacs.c")` 返回 `Git` 。请注意，如果文件是符号链接，vc-responsible-backend 将不会解析它——报告符号链接文件本身的后端。要获取文件所引用文件的后端 `VC` ，请使用符号链接解析函数（例如 `file-chase-links` ）包装文件：

    (vc-responsible-backend (file-chase-links "emacs.c"))


<a id="org5838ed0"></a>

### 26.6.4 文件属性

本节介绍获取文件详细信息的函数，包括所有者和组号、名称的数量、inode 号、大小以及访问和修改的次数。

    Function: file-newer-than-file-p filename1 filename2 ¶

如果文件 `filename1` 比文件 `filename2` 新，则此函数返回 `t` 。如果 `filename1` 不存在，则返回 `nil` 。如果 `filename1` 确实存在，但 `filename2` 不存在，则返回 `t` 。

在下面的例子中，假设文件 `aug-19` 写在 `19` 号，aug-20 写在 `20` 号，文件 `no-file` 根本不存在。

    (file-newer-than-file-p "aug-19" "aug-20")
         ⇒ nil
    
    (file-newer-than-file-p "aug-20" "aug-19")
         ⇒ t
    
    (file-newer-than-file-p "aug-19" "no-file")
         ⇒ t
    
    (file-newer-than-file-p "no-file" "aug-19")
         ⇒ nil

    Function: file-attributes filename &optional id-format ¶

此函数返回文件 `filename` 的属性列表。如果指定的文件不存在，则返回 `nil` 。此函数不遵循符号链接。可选参数 `id-format` 指定 `UID` 和 `GID` 属性的首选格式（见下文）——有效值为 `'string` 和 `'integer` 。后者是默认值，但我们计划更改它，因此如果您使用返回的 `UID` 或 `GID` ，则应为 `id-format` 指定一个非零值。

在 `GNU` 平台上操作本地文件时，此函数是原子的：如果文件系统同时被其他进程更改，则此函数在更改之前或之后返回文件的属性。否则，此函数不是原子的，如果它检测到竞争条件，则可能返回 `nil` ，或者可能返回先前和当前文件属性的大杂烩。

提供了访问器函数来访问此列表中的元素。访问器与以下元素的描述一起被提及。

列表的元素按顺序是：

t 表示目录，字符串表示符号链接（链接到的名称），或 `nil`  表示文本文件（文件属性类型）。
文件具有的名称数（文件属性链接编号）。可以使用 `add-name-to-file` 函数创建备用名称，也称为硬链接（请参阅更改文件名和属性）。
文件的 `UID` ，通常为字符串 `(file-attribute-user-id)` 。但是，如果它不对应于指定用户，则该值为整数。
文件的 `GID` ，同样是 `(file-attribute-group-id)` 。
最后一次访问的时间作为 `Lisp` 时间戳（文件属性访问时间）。时间戳采用当前时间的样式（请参阅时间），并被截断为文件系统的时间戳分辨率；例如，在某些基于 `FAT` 的文件系统上，仅记录最后一次访问的日期，因此该时间将始终保持最后一次访问当天的午夜。
最后修改的时间作为 `Lisp` 时间戳（文件属性修改时间）。这是文件内容最后一次修改。
最后状态更改的时间作为 `Lisp` 时间戳（文件属性状态更改时间）。这是文件的访问模式位、其所有者和组以及文件系统中记录的文件的其他信息的最后更改时间，超出了文件的内容。
文件的大小（以字节为单位）（file-attribute-size）。
文件的模式，由十个字母或破折号组成的字符串，如 `'ls -l' (file-attribute-modes)` 。
一个未指定的值，用于向后兼容。
文件的 `inode` 号（file-attribute-inode-number），一个非负整数。
文件所在设备的文件系统编号（file-attribute-device-number），整数。这个元素和文件的 `inode` 编号一起提供了足够的信息来区分系统上的任何两个文件——没有两个文件可以对这两个编号具有相同的值。

例如，以下是 `files.texi` 的文件属性：

    (file-attributes "files.texi" 'string)
         ⇒  (nil 1 "lh" "users"
    	  (20614 64019 50040 152000)
    	  (20000 23 0 0)
    	  (20614 64555 902289 872000)
    	  122295 "-rw-rw-rw-"
    	  t 6473924464520138
    	  1014478468)

以下是结果的解释方式：

    nil

既不是目录也不是符号链接。

    1

只有一个名称（当前默认目录中的名称 `files.texi` ）。

    "lh"

由名为 `lh` 的用户所有。

    "users"

在名为 `用户` 的组中。

    (20614 64019 50040 152000)

上次访问时间为 `2012` 年 `10` 月 `23` 日 `20:12:03.050040152 UTC` 。

    (20000 23 0 0)

上次修改时间为 `2001` 年 `7` 月 `15` 日 `08:53:43 UTC` 。

    (20614 64555 902289 872000)

最后一次更改状态是在 `2012` 年 `10` 月 `23` 日 `20:20:59.902289872 UTC` 。

    122295

长度为 `122295` 字节。（但是，如果某些字节属于多字节序列，并且行尾格式为 `CR-LF` ，则它可能不包含 `122295` 个字符。）

    "-rw-rw-rw-"

拥有所有者、组和世界的读写访问模式。

    t

只是一个占位符；它不携带任何信息。

    6473924464520138

inode 编号为 `6473924464520138` 。

    1014478468

位于编号为 `1014478468` 的文件系统设备上。

    Function: file-nlinks filename ¶

此函数返回文件 `filename` 具有的名称（即硬链接）的数量。如果文件不存在，则此函数返回 `nil` 。请注意，符号链接对此函数没有影响，因为它们不被认为是它们链接到的文件的名称。此函数不遵循符号链接。

    $ ls -l foo*
    -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
    -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1
    
    
    (file-nlinks "foo")
         ⇒ 2
    
    (file-nlinks "doesnt-exist")
         ⇒ nil


<a id="org442de02"></a>

### 26.6.5 扩展文件属性

某些操作系统上，每个文件都可以与任意扩展文件属性相关联。目前，Emacs 支持查询和设置两组特定的扩展文件属性：访问控制列表 `(ACL)` 和 `SELinux` 上下文。在某些系统上，这些扩展文件属性用于实施比前几节中讨论的基本 `Unix` 样式权限更复杂的文件访问控制。

ACL 和 `SELinux` 的详细说明超出了本手册的范围。出于我们的目的，每个文件都可以与一个 `ACL` 相关联，该 `ACL` 指定其在基于 `ACL` 的文件控制系统下的属性，和/或 `SELinux` 上下文，该上下文指定其在 `SELinux` 系统下的属性。

    Function: file-acl filename ¶

此函数返回文件文件名的 `ACL` 。ACL 的确切 `Lisp` 表示是未指定的（并且可能会在未来的 `Emacs` 版本中更改），但它与 `set-file-acl` 为其 `acl` 参数所采用的相同（请参阅更改文件名和属性）。

底层 `ACL` 实现是平台特定的；在 `GNU/Linux` 和 `BSD` 上，Emacs 使用 `POSIX ACL` 接口，而在 `MS-Windows` 上，Emacs 使用本机文件安全 `API` 模拟 `POSIX ACL` 接口。

如果不支持 `ACL` 或文件不存在，则返回值为 `nil` 。

    Function: file-selinux-context filename ¶

该函数返回文件文件名的 `SELinux` 上下文，以列表形式（用户角色类型范围）。列表元素分别是上下文的用户、角色、类型和范围，作为 `Lisp` 字符串；有关这些实际含义的详细信息，请参阅 `SELinux` 文档。返回值的形式与 `set-file-selinux-context` 为其上下文参数所采用的形式相同（请参阅更改文件名和属性）。

如果不支持 `SELinux` 或文件不存在，则返回值为 `(nil nil nil nil)` 。

    Function: file-extended-attributes filename ¶

此函数返回 `Emacs` 识别的文件 `filename` 扩展属性的列表。目前，它是检索 `ACL` 和 `SELinux` 上下文的便捷方式；然后，您可以调用函数 `set-file-extended-attributes` ，将返回的 `alist` 作为其第二个参数，以将相同的文件访问属性应用于另一个文件（请参阅更改文件名和属性）。

其中一个元素是 `(acl .acl)` ，其中 `acl` 与 `file-acl` 返回的形式相同。

另一个元素是 `(selinux-context . context)` ，其中 `context` 是 `SELinux` 上下文，与 `file-selinux-context` 返回的形式相同。


<a id="orgf555748"></a>

### 26.6.6 在标准位置定位文件

本节说明如何在目录列表（路径）中搜索文件，或在标准可执行文件目录列表中搜索可执行文件。

要搜索特定于用户的配置文件，请参阅标准文件名，了解 `locate-user-emacs-file` 功能。

    Function: locate-file filename path &optional suffixes predicate ¶

此函数在 `path` 给出的目录列表中搜索名称为 `filename` 的文件，并尝试后缀中的后缀。如果找到这样的文件，则返回文件的绝对文件名（请参阅绝对和相对文件名）；否则返回零。

可选参数 `suffixes` 给出搜索时附加到文件名的文件名后缀列表。locate-file 使用这些后缀中的每一个尝试每个可能的目录。如果 `suffixes` 为 `nil`  或 `("")` ，则没有后缀，文件名仅按原样使用。后缀的典型值是 `exec-suffixes` （参见创建子进程的函数）、load-suffixes、load-file-rep-suffixes 和函数 `get-load-suffixes` 的返回值（参见加载后缀）。

path 的典型值是查找可执行程序时的 `exec-path` （请参阅创建子进程的函数），或查找 `Lisp` 文件时的 `load-path` （请参阅库搜索）。如果filename是absolute，path没有作用，但是suffixes中的suffixs还是会尝试。

可选参数谓词，如果非零，则指定用于测试候选文件是否合适的谓词函数。谓词将候选文件名作为其单个参数传递。如果 `predicate` 为 `nil`  或省略，则 `locate-file` 使用 `file-readable-p` 作为谓词。有关其他有用的谓词，请参阅区分文件种类，例如 `file-executable-p` 和 `file-directory-p` 。

此函数通常会跳过目录，因此如果您希望它查找目录，请确保谓词函数为它们返回 `dir-ok` 。例如：

    (locate-file "html" '("/var/www" "/srv") nil
    	     (lambda (f) (if (file-directory-p f) 'dir-ok)))

为了兼容性，谓词也可以是可执行、可读、可写、存在的符号之一，或这些符号中的一个或多个的列表。

    Function: executable-find program &optional remote ¶

此函数搜索指定程序的可执行文件并返回可执行文件的绝对文件名，包括其文件扩展名（如果有）。如果找不到文件，则返回 `nil` 。该函数搜索 `exec-path` 中的所有目录，并尝试 `exec-suffixes` 中的所有文件扩展名（请参阅创建子进程的函数）。

如果 `remote` 不为零，并且 `default-directory` 是远程目录，则在相应的远程主机上搜索程序。


<a id="org1709e9b"></a>

## 26.7 更改文件名和属性

本节中的功能重命名、复制、删除、链接和设置文件的模式（权限）。通常，如果它们无法执行其功能，它们会发出文件错误错误信号，并报告描述失败原因的系统相关错误消息。如果它们因为文件丢失而失败，它们会发出文件丢失错误的信号。

出于性能考虑，操作系统可能会缓存这些函数所做的更改或为其设置别名，而不是立即将它们写入辅助存储。请参阅文件和辅助存储。

在具有参数 `newname` 的函数中，如果此参数是目录名称，则将其视为附加了源名称的非目录部分。通常，目录名称是以 `/` 结尾的目录名称（请参阅目录名称）。例如，如果旧名称是 `a/b/c` ，则新名称 `d/e/f/` 被视为 `d/e/f/c` 。如果 `newname` 不是目录名而是将文件命名为目录，则此特殊处理不适用；例如，即使 `d/e/f` 恰好是一个目录，新名称 `d/e/f` 也会保持原样。

在具有参数 `newname` 的函数中，如果名为 `newname` 的文件已经存在，则采取的操作取决于参数 `ok-if-already-exists` 的值：

    $ ls -li fo*
    81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
    84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

    Command: add-name-to-file oldname newname &optional ok-if-already-exists ¶

此函数为名为 `oldname` 的文件提供附加名称 `newname` 。这意味着 `newname` 成为 `oldname` 的新硬链接。

如果 `newname` 是符号链接，则替换它的目录条目，而不是它指向的目录条目。如果 `oldname` 是符号链接，则此函数可能会或可能不会跟随链接；它不遵循 `GNU` 平台上的链接。如果 `oldname` 是一个目录，这个函数通常会失败，尽管对于一些老式非 `GNU` 平台上的超级用户来说，它可以成功并创建一个非树形结构的文件系统。

在以下示例的第一部分中，我们列出了两个文件 `foo` 和 `foo3` 。

    $ ls -li fo*
    81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
    84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

现在我们通过调用 `add-name-to-file` 创建一个硬链接，然后再次列出文件。这显示了一个文件的两个名称，foo 和 `foo2` 。

    (add-name-to-file "foo" "foo2")
         ⇒ nil
    
    
    $ ls -li fo*
    81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
    81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
    84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3

最后，我们评估以下内容：

    (add-name-to-file "foo" "foo3" t)

并再次列出文件。现在一个文件有三个名称：foo、foo2 和 `foo3` 。foo3 的旧内容丢失。

    (add-name-to-file "foo1" "foo3")
         ⇒ nil
    
    
    $ ls -li fo*
    81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
    81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
    81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3

此功能在不允许一个文件有多个名称的操作系统上没有意义。一些系统通过复制文件来实现多个名称。

另请参阅文件属性中的 `file-nlinks` 。

    Command: rename-file filename newname &optional ok-if-already-exists ¶

此命令将文件 `filename` 重命名为 `newname` 。

如果文件名除了文件名之外还有其他名称，它会继续使用这些名称。事实上，使用 `add-name-to-file` 添加名称 `newname` 然后删除 `filename` 与重命名具有相同的效果，除了暂时的中间状态和错误、目录和符号链接的处理。

此命令不遵循符号链接。如果 `filename` 是符号链接，则此命令重命名符号链接，而不是它指向的文件。如果 `newname` 是符号链接，则替换它的目录条目，而不是它指向的目录条目。

如果 `filename` 和 `newname` 是相同的目录条目，即如果它们引用相同的父目录并在该目录中给出相同的名称，则此命令不执行任何操作。否则，如果 `filename` 和 `newname` 命名相同的文件，则此命令在符合 `POSIX` 的系统上不执行任何操作，并在某些非 `POSIX` 系统上删除 `filename` 。

如果 `newname` 存在，那么如果 `oldname` 是一个目录，那么它必须是一个空目录，否则它必须是一个非目录。

    Command: copy-file oldname newname &optional ok-if-already-exists time preserve-uid-gid preserve-extended-attributes ¶

此命令将文件 `oldname` 复制到 `newname` 。如果 `oldname` 不是常规文件，则会发出错误信号。如果 `newname` 命名一个目录，它会将 `oldname` 复制到该目录中，并保留其最终名称组件。

此函数遵循符号链接，但它不遵循悬空符号链接来创建新名称。

如果时间不为零，则此函数为新文件提供与旧文件相同的最后修改时间。（这仅适用于某些操作系统。）如果设置时间出错，则 `copy-file` 会发出 `file-date-error` 错误信号。在交互式调用中，前缀参数指定时间的非零值。

如果参数 `preserve-uid-gid` 为 `nil` ，我们让操作系统决定新文件的用户和组所有权（这通常设置为运行 `Emacs` 的用户）。如果 `preserve-uid-gid` 不为零，我们会尝试复制文件的用户和组所有权。这仅适用于某些操作系统，并且仅当您具有正确的权限才能这样做。

如果可选参数 `preserve-permissions` 不为零，则此函数将 `oldname` 的文件模式（或 `权限` ）复制到 `newname` ，以及访问控制列表和 `SELinux` 上下文（如果有）。请参阅有关文件的信息。

否则，如果 `newname` 是现有文件，则 `newname` 的文件模式保持不变，如果要新建 `newname` ，则设置为 `oldname` 的文件模式，并由默认文件权限屏蔽（参见下面的 `set-default-file-modes` ）。在这两种情况下都不会复制访问控制列表或 `SELinux` 上下文。

    Command: make-symbolic-link target linkname &optional ok-if-already-exists ¶

此命令创建一个指向目标的符号链接，名为链接名。这就像 `shell` 命令 `ln -s` 目标链接名~ 。目标参数仅被视为字符串；它不需要命名现有文件。如果 `ok-if-already-exists` 是一个整数，表示交互使用，则扩展前导 `'`'~ 并去除目标字符串中的前导 `'/:'` 。

如果 `target` 是相对文件名，则生成的符号链接将相对于包含符号链接的目录进行解释。请参阅绝对和相对文件名。

如果 `target` 和 `linkname` 都具有远程文件名语法，并且两个远程标识相等，则符号链接指向 `target` 的本地文件名部分。

此功能在不支持符号链接的系统上不可用。

    Command: delete-file filename &optional trash ¶

此命令删除文件文件名。如果文件有多个名称，它会继续以其他名称存在。如果 `filename` 是符号链接，则 `delete-file` 仅删除符号链接而不删除其目标。

如果文件不存在或不可删除，则会发出适当类型的文件错误错误信号。（在 `GNU` 和其他类似 `POSIX` 的系统上，如果文件的目录是可写的，则该文件是可删除的。）

如果可选参数垃圾是非零并且变量 `delete-by-moving-to-trash` 是非零，则此命令将文件移动到系统垃圾箱而不是删除它。请参阅 `GNU Emacs` 手册中的其他文件操作。当交互调用时，如果没有给出前缀参数，则垃圾为 `t` ，否则为 `nil` 。

另请参阅创建、复制和删除目录中的删除目录。

    Command: set-file-modes filename mode &optional flag ¶

该函数将文件名的文件模式（或权限）设置为模式。

默认情况下，此函数遵循符号链接。但是，如果可选参数标志是符号nofollow，如果它是符号链接，则此函数不跟随文件名；这有助于防止在其他地方无意中更改文件的模式位。在不支持更改符号链接上的模式位的平台上，当文件名是符号链接并且标志是 `nofollow` 时，此函数会发出错误信号。

如果以非交互方式调用，mode 必须是整数。仅使用整数的最低 `12` 位；在大多数系统上，只有最低 `9` 位是有意义的。您可以使用八进制数的 `Lisp` 构造来进入模式。例如，

    (set-file-modes "myfile" #o644 'nofollow)

指定文件应该对其所有者可读和可写，对组成员可读，对所有其他用户可读。有关模式位规范的描述，请参阅 `GNU Coreutils` 手册中的文件权限。

交互地，模式是使用 `read-file-modes` （见下文）从 `minibuffer` 中读取的，它允许用户输入一个整数或一个象征性地表示权限的字符串。

有关返回文件权限的函数 `file-modes` ，请参阅测试可访问性。

    Function: set-default-file-modes mode ¶

该函数为 `Emacs` 及其子进程创建的新文件设置默认权限。使用 `Emacs` 创建的每个文件最初都具有这些权限，或者它们的子集（即使默认文件权限允许执行，write-region 也不会授予执行权限）。在 `GNU` 和其他类似 `POSIX` 的系统上，默认权限由 `'umask'` 值的按位补码给出，即在参数模式中设置的每个位都将在 `Emacs` 创建文件时使用的默认权限中重置。

参数 `mode` 应该是一个指定权限的整数，类似于上面的 `set-file-modes` 。只有最低的 `9` 位是有意义的。

保存现有文件的修改版本时，默认文件权限无效；保存文件会保留其现有权限。

    Macro: with-file-modes mode body… ~¶

~ 此宏使用临时设置为模式的新文件的默认权限评估正文表单（其值与上面的 `set-file-modes` 相同）。完成后，它恢复原始默认文件权限，并返回正文中最后一个表单的值。

例如，这对于创建私有文件很有用。

    Function: default-file-modes ¶

此函数以整数形式返回默认文件权限。

    Function: read-file-modes &optional prompt base-file ¶

该函数从 `minibuffer` 中读取一组文件模式位。第一个可选参数提示指定非默认提示。第二个可选参数 `base-file` 是文件的名称，如果用户键入的内容指定了与现有文件的权限相关的模式位，则该文件的权限是该函数返回的模式位的基础。

如果用户输入表示一个八进制数，则此函数返回该数字。如果它是模式位的完整符号规范，如 `"u=rwx"` ，则该函数使用 `file-modes-symbolic-to-number` 将其转换为等效的数值并返回结果。如果规范是相对的，如 `o+g` ，则规范所基于的权限取自基本文件的模式位。如果基本文件被省略或为零，则函数使用 `0` 作为基本模式位。完整的和相对的规范可以组合起来，如 `"u+r,g+rx,o+r,gw"` 。有关文件模式规范的描述，请参阅 `GNU Coreutils` 手册中的文件权限。

    Function: file-modes-symbolic-to-number modes &optional base-modes ¶

此函数将模式中的符号文件模式规范转换为等效的整数。如果符号规范基于现有文件，则该文件的模式位取自可选参数基本模式；如果该参数被省略或为零，则默认为 `0` ，即根本没有访问权限。

    Function: file-modes-number-to-symbolic modes ¶

此函数将模式中的数字文件模式规范转换为等效的符号形式。

    Function: set-file-times filename &optional time flag ¶

该函数将文件名的访问和修改时间设置为时间。如果时间设置成功，则返回值为 `t` ，否则为 `nil` 。time 默认为当前时间，并且必须是时间值（请参阅时间）。

默认情况下，此函数遵循符号链接。但是，如果可选参数标志是符号nofollow，如果它是符号链接，则此函数不跟随文件名；这有助于防止在其他地方无意中更改文件的时间。在不支持符号链接更改时间的平台上，当文件名是符号链接并且标志是 `nofollow` 时，此函数会发出错误信号。

    Function: set-file-extended-attributes filename attribute-alist ¶

这个函数为文件名设置 `Emacs` 识别的扩展文件属性。第二个参数属性列表应该是文件扩展属性返回的相同形式的列表。如果属性设置成功，则返回值为 `t` ，否则为 `nil` 。请参阅扩展文件属性。

    Function: set-file-selinux-context filename context ¶

此函数将文件名的 `SELinux` 安全上下文设置为上下文。上下文参数应该是一个列表（用户角色类型范围），其中每个元素都是一个字符串。请参阅扩展文件属性。

如果成功设置文件名的 `SELinux` 上下文，则该函数返回 `t` 。如果没有设置上下文（例如，如果 `SELinux` 被禁用，或者如果 `Emacs` 是在没有 `SELinux` 支持的情况下编译的），它返回 `nil` 。

    Function: set-file-acl filename acl ¶

此函数将文件名的访问控制列表设置为 `acl` 。acl 参数应该与函数 `file-acl` 返回的形式相同。请参阅扩展文件属性。

如果成功设置文件名的 `ACL` ，该函数返回 `t` ，否则返回 `nil` 。


<a id="org4007079"></a>

## 26.8 文件和二级存储

在 `Emacs` 更改文件后，这些更改可能无法在后来的电源或媒体故障中幸存下来，这两个原因都与效率有关。首先，操作系统可能会将已写入的数据与已存储在辅助存储中其他地方的数据混为一谈，直到稍后修改一个文件或另一个文件；如果辅助存储上的唯一副本由于媒体故障而丢失，这将丢失两个文件。其次，操作系统可能不会立即将数据写入二级存储，如果断电，二级存储会丢失数据。

尽管通过适当配置的文件系统可以在很大程度上避免这两种故障，但这种系统通常更昂贵或效率更低。在更典型的系统中，为了避免媒体故障，您可以将文件复制到不同的设备，为了避免电源故障，您可以使用 `write-region` 函数并将 `write-region-inhibit-fsync` 变量设置为 `nil` 。请参阅写入文件。


<a id="org4d417fc"></a>

## 26.9 文件名

在 `Emacs` 中和其他地方一样，文件通常以它们的名称来引用。Emacs 中的文件名表示为字符串。对文件进行操作的函数都需要一个文件名参数。

除了对文件本身进行操作外，Emacs Lisp 程序还经常需要对文件名进行操作；即，将它们分开并使用名称的一部分来构造相关的文件名。本节介绍如何操作文件名。

本节中的函数实际上并不访问文件，因此它们可以对不引用现有文件或目录的文件名进行操作。

在 `MS-DOS` 和 `MS-Windows` 上，这些函数（如实际操作文件的函数）接受 `MS-DOS` 或 `MS-Windows` 文件名语法，其中反斜杠分隔组件，以及 `POSIX` 语法；但它们总是返回 `POSIX` 语法。这使 `Lisp` 程序能够以 `POSIX` 语法指定文件名，并且无需更改即可在所有系统上正常工作。 ~17


<a id="org1196177"></a>

### 26.9.1~ 文件名组件

操作系统将文件分组到目录中。要指定文件，您必须指定目录和该目录中的文件名。因此，Emacs 认为文件名有两个主要部分：目录名部分和非目录部分（或目录中的文件名）。任何一部分都可能是空的。连接这两个部分会重现原始文件名。

在大多数系统上，目录部分是直到最后一个斜杠的所有内容（在 `MS-DOS` 或 `MS-Windows` 上也允许在输入中使用反斜杠）；非目录部分是其余部分。

出于某些目的，非目录部分进一步细分为专有名称和版本号。在大多数系统上，只有备份文件的名称中有版本号。

    Function: file-name-directory filename ¶

此函数返回文件名的目录部分，作为目录名（请参阅目录名），如果文件名不包含目录部分，则返回 `nil` 。

在 `GNU` 和其他类似 `POSIX` 的系统上，此函数返回的字符串总是以斜杠结尾。在 `MS-DOS` 上，它也可以以冒号结尾。

    (file-name-directory "lewis/foo")  ; GNU example
         ⇒ "lewis/"
    
    (file-name-directory "foo")        ; GNU example
         ⇒ nil

    Function: file-name-nondirectory filename ¶

此函数返回文件名的非目录部分。

    (file-name-nondirectory "lewis/foo")
         ⇒ "foo"
    
    (file-name-nondirectory "foo")
         ⇒ "foo"
    
    (file-name-nondirectory "lewis/")
         ⇒ ""

    Function: file-name-sans-versions filename &optional keep-backup-version ¶

此函数返回文件名，其中包含任何文件版本号、备份版本号或丢弃的尾随波浪号。

如果 `keep-backup-version` 不为零，则从返回值中丢弃文件系统所理解的真实文件版本号，但保留备份版本号。

    (file-name-sans-versions "~rms/foo.~1~")
         ⇒ "~rms/foo"
    
    (file-name-sans-versions "~rms/foo~")
         ⇒ "~rms/foo"
    
    (file-name-sans-versions "~rms/foo")
         ⇒ "~rms/foo"

    Function: file-name-extension filename &optional period ¶

在应用 `file-name-sans-versions` 删除任何版本/备份部分后，此函数返回文件名的最终扩展名（如果有）。文件名中的扩展名是最后一个 `。` 之后的部分。在姓氏组件中（减去任何版本/备份部分）。

对于 `foo` 等无扩展名的文件名，此函数返回 `nil` 。它为空扩展名返回 `，如 ~foo..` 如果文件名的最后一个组件以 `.` 开头，则该 `.`  ~ 不算作扩展的开始。因此，.emacs 的扩展名是 `nil` ，而不是 `'.emacs'` 。

如果 `period` 不为 `nil` ，则返回值包括分隔扩展名的句点，如果 `filename` 没有扩展名，则该值为 `""` 。

    Function: file-name-with-extension filename extension ¶

此函数返回扩展名设置为扩展名的文件名。如果扩展名中有一个前导点，则将被剥离。例如：

    (file-name-with-extension "file" "el")
         ⇒ "file.el"
    (file-name-with-extension "file" ".el")
         ⇒ "file.el"
    (file-name-with-extension "file.c" "el")
         ⇒ "file.el"

请注意，如果文件名或扩展名为空，或者文件名的形状像目录（即，如果 `directory-name-p` 返回非 `nil` ），则此函数将出错。

    Function: file-name-sans-extension filename ¶

此函数返回文件名减去其扩展名（如果有）。版本/备份部分（如果存在）仅在文件具有扩展名时才会被删除。例如，

    (file-name-sans-extension "foo.lose.c")
         ⇒ "foo.lose"
    (file-name-sans-extension "big.hack/foo")
         ⇒ "big.hack/foo"
    (file-name-sans-extension "/my/home/.emacs")
         ⇒ "/my/home/.emacs"
    (file-name-sans-extension "/my/home/.emacs.el")
         ⇒ "/my/home/.emacs"
    (file-name-sans-extension "~/foo.el.~3~")
         ⇒ "~/foo"
    (file-name-sans-extension "~/foo.~3~")
         ⇒ "~/foo.~3~"

请注意，最后两个示例中的 `'.~3`'~ 是备份部分，而不是扩展名。

    Function: file-name-base filename ¶

该功能是文件名无扩展名和文件名非目录的组合。例如，

    (file-name-base "/my/home/foo.c")
        ⇒ "foo"


<a id="org1cba7dd"></a>

### 26.9.2 绝对和相对文件名

文件系统中的所有目录从根目录开始形成一棵树。一个文件名可以指定从树根开始的所有目录名；然后它被称为绝对文件名。或者它可以指定文件在树中相对于默认目录的位置；然后它被称为相对文件名。在 `GNU` 和其他类似 `POSIX` 的系统上，在任何前导 `'`'~ 展开后，绝对文件名以 `'/'` 开头（参见 `abbreviate-file-name` ），而相对文件名则不然。在 `MS-DOS` 和 `MS-Windows` 上，绝对文件名以斜杠或反斜杠开头，或者以驱动器规范 `'x:/'` 开头，其中 `x` 是驱动器号。

    Function: file-name-absolute-p filename ¶

如果文件 `filename` 是绝对文件名，此函数返回 `t` ，否则返回 `nil` 。如果文件名的第一个组件是 `~，则文件名被认为是绝对的，或者是 ~~user` ，其中用户是有效的登录名。在以下示例中，假设有一个名为 `rms` 的用户，但没有名为 `nosuchuser` 的用户。

    
    
    (file-name-absolute-p "~rms/foo")
         ⇒ t
    
    (file-name-absolute-p "~nosuchuser/foo")
         ⇒ nil
    
    (file-name-absolute-p "rms/foo")
         ⇒ nil
    
    (file-name-absolute-p "/user/rms/foo")
         ⇒ t

给定一个可能的相对文件名，您可以扩展任何前导 `'`'~ 并使用 `expand-file-name` 将结果转换为绝对名称（请参阅扩展文件名的函数）。此函数将绝对文件名转换为相对名称：

    Function: file-relative-name filename &optional directory ¶

此函数尝试返回一个与文件名等效的相对名称，假设结果将被解释为相对于目录（绝对目录名称或目录文件名称）。如果 `directory` 被省略或为零，则默认为当前缓冲区的默认目录。

在某些操作系统上，绝对文件名以设备名开头。在这样的系统上，如果文件名以两个不同的设备名开头，则文件名没有基于目录的相对等价物。在这种情况下，file-relative-name 以绝对形式返回文件名。

    (file-relative-name "/foo/bar" "/foo/")
         ⇒ "bar"
    (file-relative-name "/foo/bar" "/hack/")
         ⇒ "../foo/bar"


<a id="orgeda551a"></a>

### 26.9.3 目录名称

目录名称是一个字符串，如果它命名任何文件，则必须命名一个目录。目录实际上是一种文件，它有一个文件名（称为目录文件名），它与目录名相关但通常不相同。（这与通常的 `POSIX` 术语不太一样。）同一实体的这两个名称通过句法转换相关联。在 `GNU` 和其他类似 `POSIX` 的系统上，这很简单：要获得目录名，请将 `/` 附加到尚未以 `/` 结尾的目录文件名。在 `MS-DOS` 上，这种关系更为复杂。

目录名和目录文件名之间的区别是微妙但至关重要的。当 `Emacs` 变量或函数参数被描述为目录名时，目录文件名是不可接受的。当 `file-name-directory` 返回一个字符串时，它始终是一个目录名。

以下两个函数在目录名和目录文件名之间进行转换。它们对环境变量替换（例如'$HOME'）和结构'`'、'.'没有什么特别的作用。和 ~'..'` 。

    Function: file-name-as-directory filename ¶

此函数以操作系统将解释为目录名称（目录名称）的形式返回表示文件名的字符串。在大多数系统上，这意味着在字符串上附加一个斜杠（如果它还没有以一个结尾）。

    (file-name-as-directory "~rms/lewis")
         ⇒ "~rms/lewis/"

    Function: directory-name-p filename ¶

如果文件名以目录分隔符结尾，则此函数返回非 `nil` 。这是 `GNU` 和其他类似 `POSIX` 的系统上的正斜杠 `/` ；MS-Windows 和 `MS-DOS` 将正斜杠和反斜杠 `'\'` 识别为目录分隔符。

    Function: directory-file-name dirname ¶

此函数以操作系统将解释为文件名（目录文件名）的形式返回表示 `dirname` 的字符串。在大多数系统上，这意味着从字符串中删除最终的目录分隔符，除非字符串完全由目录分隔符组成。

    (directory-file-name "~lewis/")
         ⇒ "~lewis"

    Function: file-name-concat directory &rest components ¶

将组件连接到目录，如果目录或前面的组件没有以斜杠结尾，则在组件之前插入一个斜杠。

    (file-name-concat "/tmp" "foo")
         ⇒ "/tmp/foo"

`nil`  或空字符串的目录或组件将被忽略——它们首先被过滤掉，不会以任何方式影响结果。

这与使用 `concat` 几乎相同，但 `dirname` （和非最终组件）可能以斜杠字符结尾，也可能不以斜杠字符结尾，并且此函数不会将这些字符加倍。

要将目录名称转换为其缩写，请使用此函数：

    Function: abbreviate-file-name filename ¶

此函数返回文件名的缩写形式。它应用 `directory-abbrev-alist` 中指定的缩写（参见 `GNU Emacs` 手册中的文件别名），然后如果参数命名主目录或其子目录之一中的文件，则用 ~~代替用户的主目录。如果主目录是根目录，则不会将其替换为 ~~，因为这不会使许多系统上的结果更短。

您可以将此函数用于目录名和文件名，因为它甚至可以将缩写识别为名称的一部分。


<a id="orgbe0ca46"></a>

### 26.9.4 扩展文件名的函数

扩展文件名意味着将相对文件名转换为绝对文件名。由于这是相对于默认目录完成的，因此您必须指定默认目录以及要扩展的文件名。它还涉及扩展诸如 `/` 之类的缩写（参见 `abbreviate-file-name` ），并消除诸如 `./` 和 `name/../` 之类的冗余。

    Function: expand-file-name filename &optional directory ¶

此函数将文件名转换为绝对文件名。如果提供了目录，则如果文件名是相对的且不以 `~开头，则它是默认目录。（directory 的值本身应该是绝对目录名或目录文件名；它可以以'`' 开头。）否则，使用当前缓冲区的 `default-directory` 值。例如：

    
    
    (expand-file-name "foo")
         ⇒ "/xcssun/users/rms/lewis/foo"
    
    (expand-file-name "../foo")
         ⇒ "/xcssun/users/rms/foo"
    
    (expand-file-name "foo" "/usr/spool/")
         ⇒ "/usr/spool/foo"

如果第一个斜杠之前的文件名部分是'`'，它会扩展为您的主目录，该目录通常由 ~HOME` 环境变量的值指定（参见 `GNU Emacs` 手册中的通用变量）。如果第一个斜杠之前的部分是 `'~user'` 并且如果 `user` 是一个有效的登录名，它会展开到用户的主目录。如果您不希望对可能以文字 `~开头的相对文件名进行此扩展，则可以使用 ~(concat (file-name-as-directory directory) filename)` 而不是 `(expand-file-name filename directory)` 。

包含 `.` 的文件名 `或 '..'` 被简化为它们的规范形式：

    (expand-file-name "bar/../foo")
         ⇒ "/xcssun/users/rms/lewis/foo"

在某些情况下，前导 `'..'` 组件可以保留在输出中：

    (expand-file-name "../home" "/")
         ⇒ "/../home"

这是为了在根目录 `/` 之上具有超级根概念的文件系统。在其他文件系统上，/../ 的解释与 `/` 完全相同。

扩大。或空字符串返回默认目录：

    (expand-file-name "." "/usr/spool/")
         ⇒ "/usr/spool"
    (expand-file-name "" "/usr/spool/")
         ⇒ "/usr/spool"

请注意，expand-file-name 不会扩展环境变量；只有替换文件名才能做到这一点：

    (expand-file-name "$HOME/foo")
         ⇒ "/xcssun/users/rms/lewis/$HOME/foo"

另请注意，expand-file-name 不遵循任何级别的符号链接。这导致 `file-truename` 和 `expand-file-name` 对待 `'..'` 的方式不同。假设 `'/tmp/bar'` 是指向目录 `'/tmp/foo/bar'` 的符号链接，我们得到：

    (file-truename "/tmp/bar/../myfile")
         ⇒ "/tmp/foo/myfile"
    
    (expand-file-name "/tmp/bar/../myfile")
         ⇒ "/tmp/myfile"

如果您可能需要遵循 `'..'` 之前的符号链接，则应确保调用 `file-truename` 而不事先直接或间接调用 `expand-file-name` 。见真名。

    Variable: default-directory ¶

此缓冲区局部变量的值是当前缓冲区的默认目录。它应该是一个绝对目录名；它可能以'〜'开头。此变量在每个缓冲区中都是缓冲区本地的。

expand-file-name 在其第二个参数为 `nil`  时使用默认目录。

该值始终是以斜杠结尾的字符串。

    default-directory
         ⇒ "/user/lewis/manual/"

    Function: substitute-in-file-name filename ¶

此函数将文件名中的环境变量引用替换为环境变量值。遵循标准 `Unix shell` 语法，'$' 是替换环境变量值的前缀。如果输入包含'$$'，则转换为'$'；这为用户提供了一种引用 `$` 的方法。

环境变量名称是跟在 `$` 后面的一系列字母数字字符（包括下划线）。如果 `$` 后面的字符是 `{` ，那么变量名就是匹配的 `}` 之前的所有内容。

在由替换文件名产生的输出上调用替换文件名往往会给出不正确的结果。例如，使用 `'$$'` 引用单个 `'$'` 将无法正常工作，并且环境变量值中的 `'$'` 可能会导致重复替换。因此，调用此函数并将输出放在将传递给此函数的位置的程序需要将所有 `$` 字符加倍，以防止随后出现错误结果。

这里我们假设保存用户主目录的环境变量 `HOME` 的值为 `/xcssun/users/rms` 。

    (substitute-in-file-name "$HOME/foo")
         ⇒ "/xcssun/users/rms/foo"

替换后，如果 `'`'~ 或 `'/'` 紧跟在另一个 `'/'` 之后，该函数将丢弃它之前的所有内容（直到紧接在前面的 `'/'` ）。

    (substitute-in-file-name "bar/~/foo")
         ⇒ "~/foo"
    
    (substitute-in-file-name "/usr/local/$HOME/foo")
         ⇒ "/xcssun/users/rms/foo"
         ;; /usr/local/ has been discarded.

有时，不需要扩展文件名。在这种情况下，可以引用文件名来抑制扩展，并按字面意思处理文件名。通过在文件名前加上'/:'来进行引用。

    Macro: file-name-quote name ¶

此宏将引号前缀 `/:` 添加到文件名。对于本地文件名，它在名称前加上'/:'。如果 `name` 是远程文件名，则 `name` 的本地部分（请参阅使某些文件名 `魔术` ）被引用。如果 `name` 已经是带引号的文件名，则 `name` 原封不动地返回。

    (substitute-in-file-name (file-name-quote "bar/~/foo"))
         ⇒ "/:bar/~/foo"
    
    
    (substitute-in-file-name (file-name-quote "/ssh:host:bar/~/foo"))
         ⇒ "/ssh:host:/:bar/~/foo"

该宏不能用于从魔术文件名中抑制文件名处理程序（请参阅使某些文件名 `魔术` ）。

    Macro: file-name-unquote name ¶

此宏从文件名中删除引号前缀 `/:` （如果有）。如果 `name` 是远程文件名，则 `name` 的本地部分不加引号。

    Macro: file-name-quoted-p name ¶

当名称以前缀 `/:` 引用时，此宏返回非零。如果 `name` 是远程文件名，则检查 `name` 的本地部分。


<a id="orgfc64a4f"></a>

### 26.9.5 生成唯一文件名

有些程序需要写入临时文件。以下是为此类文件构造名称的常用方法：

    (make-temp-file name-of-application)

make-temp-file 的工作是防止两个不同的用户或两个不同的工作尝试使用完全相同的文件名。

    Function: make-temp-file prefix &optional dir-flag suffix text ¶

此函数创建一个临时文件并返回其名称。Emacs 通过在每个 `Emacs` 作业中添加一些不同的随机字符作为前缀来创建临时文件的名称。结果保证是一个新创建的文件，如果以字符串形式给出，则包含文本，否则为空。在 `MS-DOS` 上，此函数可以截断前缀以适应 `8+3` 文件名限制。如果前缀是一个相对文件名，它会针对临时文件目录进行扩展。

    (make-temp-file "foo")
         ⇒ "/tmp/foo232J6v"

当 `make-temp-file` 返回时，文件已创建并且为空。此时，您应该将预期的内容写入文件。

如果 `dir-flag` 不是 `nil` ，make-temp-file 会创建一个空目录而不是空文件。它返回该目录的文件名，而不是目录名。请参阅目录名称。

如果 `suffix` 不为 `nil` ，make-temp-file 会将其添加到文件名的末尾。

如果 `text` 是一个字符串，make-temp-file 将它插入到文件中。

为了防止在同一个 `Emacs` 中运行的不同库之间发生冲突，每个使用 `make-temp-file` 的 `Lisp` 程序都应该有自己的前缀。添加到前缀末尾的数字用于区分在不同 `Emacs` 作业中运行的同一应用程序。即使在一个 `Emacs` 作业中，额外添加的字符也允许使用大量不同的名称。

临时文件的默认目录由变量temporary-file-directory 控制。此变量为用户提供了一种统一的方式来指定所有临时文件的目录。一些程序使用 `small-temporary-file-directory` 代替，如果它不是 `nil`  的话。要使用它，您应该在调用 `make-temp-file` 之前针对正确的目录展开前缀。

    User Option: temporary-file-directory ¶

此变量指定用于创建临时文件的目录名称。它的值应该是一个目录名（参见目录名），但是如果该值是一个目录的文件名，那么 `Lisp` 程序可以很好地应对。使用该值作为 `expand-file-name` 的第二个参数是实现此目的的好方法。

默认值根据您的操作系统以合理的方式确定；它基于 `TMPDIR` 、TMP 和 `TEMP` 环境变量，如果未定义这些变量，则回退到系统相关名称。

即使你不使用 `make-temp-file` 创建临时文件，你仍然应该使用这个变量来决定将文件放在哪个目录。但是，如果你希望文件很小，你应该使用 `small-temporary -file-directory` 如果那是非零的话。

    User Option: small-temporary-file-directory ¶

此变量指定用于创建某些可能很小的临时文件的目录名称。

如果你想写一个可能很小的临时文件，你应该像这样计算目录：

    (make-temp-file
      (expand-file-name prefix
    		    (or small-temporary-file-directory
    			temporary-file-directory)))

    Function: make-temp-name base-name ¶

此函数生成一个可能是唯一文件名的字符串。该名称以 `base-name` 开头，并附加了几个随机字符，这些字符在每个 `Emacs` 作业中都不同。它类似于 `make-temp-file` ，除了 `(i)` 它只是构造一个名称而不创建文件，(ii) base-name 应该是一个绝对文件名，而不是魔术，以及 `(iii)` 如果返回的文件name 很神奇，它可能会命名一个现有的文件。请参阅使某些文件名 `神奇` 。

警告：在大多数情况下，您不应该使用此功能；改用 `make-temp-file` ！ ~ 此函数容易受到 `make-temp-name` 调用和文件创建之间的竞争条件的影响，这在某些情况下可能会导致安全漏洞。

有时，需要在远程主机或挂载目录上创建临时文件。以下两个函数支持这一点。

    Function: make-nearby-temp-file prefix &optional dir-flag suffix ¶

此功能类似于 `make-temp-file` ，但它创建一个尽可能靠近默认目录的临时文件。如果 `prefix` 是相对文件名，而 `default-directory` 是远程文件名或位于已挂载的文件系统上，则在函数 `temporary-file-directory` 返回的目录中创建临时文件。否则，使用函数 `make-temp-file` 。prefix、dir-flag 和 `suffix` 与 `make-temp-file` 中的含义相同。

    (let ((default-directory "/ssh:remotehost:"))
      (make-nearby-temp-file "foo"))
         ⇒ "/ssh:remotehost:/tmp/foo232J6v"

    Function: temporary-file-directory ¶

通过 `make-nearby-temp-file` 写入临时文件的目录。在远程默认目录的情况下，这是该远程主机上临时文件的目录。如果这样的目录不存在，或者默认目录应该位于已安装的文件系统上（请参阅mounted-file-systems），则该函数返回默认目录。对于非远程和非挂载的默认目录，返回变量临时文件目录的值。

要提取临时文件的文件名的本地部分，请使用 `file-local-name` （请参阅使某些文件名 `变魔术` ）。


<a id="org6c071bc"></a>

### 26.9.6 文件名补全

本节介绍用于完成文件名的低级子例程。有关更高级别的功能，请参阅读取文件名。

    Function: file-name-all-completions partial-filename directory ¶

此函数返回目录目录中名称以部分文件名开头的文件的所有可能完成的列表。完成的顺序是目录中文件的顺序，它是不可预测的，也没有传达任何有用的信息。

参数 `partial-filename` 必须是不包含目录部分和斜杠（或在某些系统上为反斜杠）的文件名。如果目录不是绝对的，则当前缓冲区的默认目录将附加到目录。

在以下示例中，假设 `rms/lewis` 是当前默认目录，并且有五个名称以 `'f'` 开头的文件：foo、file~、file.c、file.c.~1~ 和 `file.c .~2`.

    
    
    (file-name-all-completions "f" "")
         ⇒ ("foo" "file~" "file.c.~2~"
    		"file.c.~1~" "file.c")
    
    
    (file-name-all-completions "fo" "")
         ⇒ ("foo")

    Function: file-name-completion filename directory &optional predicate ¶

~ 该函数补全目录目录中的文件名filename。它返回目录目录中以文件名开头的所有文件名共有的最长前缀。如果谓词非零，则在使用一个参数（扩展的绝对文件名）调用该函数后，它会忽略不满足谓词的可能完成。

如果只存在一个匹配并且文件名完全匹配，则函数返回 `t` 。如果目录目录不包含以文件名开头的名称，则该函数返回 `nil` 。

在以下示例中，假设当前默认目录有五个名称以 `f` 开头的文件：foo、file~、file.c、file.c.~1~ 和 `file.c.~2` 。

    (file-name-completion "fi" "")
         ⇒ "file"
    
    
    (file-name-completion "file.c.~1" "")
         ⇒ "file.c.~1~"
    
    
    (file-name-completion "file.c.~1~" "")
         ⇒ t
    
    
    (file-name-completion "file.c.~3" "")
         ⇒ nil

    User Option: completion-ignored-extensions ¶

file-name-completion 通常会忽略此列表中以任何字符串结尾的文件名。当所有可能的补全都以这些后缀之一结尾时，它不会忽略它们。此变量对文件名全部完成没有影响。

典型值可能如下所示：

    completion-ignored-extensions
         ⇒ (".o" ".elc" "~" ".dvi")

如果完成忽略扩展的元素以斜杠 `/` 结尾，则它表示目录。不以斜线结尾的元素永远不会匹配目录；因此，上述值不会过滤掉名为 `foo.elc` 的目录。


<a id="org00144a7"></a>

### 26.9.7 标准文件名

有时，Emacs Lisp 程序需要为特定用途指定标准文件名——通常是保存当前用户指定的配置数据。通常，此类文件应位于 `user-emacs-directory` 指定的目录中，默认情况下通常为 `/.config/emacs/` 或 `/.emacs.d/` （请参阅 `Emacs` 如何在 `GNU Emacs` 中查找您的初始化文件手动的）。例如，缩写定义默认存储在 `/.config/emacs/abbrev_defs` 或 `/.emacs.d/abbrev_defs` 中。指定此类文件名的最简单方法是使用函数 `locate-user-emacs-file` 。

    Function: locate-user-emacs-file base-name &optional old-name ¶

此函数返回 `Emacs` 特定配置或数据文件的绝对文件名。参数 `base-name` 应该是一个相对文件名。返回值是user-emacs-directory指定的目录中文件的绝对名称；如果该目录不存在，此函数将创建它。

如果可选参数 `old-name` 不为 `nil` ，则它指定用户主目录中的一个文件 `/old-name` 。如果存在这样的文件，则返回值是该文件的绝对名称，而不是 `base-name` 指定的文件。此参数旨在供 `Emacs` 包使用以提供向后兼容性。例如，在引入 `user-emacs-directory` 之前，缩写文件位于 `/.abbrev_defs` 。以下是 `abbrev-file-name` 的定义：

    (defcustom abbrev-file-name
      (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
      "Default name of file from which to read abbrevs."
      …
      :type 'file)

locate-user-emacs-file 用作子例程的用于标准化文件名的低级函数是 `convert-standard-filename` 。

    Function: convert-standard-filename filename ¶

该函数根据文件名返回一个文件名，符合当前操作系统的约定。

在 `GNU` 和其他类似 `POSIX` 的系统上，这只是返回文件名。在其他操作系统上，它可能会强制执行系统特定的文件名约定；例如，在 `MS-DOS` 上，此函数执行各种更改以强制执行 `MS-DOS` 文件名限制，包括转换任何前导 `'.' ~ 到 ~'_'` 并在 `'.'` 之后截断为三个字符。

使用此函数的推荐方法是指定一个符合 `GNU` 和 `Unix` 系统约定的名称，并将其传递给 `convert-standard-filename` 。


<a id="orgc670a21"></a>

## 26.10 目录的内容

目录是一种文件，其中包含以各种名称输入的其他文件。目录是文件系统的一个特征。

Emacs 可以将目录中文件的名称作为 `Lisp` 列表列出，或者使用 `ls shell` 命令在缓冲区中显示名称。在后一种情况下，它可以选择显示有关每个文件的信息，具体取决于传递给 `ls` 命令的选项。

    Function: directory-files directory &optional full-name match-regexp nosort count ¶

此函数返回目录目录中文件的名称列表。默认情况下，列表按字母顺序排列。

如果 `full-name` 不为零，则该函数返回文件的绝对文件名。否则，它返回相对于指定目录的名称。

如果 `match-regexp` 不为 `nil` ，则此函数仅返回那些其非目录部分包含与该正则表达式匹配的文件名——其他文件名将从列表中排除。在不区分大小写的文件系统上，正则表达式匹配不区分大小写。

如果 `nosort` 不为零，则 `directory-files` 不会对列表进行排序，因此您可以不按特定顺序获取文件名。如果您想要尽可能快的速度并且不关心文件的处理顺序，请使用此选项。如果处理顺序对用户可见，那么如果您对名称进行排序，用户可能会更开心。

如果 `count` 不为零，则该函数将返回第一个 `count` 个文件的名称，或所有文件的名称，以先发生者为准。count 必须是大于零的整数。

    (directory-files "~lewis")
         ⇒ ("#foo#" "#foo.el#" "." ".."
    	 "dired-mods.el" "files.texi"
    	 "files.texi.~1~")

如果目录不是可以读取的目录的名称，则会发出错误信号。

    Function: directory-empty-p directory ¶

如果给定的目录是可访问的目录并且它不包含任何文件，则此实用程序函数返回 `t` ，即，它是一个空目录。它将忽略 `。`   和 `..` 在将它们作为目录中的文件返回的系统上。

指向目录的符号链接算作目录。请参阅 `file-symlink-p` 以区分符号链接。

    Function: directory-files-recursively directory regexp &optional include-directories predicate follow-symlinks ¶

返回目录下名称与正则表达式匹配的所有文件。此函数递归搜索指定目录及其子目录，查找其基本名称（即没有前导目录）与指定正则表达式匹配的文件，并返回匹配文件的绝对文件名列表（参见绝对文件名） `. ~ 文件名以深度优先顺序返回，这意味着某些子目录中的文件在其父目录中的文件之前返回。此外，在每个子目录中找到的匹配文件按其基本名称的字母顺序排序。默认情况下，名称与正则表达式匹配的目录会从列表中省略，但如果可选参数 ~include-directories` 不为 `nil` ，则它们会被包括在内。

默认情况下，所有子目录都下降到。如果谓词是 `t` ，则尝试进入子目录时的错误（例如，如果该用户不可读）将被忽略。如果它既不是 `nil`  也不是 `t` ，它应该是一个带有一个参数（子目录名称）的函数，并且如果要下降到目录，它应该返回非 `nil` 。

默认情况下不遵循指向子目录的符号链接，但如果 `follow-symlinks` 不为 `nil` ，则会遵循它们。

    Function: locate-dominating-file file name ¶

从文件开始，沿着目录树层次结构查找存在名称（字符串）的第一个目录，然后返回该目录。如果 `file` 是一个文件，它的目录将作为搜索的起点；否则文件应该是一个开始的目录。该函数在起始目录中查找，然后在其父目录中查找，然后在其父目录的父目录中查找，等等，直到找到具有名称的目录或到达文件系统的根目录而没有找到名称——在后一种情况下，函数返回 `nil`  .

参数名称也可以是谓词函数。谓词为函数检查的每个目录调用，从文件开始（即使文件不是目录）。它使用一个参数（文件或目录）调用，如果该目录是它要查找的目录，则应返回非零。

    Function: directory-files-and-attributes directory &optional full-name match-regexp nosort id-format count ¶

在决定报告哪些文件以及如何报告它们的名称时，这类似于目录文件。但是，它不是返回文件名列表，而是为每个文件返回一个列表（文件名.属性），其中属性是文件属性为该文件返回的内容。可选参数 `id-format` 与文件属性的相应参数具有相同的含义（请参阅文件属性的定义）。

    Constant: directory-files-no-dot-files-regexp ¶

此正则表达式匹配除 `'.'` 以外的任何文件名 `和 '..'` 。更准确地说，它匹配除这两个之外的任何非空字符串的部分。它作为目录文件和目录文件和属性的 `match-regexp` 参数很有用：

    (directory-files "/foo" nil directory-files-no-dot-files-regexp)

如果目录 `'/foo'` 为空，则返回 `nil` 。

    Function: file-expand-wildcards pattern &optional full ¶

此函数扩展通配符模式模式，返回与其匹配的文件名列表。

如果模式被写为绝对文件名，则值也是绝对的。

如果 `pattern` 被写为相对文件名，则相对于当前默认目录进行解释。返回的文件名通常也与当前默认目录相关。但是，如果 `full` 不为零，则它们是绝对的。

    Function: insert-directory file switches &optional wildcard full-directory-p ¶

此函数插入​​（在当前缓冲区中）目录文件的目录列表，根据开关用 `ls` 格式化。它在插入的文本之后留下点。开关可以是一串选项，也可以是代表单个选项的字符串列表。

参数文件可以是目录或包含通配符的文件规范。如果通配符不为零，则意味着将文件视为带有通配符的文件规范。

如果 `full-directory-p` 不为零，则表示目录列表应显示目录的全部内容。当文件是目录并且开关不包含 `-d` 时，您应该指定 `t` 。（ls 的 `-d` 选项表示将目录本身描述为文件，而不是显示其内容。）

在大多数系统上，此功能通过运行一个目录列表程序来工作，该程序的名称在变量 `insert-directory-program` 中。如果通配符不为 `nil` ，它还会运行由 `shell-file-name` 指定的 `shell` ，以扩展通配符。

MS-DOS 和 `MS-Windows` 系统通常缺少标准的 `Unix` 程序 `ls` ，所以这个函数用 `Lisp` 代码模拟标准的 `Unix` 程序 `ls` 。

作为一个技术细节，当 `switch` 包含 `long '--dired'` 选项时，insert-directory 会对其进行特殊处理，以便 `dired` 。但是，通常等效的短 `-D` 选项只是传递给插入目录程序，就像任何其他选项一样。

    Variable: insert-directory-program ¶

该变量的值是为函数插入目录生成目录列表而运行的程序。它在使用 `Lisp` 代码生成列表的系统上被忽略。


<a id="org8299f63"></a>

## 26.11 创建、复制和删除目录

大多数 `Emacs Lisp` 文件操作函数在用于目录文件时都会出错。例如，您不能使用 `delete-file` 删除目录。这些特殊功能用于创建和删除目录。

    Command: make-directory dirname &optional parents ¶

此命令创建一个名为 `dirname` 的目录。如果 `parents` 不是 `nil` ，就像交互式调用中的情况一样，这意味着首先创建父目录，如果它们不存在的话。mkdir 是这个的别名。

    Command: make-empty-file filename &optional parents ¶

此命令创建一个名为 `filename` 的空文件。作为 `make-directory` ，如果 `parents` 不为 `nil` ，此命令将创建父目录。如果文件名已经存在，则此命令会发出错误信号。

    Command: copy-directory dirname newname &optional keep-time parents copy-contents ¶

此命令将名为 `dirname` 的目录复制到 `newname` 。如果 `newname` 是目录名，则 `dirname` 将被复制到那里的子目录中。请参阅目录名称。

它始终设置复制文件的文件模式以匹配相应的原始文件。

第三个参数 `keep-time non-nil` 表示保留复制文件的修改时间。前缀 `arg` 使保持时间非零。

第四个参数 `parents` 表示如果父目录不存在，是否创建父目录。交互式地，这是默认情况下发生的。

第五个参数copy-contents，如果非 `nil` ，表示如果后者是目录名，则将dirname的内容直接复制到newname中，而不是将dirname作为子目录复制到其中。

    Command: delete-directory dirname &optional recursive trash ¶

此命令删除名为 `dirname` 的目录。函数 `delete-file` 不适用于目录文件；您必须为它们使用删除目录。如果 `recursive` 为 `nil` ，并且目录包含任何文件，则 `delete-directory` 会发出错误信号。如果 `recursive` 不为零，则不会仅仅因为目录或其文件在 `delete-directory` 到达它们之前被其他进程删除而产生错误。

delete-directory 仅遵循父目录级别的符号链接。

如果可选参数垃圾是非零并且变量 `delete-by-moving-to-trash` 是非零，则此命令将文件移动到系统垃圾箱而不是删除它。请参阅 `GNU Emacs` 手册中的其他文件操作。当交互调用时，如果没有给出前缀参数，则垃圾为 `t` ，否则为 `nil` 。


<a id="org5df0486"></a>

## 26.12 使某些文件名 `神` 奇

您可以对某些文件名实施特殊处理。这被称为让这些名字变得神奇。此功能的主要用途是实现对远程文件的访问（请参阅 `GNU Emacs` 手册中的远程文件）。

要定义一种魔术文件名，您必须提供一个正则表达式来定义名称类（所有匹配正则表达式的名称），以及一个处理程序，该处理程序为匹配的文件名实现所有原始 `Emacs` 文件操作。

变量 `file-name-handler-alist` 包含一个处理程序列表，以及确定何时应用每个处理程序的正则表达式。每个元素都有这种形式：

    (regexp . handler)

所有用于文件访问和文件名转换的 `Emacs` 原语都会根据 `file-name-handler-alist` 检查给定的文件名。如果文件名与正则表达式匹配，则原语通过调用处理程序来处理该文件。

给 `handler` 的第一个参数是原语的名称，作为一个符号；其余参数是传递给该原语的参数。（这些参数中的第一个通常是文件名本身。）例如，如果您这样做：

    (file-exists-p filename)

并且文件名有处理程序处理程序，然后处理程序被这样调用：

    (expand-file-name filename dirname)

当一个函数接受两个或多个必须是文件名的参数时，它会检查每个名称以查找处理程序。例如，如果您这样做：

    (funcall handler 'file-exists-p filename)

然后它检查文件名的处理程序，然后检查目录名的处理程序。在任何一种情况下，处理程序的调用方式如下：

    (funcall handler 'expand-file-name filename dirname)

然后处理程序需要确定是处理文件名还是目录名。

如果指定的文件名匹配多个处理程序，则匹配文件名中最后一个开始的处理程序优先。选择此规则是为了首先处理解压缩等作业的处理程序，然后处理远程文件访问等作业的处理程序。

以下是魔术文件名处理程序要处理的操作：

访问文件，添加名称到文件，字节编译器基础文件名，
复制目录，复制文件，删除目录，删除文件，差异最新备份文件，目录文件名，目录文件，目录文件和属性，dired-compress-file，dired-取消缓存，执行路径，扩展文件名，
文件可访问目录-p、文件-acl、文件属性、文件目录-p、文件相等-p、文件可执行文件-p、文件存在-p、文件在目录-p、文件-本地复制，文件锁定-p，文件模式，文件名所有完成，文件名作为目录，文件名不区分大小写-p，文件名完成，文件名-目录、文件名非目录、文件名无版本、文件比文件-p、文件通知添加监视、文件通知-rm-监视、文件通知有效-p、文件所有权保留-p，文件可读-p，文件-常规-p，文件-远程-p，文件-selinux-context，文件-符号链接-p，文件-系统信息，文件-真名，文件-可写-p，查找备份文件名，
获取文件缓冲区、插入目录、插入文件内容、
加载，锁定文件，生成自动保存文件名，生成目录，生成目录内部，生成锁定文件名，生成附近临时文件，生成过程，生成符号-关联，
进程文件，重命名文件，设置文件 `acl` ，设置文件模式，设置文件 `selinux` 上下文，设置文件时间，设置访问文件修改时间，shell 命令，启动文件-进程，替代文件名，
临时文件目录、未处理文件名目录、解锁文件、vc 注册、验证访问文件修改时间、
写区域。

如果访问参数为非零，则插入文件内容的处理程序通常需要使用 `(set-buffer-modified-p nil)` 清除缓冲区的修改标志。如果缓冲区被锁定，这也具有解锁缓冲区的效果。

处理程序函数必须处理所有上述操作，以及将来可能添加的其他操作。它不需要自己实现所有这些操作——当它对某个操作没有什么特别的事情时，它可以重新调用原语，以通常的方式处理该操作。它应该始终为它无法识别的操作重新调用原语。这是执行此操作的一种方法：

    (defun my-file-handler (operation &rest args)
      ;; First check for the specific operations
      ;; that we have special handling for.
      (cond ((eq operation 'insert-file-contents) …)
    	((eq operation 'write-region) …)
    	…
    	;; Handle any operation we don’t know about.
    	(t (let ((inhibit-file-name-handlers
    		  (cons 'my-file-handler
    			(and (eq inhibit-file-name-operation operation)
    			     inhibit-file-name-handlers)))
    		 (inhibit-file-name-operation operation))
    	     (apply operation args)))))

当一个处理函数决定为手头的操作调用普通的 `Emacs` 原语时，它需要防止原语再次调用相同的处理程序，从而导致无限递归。上面的示例显示了如何使用变量禁止文件名处理程序和禁止文件名操作来执行此操作。小心使用它们，如上所示；在多个处理程序的情况下，细节对于正确的行为至关重要，对于具有两个文件名的操作，每个文件名可能都有处理程序。

对文件的实际访问没有真正做任何特殊处理的处理程序——例如为远程文件名实现主机名完成的处理程序——应该有一个非零安全魔法属性。例如，Emacs 通常会保护它在 `PATH` 中找到的目录名称不会变成魔法，如果它们看起来像魔法文件名，则会通过在它们前面加上 `'/:'` 前缀。但是，如果将用于它们的处理程序具有非零安全魔术属性，则不会添加 `/` ：~ 。

文件名处理程序可以有一个操作属性来声明它以一种重要的方式处理哪些操作。如果这个属性有一个非零值，它应该是一个操作列表；那么只有那些操作会调用处理程序。这避免了效率低下，但它的主要目的是用于自动加载的处理程序函数，以便它们不会被加载，除非它们有真正的工作要做。

简单地将所有操作推迟到通常的原语是行不通的。例如，如果文件名处理程序适用于 `file-exists-p` ，那么它必须自己处理加载，因为在这种情况下，通常的加载代码将无法正常工作。但是，如果处理程序使用操作属性说它不处理文件存在-p，那么它不需要处理负载。

    Variable: inhibit-file-name-handlers ¶

此变量包含一个处理程序列表，当前禁止使用这些处理程序进行某个操作。

    Variable: inhibit-file-name-operation ¶

当前禁止某些处理程序的操作。

    Function: find-file-name-handler file operation ¶

此函数返回文件名 `file` 的处理函数，如果没有则返回 `nil` 。参数操作应该是对文件执行的操作——当您调用它时，您将作为第一个参数传递给处理程序的值。如果 `operation` 等于 `inhibitor-file-name-operation` ，或者如果在处理程序的操作属性中找不到它，则此函数返回 `nil` 。

    Function: file-local-copy filename ¶

此函数将文件 `filename` 复制到本地计算机上的普通非魔术文件（如果它不在本地计算机上）。如果魔术文件名引用其他机器上的文件，则应处理文件本地复制操作。用于远程文件访问以外的其他目的的魔术文件名不应处理文件本地复制；那么这个函数会将文件视为本地文件。

如果文件名是本地的，无论是否魔法，这个函数什么都不做并且返回 `nil` 。否则返回本地复制文件的文件名。

    Function: file-remote-p filename &optional identification connected ¶

此函数测试文件名是否为远程文件。如果文件名是本地的（不是远程的），则返回值为 `nil` 。如果文件名确实是远程的，则返回值是一个标识远程系统的字符串。

此标识符字符串可以包括主机名和用户名，以及指定用于访问远程系统的方法的字符。例如，文件名 `/sudo::/some/file` 的远程标识符字符串是 `/sudo:root@localhost:` 。

如果 `file-remote-p` 为两个不同的文件名返回相同的标识符，这意味着它们存储在同一个文件系统上，并且可以在本地相互访问。例如，这意味着可以启动同时访问两个文件的远程进程。文件名处理程序的实现者需要确保这个原则是有效的。

标识指定标识符的哪一部分应作为字符串返回。标识可以是符号方法、用户或主机；任何其他值都像 `nil`  一样处理，意味着返回完整的标识符字符串。在上面的示例中，远程用户标识符字符串将是 `root` 。

如果 `connected` 不是 `nil` ，即使文件名是远程的，如果 `Emacs` 没有到它的主机的网络连接，这个函数也会返回 `nil` 。当您想避免在连接不存在时建立连接的延迟时，这很有用。

    Function: unhandled-file-name-directory filename ¶

这个函数返回一个非魔法目录的名称。对于非魔术文件名，它返回相应的目录名（请参阅目录名）。对于魔术文件名，它调用文件名处理程序，因此决定返回什么值。如果本地进程无法访问文件名，则文件名处理程序应通过返回 `nil`  来指示。

这对于运行子进程很有用；每个子进程都必须有一个非魔法目录作为其当前目录，这个函数是一个很好的方法。

    Function: file-local-name filename ¶

此函数返回文件名的本地部分。这是文件名中在远程主机上标识它的部分，通常通过从远程文件名中删除指定远程主机和访问它的方法的部分来获得。例如：

    (file-local-name "/ssh:user@host:/foo/bar")
         ⇒ "/foo/bar"

对于远程文件名，此函数返回一个文件名，该文件名可以直接用作远程进程的参数（请参阅创建异步进程和创建同步进程），也可以作为在远程主机上运行的程序。如果文件名是本地的，则此函数将其原封不动地返回。

    User Option: remote-file-name-inhibit-cache ¶

可以缓存远程文件的属性以获得更好的性能。如果它们在 `Emacs` 的控制之外被更改，缓存的值将变为无效，并且必须重新读取。

当此变量设置为 `nil`  时，缓存值永不过期。谨慎使用此设置，仅当您确定除了 `Emacs` 之外没有任何东西会更改远程文件。如果设置为 `t` ，则从不使用缓存值。这是最安全的值，但可能会导致性能下降。

折衷方案是将其设置为正数。这意味着自缓存值起，缓存值将用于该秒数。如果定期检查远程文件，最好将此变量绑定到小于连续检查之间的时间段的值。例如：

    (defun display-time-file-nonempty-p (file)
      (let ((remote-file-name-inhibit-cache
    	 (- display-time-interval 5)))
        (and (file-exists-p file)
    	 (< 0 (file-attribute-size
    	       (file-attributes
    		(file-chase-links file)))))))


<a id="org9517f9b"></a>

## 26.13 文件格式转换

Emacs 执行几个步骤来将缓冲区中的数据（文本、文本属性和可能的​​其他信息）与适合存储到文件中的表示形式相互转换。本节介绍执行这种格式转换的基本函数，即用于将文件读入缓冲区的 `insert-file-contents` 和用于将缓冲区写入文件的 `write-region` 。


<a id="org61fc99d"></a>

### 26.13.1 概述

函数插入文件内容：

-   最初，将文件中的字节插入缓冲区；
-   将字节解码为适当的字符；
-   处理由 `format-alist` 中的条目定义的格式；和
-   调用后插入文件函数中的函数。

函数写入区域：

-   最初，调用 `write-region-annotate-functions` 中的函数；
-   处理由 `format-alist` 中的条目定义的格式；
-   根据需要将字符编码为字节；和
-   用字节修改文件。

这显示了最低级别操作的对称性；阅读和写作以相反的顺序处理事情。本节的其余部分描述了围绕上述三个变量的两个工具，以及一些相关的函数。编码系统，有关字符编码和解码的详细信息。


<a id="org81208e0"></a>

### 26.13.2 往返规范

这两个工具中最通用的是由变量 `format-alist` 控制，它是文件格式规范的列表，它描述了 `Emacs` 缓冲区中数据的文件中使用的文本表示。读取和写入的描述是成对的，这就是我们称之为 `往返` 规范的原因（参见 `Piecemeal Specification` ，非成对规范）。

    Variable: format-alist ¶

此列表包含每个已定义文件格式的格式定义。每个格式定义都是这种形式的列表：

    (name doc-string regexp from-fn to-fn modify mode-fn preserve)

以下是格式定义中元素的含义：

    name

此格式的名称。

    doc-string

格式的文档字符串。

    regexp

用于识别以这种格式表示的文件的正则表达式。如果为零，则永远不会自动应用格式。

    from-fn

以这种格式解码数据的 `shell` 命令或函数（将文件数据转换为通常的 `Emacs` 数据表示）。

一个shell命令被表示为一个字符串；Emacs 将该命令作为过滤器运行以执行转换。

如果 `from-fn` 是一个函数，则使用两个参数调用它，begin 和 `end` ，它们指定它应该转换的缓冲区部分。它应该通过就地编辑来转换文本。因为这可以改变文本的长度，所以 `from-fn` 应该返回修改后的结束位置。

from-fn 的一项职责是确保文件的开头不再匹配正则表达式。否则很可能会再次被调用。此外，from-fn 不得涉及除被解码的缓冲区或文件之外的缓冲区或文件，否则可能会覆盖用于格式化的内部缓冲区。

    to-fn

以这种格式编码数据的 `shell` 命令或函数——即将通常的 `Emacs` 数据表示转换为这种格式。

如果 `to-fn` 为字符串，则为 `shell` 命令；Emacs 将该命令作为过滤器运行以执行转换。

如果 `to-fn` 是一个函数，则使用三个参数调用它：begin 和 `end` ，它们指定它应该转换的缓冲区部分，以及 `buffer` ，它指定哪个缓冲区。它可以通过两种方式进行转换：

通过就地编辑缓冲区。在这种情况下， `to-fn` 应该返回文本范围的结束位置，如修改后的那样。
通过返回注释列表。这是一个形式为 `(position . string)` 的元素列表，其中 `position` 是一个整数，指定要写入的文本中的相对位置，而 `string` 是要添加的注释。当 `to-fn` 返回时，列表必须按位置顺序排序。

当 `write-region` 实际将文本从缓冲区写入文件时，它会在相应位置混合指定的注释。所有这些都发生在不修改缓冲区的情况下。

to-fn 不得涉及除被编码的缓冲区或文件之外的缓冲区或文件，否则用于格式化的内部缓冲区可能会被覆盖。

    modify

一个标志，如果编码函数修改了缓冲区，则为 `t` ，如果它通过返回注释列表工作，则为 `nil` 。

    mode-fn

访问从这种格式转换的文件后调用的次要模式函数。该函数使用一个参数调用，整数 `1` ；告诉次要模式函数启用该模式。

    preserve

一个标志，t 如果 `format-write-file` 不应该从 `buffer-file-format` 中删除此格式。

insert-file-contents 函数在读取指定文件时自动识别文件格式。它根据格式定义的正则表达式检查文件开头的文本，如果找到匹配项，则调用该格式的解码函数。然后它再次检查所有已知的格式。它会不断检查它们，直到它们都不适用。

使用 `find-file-noselect` 或使用它的命令访问文件，同样执行转换（因为它调用 `insert-file-contents` ）；它还为它解码的每种格式调用模式函数。它将格式名称列表存储在缓冲区局部变量 `buffer-file-format` 中。

    Variable: buffer-file-format ¶

此变量说明访问文件的格式。更准确地说，这是在访问当前缓冲区文件的过程中解码的文件格式名称列表。它在所有缓冲区中始终是缓冲区本地的。

当 `write-region` 将数据写入文件时，它首先调用 `buffer-file-format` 中列出的格式的编码函数，按照在列表中出现的顺序。

    Command: format-write-file file format &optional confirm ¶

该命令将当前缓冲区内容以基于格式的格式写入文件文件，格式是格式名称的列表。它从 `format` 开始构造实际的格式，然后将 `buffer-file-format` 的值中的任何元素附加一个非 `nil`  保留标志（见上文），如果它们尚不存在于 `format` 中。然后它使用这种格式更新缓冲区文件格式，使其成为未来保存的默认值。除格式参数外，此命令类似于 `write-file` 。特别是，confirm 与 `write-file` 的相应参数具有相同的含义和交互处理。请参阅写入文件的定义。

    Command: format-find-file file format ¶

该命令查找文件文件，根据格式格式对其进行转换。如果稍后保存缓冲区，它也会将格式设置为默认值。

参数格式是格式名称的列表。如果 `format` 为 `nil` ，则不进行转换。交互地，只输入 `RET` 作为格式指定 `nil` 。

    Command: format-insert-file file format &optional beg end ¶

该命令插入文件file的内容，按照format格式进行转换。如果 `beg` 和 `end` 不是 `nil` ，它们指定要读取文件的哪个部分，如 `insert-file-contents` （请参阅从文件中读取）。

返回值类似于 `insert-file-contents` 返回的内容：绝对文件名和插入数据长度的列表（转换后）。

参数格式是格式名称的列表。如果 `format` 为 `nil` ，则不进行转换。交互地，只输入 `RET` 作为格式指定 `nil` 。

    Variable: buffer-auto-save-file-format ¶

此变量指定用于自动保存的格式。它的值是格式名称的列表，就像 `buffer-file-format` 的值一样；但是，它被用来代替缓冲区文件格式来编写自动保存文件。如果值为 `t` ，则默认自动保存使用与在同一缓冲区中的常规保存相同的格式。此变量在所有缓冲区中始终是缓冲区本地的。


<a id="org7321f1c"></a>

### 26.13.3 零碎规格

与上一小节中描述的往返规范（参见往返规范）相比，您可以使用变量 `after-insert-file-functions` 和 `write-region-annotate-functions` 分别控制各自的读写转换.

转换从一种表示开始并产生另一种表示。当只有一次转换要做时，从什么开始就不会有冲突。但是，当涉及到多个转换时，当两个转换需要从相同的数据开始时可能会出现冲突。

在写入区域期间转换文本属性的上下文中可以最好地理解这种情况。例如，缓冲区中位置 `42` 处的字符是具有文本属性 `foo` 的 `X` 。如果 `foo` 的转换是通过插入缓冲区来完成的，比如 `FOO:` ，那么这会将位置 `42` 处的字符从 `X` 更改为 `F` 。下一次转换将立即从错误的数据开始。

为避免冲突，协同转换不会修改缓冲区，而是指定注释，即表单的元素列表（位置.字符串），按位置递增的顺序排序。

如果有多个转换，write-region 会破坏性地将它们的注释合并到一个排序列表中。稍后，当缓冲区中的文本实际写入文件时，它会在相应位置混合指定的注释。所有这些都发生在不修改缓冲区的情况下。

相反，在阅读时，与文本混合的注释会立即处理。insert-file-contents 设置指向要转换的某些文本的开头，然后使用该文本的长度调用转换函数。这些函数应始终在插入文本的开头返回点。这种方法对阅读很有意义，因为第一个转换器删除的注释不会被后面的转换器错误地处理。每个转换函数都应该扫描它识别的注释，删除注释，修改缓冲区文本（例如设置文本属性），并返回文本的更新长度，因为它在这些更改之后保持不变。一个函数返回的值成为下一个函数的参数。

    Variable: write-region-annotate-functions ¶

write-region 要调用的函数列表。列表中的每个函数都使用两个参数调用：要写入的区域的开始和结束。这些函数不应该改变缓冲区的内容。相反，它们应该返回注释。

作为一种特殊情况，函数可能会以不同的缓冲电流返回。Emacs 认为这意味着当前缓冲区包含要输出的已更改文本。因此，它更改了 `write-region` 调用的开始和结束参数，分别为它们提供了新缓冲区中的 `point-min` 和 `point-max` 的值。它还丢弃所有以前的注释，因为它们应该由这个函数处理。

    Variable: write-region-post-annotation-function ¶

这个变量的值，如果非零，应该是一个函数。在 `write-region` 完成后调用此函数，不带参数。

如果 `write-region-annotate-functions` 中的任何函数返回不同的缓冲区电流，Emacs 会多次调用 `write-region-post-annotation-function` 。Emacs 使用当前的最后一个缓冲区调用它，然后再次使用之前的缓冲区调用它，以此类推回到原始缓冲区。

因此，write-region-annotate-functions 中的函数可以创建一个缓冲区，为该变量赋予该缓冲区中 `kill-buffer` 的本地值，使用更改的文本设置缓冲区，并使缓冲区成为当前缓冲区。缓冲区将在写入区域完成后被杀死。

    Variable: after-insert-file-functions ¶

此列表中的每个函数都由 `insert-file-contents` 调用，其参数为插入的字符数，点位于插入文本的开头。每个函数都应保持 `point` 不变，并返回描述插入文本的新字符数，该字符数由函数修改。

我们邀请用户编写 `Lisp` 程序来存储和检索文件中的文本属性，使用这些钩子，从而尝试各种数据格式并找到好的格式。最终，我们希望用户能够生成可以安装在 `Emacs` 中的良好、通用的扩展。

我们建议不要尝试将任意 `Lisp` 对象作为文本属性名称或值来处理——因为一般的程序可能很难编写，而且速度很慢。相反，选择一组相当灵活且不太难编码的可能数据类型。

