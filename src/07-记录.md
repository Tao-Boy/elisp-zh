# 7 记录

记录的目的是允许程序员创建具有未内置于 `Emacs` 中的新类型的对象。它们被用作 `cl-defstruct` 和 `defclass` 实例的底层表示。

在内部，一个记录对象很像一个向量。它的插槽可以使用 `aref` 访问，并且可以使用复制序列进行复制。但是，第一个槽用于保存由 `type-of` 返回的类型。此外，在当前的实现中，记录最多可以有 `4096` 个插槽，而向量可以大得多。像数组一样，记录使用零源索引：第一个槽的索引为 `0` 。

类型槽应该是符号或类型描述符。如果是类型描述符，则返回命名其类型的符号；类型描述符。任何其他类型的对象都按原样返回。

记录的打印表示是 `#s` ，后跟指定内容的列表。第一个列表元素必须是记录类型。以下元素是记录槽。

为避免与其他类型名称冲突，定义新记录类型的 `Lisp` 程序通常应使用为类型名称引入这些记录类型的包的命名约定。请注意，在加载定义记录类型的包时，可能不知道可能发生冲突的类型的名称；它们可以在未来的某个时间点加载。

记录被认为是评估的常数：评估它的结果是相同的记录。这不会评估甚至检查插槽。请参阅自我评估表。


<a id="org8991534"></a>

## 7.1 记录功能

    Function: recordp object

如果 `object` 是记录，则此函数返回 `t` 。

    (recordp #s(a))
         ⇒ t

    Function: record type &rest objects

这个函数创建并返回一个类型为类型的记录，剩余的槽是其余的参数，对象。

    (record 'foo 23 [bar baz] "rats")
         ⇒ #s(foo 23 [bar baz] "rats")

    Function: make-record type length object

这个函数返回一个新的记录类型类型和长度更多的槽，每个都初始化为对象。

    (setq sleepy (make-record 'foo 9 'Z))
         ⇒ #s(foo Z Z Z Z Z Z Z Z Z)


<a id="org9ecf2c2"></a>

## 7.2 向后兼容性

使用旧版本的不使用记录的 `cl-defstruct` 编译的代码在新 `Emacs` 中使用时可能会遇到问题。为了缓解这种情况，Emacs 会检测何时使用旧的 `cl-defstruct` ，并启用一种模式，在该模式中 `type-of` 处理旧的结构对象，就好像它们是记录一样。

    Function: cl-old-struct-compat-mode arg

如果 `arg` 为正，则启用与旧式结构的向后兼容性。

