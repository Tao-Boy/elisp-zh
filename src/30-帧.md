
# 30 帧

帧是包含一个或多个 `Emacs` 窗口的屏幕对象（请参阅 `Windows` ）。它是一种在图形环境术语中称为 `窗口` 的对象；但我们不能在这里称它为 `窗口` ，因为 `Emacs` 以不同的方式使用这个词。在 `Emacs Lisp` 中，一个帧对象是一个 `Lisp` 对象，它表示屏幕上的一个帧。请参见帧类型。

一帧最初包含一个主窗口和/或一个小缓冲区窗口；您可以将主窗口垂直或水平细分为较小的窗口。请参阅拆分窗口。

终端是能够显示一个或多个 `Emacs` 帧的显示设备。在 `Emacs Lisp` 中，终端对象是表示终端的 `Lisp` 对象。请参阅终端类型。

有两类终端：文本终端和图形终端。文本终端是不支持图形的显示器，包括 `xterm` 和其他终端仿真器。在文本终端上，每个 `Emacs` 帧占据终端的整个屏幕；尽管您可以创建额外的帧并在它们之间切换，但终端一次只显示一帧。另一方面，图形终端由图形显示系统管理，例如 `X Window System` ，它允许 `Emacs` 在同一显示器上同时显示多个帧。

在 `GNU` 和 `Unix` 系统上，无论 `Emacs` 是在文本终端还是图形终端上启动，您都可以在单个 `Emacs` 会话中在任何可用终端上创建额外的帧。Emacs 可以同时显示在图形和文本终端上。例如，当您从多个远程位置连接到同一个会话时，这会派上用场。请参阅多个终端。

    Function: framep object ¶

如果 `object` 是一个帧，则此谓词返回一个非 `nil`  值，否则返回 `nil` 。对于一个帧，该值指示该帧使用哪种显示方式：

    t

帧显示在文本终端上。

    x

帧显示在 `X` 图形终端上。

    w32

帧显示在 `MS-Windows` 图形终端上。

    ns

帧显示在 `GNUstep` 或 `Macintosh Cocoa` 图形终端上。

    pc

该帧显示在 `MS-DOS` 终端上。

    Function: frame-terminal &optional frame ¶

该函数返回显示帧的终端对象。如果 `frame` 为 `nil`  或未指定，则默认为选定的帧。

    Function: terminal-live-p object ¶

如果 `object` 是活动的终端（即未删除），则此谓词返回非 `nil`  值，否则返回 `nil` 。对于直播终端，返回值表示在该终端上显示什么样的帧；可能值的列表与上面的 `framep` 相同。

在图形终端上，我们区分两种类型的帧： `普` 通的顶级帧是其窗口系统窗口是该终端的窗口系统根窗口的子窗口的帧。子帧是一个帧，其窗口系统窗口是另一个 `Emacs` 帧的窗口系统窗口的子窗口。请参阅子帧。


<a id="orgf011e51"></a>

## 30.1 创建帧

要创建一个新帧，请调用函数 `make-frame` 。

    Command: make-frame &optional parameters ¶

此函数创建并返回一个新帧，显示当前缓冲区。

parameters 参数是一个列表，它为新帧指定帧参数。请参见帧参数。如果您在参数中指定终端参数，则会在该终端上创建新帧。否则，如果您在参数中指定窗口系统帧参数，则确定帧应显示在文本终端还是图形终端上。请参阅窗系统。如果两者都没有指定，则在与选定帧相同的终端中创建新帧。

参数中未提及的任何参数默认为 `alist default-frame-alist` 中的值（参见初始帧参数）；此处未指定的参数默认来自 `X` 资源或操作系统上的等效资源（请参阅 `GNU Emacs` 手册中的 `X` 资源）。创建帧后，此函数应用在 `frame-inherited-parameters` 中指定的任何参数（见下文），它尚未分配，从调用 `make-frame` 时选择的帧中获取值。

请注意，在多显示器显示器（请参阅多个终端）上，窗口管理器可能会以不同于参数中位置参数指定的方式定位帧（请参阅位置参数）。例如，一些窗口管理器的策略是在包含窗口最大部分的监视器上显示帧（也称为主监视器）。

此函数本身不会使新帧成为选定帧。请参阅输入焦点。先前选择的帧保持选中状态。然而，在图形终端上，窗口系统可能会出于自己的原因选择新帧。

    Variable: before-make-frame-hook ¶

在创建帧之前由 `make-frame` 运行的普通钩子。

    Variable: after-make-frame-functions ¶

make-frame 创建帧后运行的异常钩子。after-make-frame-functions 中的每个函数都接收一个参数，即刚刚创建的帧。

请注意，由初始文件添加到这些钩子的任何函数通常不会针对初始帧运行，因为 `Emacs` 仅在创建该帧后才会读取初始文件。但是，如果初始帧被指定为使用单独的 `minibuffer` 帧（请参阅 `Minibuffers` 和 `Frames` ），则函数将为无 `minibuffer-less` 和 `minibuffer` 帧运行。

    Variable: frame-inherited-parameters ¶

此变量指定新创建的帧从当前选定的帧继承的帧参数列表。对于作为此列表中的元素且在处理构建帧时之前未分配的每个参数（符号），该函数将创建的帧中该参数的值设置为其在选定帧中的值。

    User Option: server-after-make-frame-hook ¶

当 `Emacs` 服务器创建一个客户端帧时，一个正常的钩子运行。当这个钩子被调用时，创建的帧是被选中的。请参阅 `GNU Emacs` 手册中的 `Emacs` 服务器。


<a id="org1264715"></a>

## 30.2 多终端

Emacs 将每个终端表示为终端对象数据类型（请参阅终端类型）。在 `GNU` 和 `Unix` 系统上，Emacs 可以在每个会话中同时使用多个终端。在其他系统上，它只能使用一个终端。每个终端对象具有以下属性：

-   终端使用的设备名称（例如，':0.0' 或 `/dev/tty` ）。
-   终端上使用的终端和键盘编码系统。请参阅终端 `I/O` 编码。
-   与终端关联的显示类型。这是函数 `terminal-live-p` （即 `x` 、t、w32、ns 或 `pc` ）返回的符号。请参阅帧。
-   终端参数列表。请参阅终端参数。

没有用于创建终端对象的原语。Emacs 根据需要创建它们，例如当您调用 `make-frame-on-display` 时（如下所述）。

    Function: terminal-name &optional terminal ¶

该函数返回终端使用的设备的文件名。如果终端被省略或为零，则默认为所选帧的终端。终端也可以是一个帧，表示该帧的终端。

    Function: terminal-list ¶

此函数返回所有活动终端对象的列表。

    Function: get-device-terminal device ¶

此函数返回一个终端，其设备名称由 `device` 给出。如果 `device` 是字符串，它可以是终端设备的文件名，也可以是 `host:server.screen` 形式的 `X` 显示器的名称。如果设备是一个帧，这个函数返回那个帧的终端； `nil` ~ 表示选中的帧。最后，如果 `device` 是一个表示活动终端的终端对象，则返回该终端。如果函数的参数不是上述任何一个，则该函数会发出错误信号。

    Function: delete-terminal &optional terminal force ¶

此函数删除终端上的所有帧并释放它使用的资源。它运行异常钩子 `delete-terminal-functions` ，将终端作为参数传递给每个函数。

如果终端被省略或为零，则默认为所选帧的终端。终端也可以是一个帧，表示该帧的终端。

通常，如果您尝试删除唯一的活动终端，此函数会发出错误信号，但如果 `force` 不为零，则允许您这样做。当终端上的最后一帧被删除时，Emacs 会自动调用这个函数（参见删除帧）。

    Variable: delete-terminal-functions ¶

删除终端运行的异常钩子。每个函数接收一个参数，即传递给 `delete-terminal` 的终端参数。由于技术细节，这些函数可以在终端被删除之前或之后被调用。

一些 `Lisp` 变量是终端本地的；也就是说，它们对每个终端都有单独的绑定。任何时候生效的绑定都是针对当前选择的帧所属的终端的绑定。这些变量包括 `default-minibuffer-frame` 、defining-kbd-macro、last-kbd-macro 和 `system-key-alist` 。它们始终是终端本地的，并且永远不能是缓冲区本地的（请参阅缓冲区本地变量）。

在 `GNU` 和 `Unix` 系统上，每个 `X` 显示器都是一个单独的图形终端。当 `Emacs` 从 `X` 窗口系统中启动时，它使用由 `DISPLAY` 环境变量或 `--display` 选项指定的 `X` 显示（参见 `GNU Emacs` 手册中的初始选项）。Emacs 可以通过命令 `make-frame-on-display` 连接到其他 `X` 显示器。每个 `X` 显示器都有自己的选定帧和自己的 `minibuffer` 窗口；但是，在任何给定时刻，只有这些帧中的一个是选定的帧（请参阅输入焦点）。通过与 `emacsclient` 程序交互，Emacs 甚至可以连接到其他文本终端。请参阅 `GNU Emacs` 手册中的 `Emacs` 服务器。

单个 `X` 服务器可以处理多个显示。每个 `X` 显示器都有一个由三部分组成的名称，'hostname:displaynumber.screennumber'。第一部分，主机名，指定显示器物理连接的机器的名称。第二部分 `displaynumber` 是一个从零开始的数字，用于标识连接到该机器的一个或多个监视器，这些监视器共享一个公共键盘和指点设备（鼠标、平板电脑等）。第三部分 `screennumber` 标识从零开始的屏幕编号（一个单独的监视器），它是该 `X` 服务器上单个监视器集合的一部分。当您使用属于一个服务器的两个或多个屏幕时，Emacs 通过名称的相似性知道它们共享一个键盘。

不使用 `X` 窗口系统的系统，例如 `MS-Windows` ，不支持 `X` 显示器的概念，并且每台主机上只有一个显示器。这些系统上的显示名称不遵循上述 `3` 部分格式；例如，MS-Windows 系统上的显示名称是一个常量字符串 `'w32'` ，并且为了兼容性而存在，因此您可以将它传递给需要显示名称的函数。

    Command: make-frame-on-display display &optional parameters ¶

此函数在显示时创建并返回一个新帧，并从 `alist` 参数中获取其他帧参数。display 应该是 `X` 显示的名称（字符串）。

在创建帧之前，该函数确保 `Emacs` 设置为显示图形。例如，如果 `Emacs` 没有处理 `X` 资源（例如，如果它是在文本终端上启动的），那么此时它会处理。在所有其他方面，此函数的行为类似于 `make-frame` （请参阅创建帧）。

    Function: x-display-list ¶

此函数返回一个列表，指示 `Emacs` 连接到的 `X` 显示器。列表的元素是字符串，每一个都是一个显示名称。

    Function: x-open-connection display &optional xrm-string must-succeed ¶

此函数打开到 `X` 显示显示的连接，而不在该显示上创建帧。通常，Emacs Lisp 程序不需要调用这个函数，因为 `make-frame-on-display` 会自动调用它。调用它的唯一原因是检查是否可以与给定的 `X` 显示器建立通信。

可选参数 `xrm-string` （如果不是 `nil` ）是资源名称和值的字符串，其格式与 `.Xresources` 文件中使用的格式相同。请参阅 `GNU Emacs` 手册中的 `X` 资源。这些值适用于在此显示上创建的所有 `Emacs` 帧，覆盖 `X` 服务器中记录的资源值。以下是此字符串的示例：

    "*BorderWidth: 3\n*InternalBorder: 2\n"

如果 `must-succeed` 不为零，则无法打开连接会终止 `Emacs` 。否则，这是一个普通的 `Lisp` 错误。

    Function: x-close-connection display ¶

此函数关闭连接以显示显示。在执行此操作之前，您必须先删除在该显示器上打开的所有帧（请参阅删除帧）。

在某些多显示器设置中，单个 `X` 显示器输出到多个物理显示器。您可以使用函数 `display-monitor-attributes-list` 和 `frame-monitor-attributes` 来获取有关此类设置的信息。

    Function: display-monitor-attributes-list &optional display ¶

该函数返回显示的物理监视器属性列表，可以是显示名称（字符串）、终端或帧；如果省略或为零，则默认为所选帧的显示。列表的每个元素都是一个关联列表，表示物理监视器的属性。第一个元素对应于主监视器。属性键和值是：

    ‘geometry’

显示器屏幕左上角的位置及其大小（以像素为单位），如 `（xy 宽度高度）` 。请注意，如果监视器不是主监视器，则某些坐标可能为负数。

    ‘workarea’

左上角的位置和工作区域（可用空间）的大小（以像素为单位）为 `（xy 宽度高度）` 。这可能与 `几何` 不同，因为各种窗口管理器功能（停靠栏、任务栏等）占用的空间可能会被排除在工作区之外。这些功能是否实际上从工作区域中减去取决于平台和环境。同样，如果监视器不是主监视器，则某些坐标可能是负数。

    ‘mm-size’

以毫米为单位的宽度和高度为 `（宽度高度` ）

    ‘frames’

此物理监视器控制的帧列表（见下文）。

    ‘name’

物理监视器的名称为字符串。

    ‘source’

多显示器信息的来源为字符串；例如， `XRandr` 或 `Xinerama` 。

x、y、宽度和高度是整数。 `名称` 和 `来源` 可能不存在。

当帧的最大区域位于该监视器中时，或者（如果该帧不与任何物理监视器相交）该监视器最接近该帧，则该帧由该物理监视器支配。图形显示中的每个（非工具提示）帧（无论是否可见）一次仅由一个物理监视器控制，尽管该帧可以跨越多个（或没有）物理监视器。

以下是此函数在 `2` 监视器显示屏上生成的数据示例：

    (display-monitor-attributes-list)
    ⇒
    (((geometry 0 0 1920 1080) ;; Left-hand, primary monitor
      (workarea 0 0 1920 1050) ;; A taskbar occupies some of the height
      (mm-size 677 381)
      (name . "DISPLAY1")
      (frames #<frame emacs@host *Messages* 0x11578c0>
    	  #<frame emacs@host *scratch* 0x114b838>))
     ((geometry 1920 0 1680 1050) ;; Right-hand monitor
      (workarea 1920 0 1680 1050) ;; Whole screen can be used
      (mm-size 593 370)
      (name . "DISPLAY2")
      (frames)))

    Function: frame-monitor-attributes &optional frame ¶

此函数返回物理监视器支配（见上文）帧的属性，默认为选定的帧。

在多显示器显示器上，可以使用命令 `make-frame-on-monitor` 在指定的显示器上制作帧。

    Command: make-frame-on-monitor monitor &optional display parameters ¶

此函数在显示器上的监视器上创建并返回一个新帧，并从 `alist` 参数中获取其他帧参数。monitor 应该是物理监视器的名称，与属性名称中函数 `display-monitor-attributes-list` 返回的字符串相同。display 应该是 `X` 显示的名称（字符串）。


<a id="org3561fe0"></a>

## 30.3 帧几何

帧的几何形状取决于用于构建此 `Emacs` 实例的工具包和显示帧的终端。本章描述了这些依赖关系以及处理它们的一些函数。请注意，所有这些函数的 `frame` 参数都必须指定一个实时帧（请参阅删除帧）。如果省略或为零，它指定选定的帧（请参阅输入焦点）。


<a id="orge526303"></a>

### 30.3.1 帧布局

可见帧在其终端显示器上占据一个矩形区域。该区域可能包含许多嵌套的矩形，每个矩形都有不同的用途。下图描绘了图形终端上帧的布局：

    	<------------ Outer Frame Width ----------->
    	____________________________________________
         ^(0)  ________ External/Outer Border _______   |
         | |  |_____________ Title Bar ______________|  |
         | | (1)_____________ Menu Bar ______________|  | ^
         | | (2)_____________ Tool Bar ______________|  | ^
         | | (3)_____________ Tab Bar _______________|  | ^
         | |  |  _________ Internal Border ________  |  | ^
         | |  | |   ^                              | |  | |
         | |  | |   |                              | |  | |
    Outer  |  | | Inner                            | |  | Native
    Frame  |  | | Frame                            | |  | Frame
    Height |  | | Height                           | |  | Height
         | |  | |   |                              | |  | |
         | |  | |<--+--- Inner Frame Width ------->| |  | |
         | |  | |   |                              | |  | |
         | |  | |___v______________________________| |  | |
         | |  |___________ Internal Border __________|  | v
         v |___________ External/Outer Border __________|
    	   <-------- Native Frame Width -------->

实际上，并非图中所示的所有区域都将或可能存在。这些区域的含义如下所述。

外框¶

外框是一个矩形，包括图中所示的所有区域。该矩形的边缘称为帧的外边缘。帧的外部宽度和外部高度一起指定了该矩形的外部大小。

了解帧的外部尺寸对于将帧装入其显示器的工作区域（请参阅多个终端）或将两个帧彼此相邻放置在屏幕上很有用。通常，帧的外部尺寸只有在帧至少被映射一次后才可用（使其可见，请参阅帧的可见性）。对于初始帧或尚未创建的帧，外部大小只能估计或必须根据窗口系统或窗口管理器的默认值计算。一种解决方法是获取映射帧的外部和本机（见下文）大小的差异，并使用它们来计算新帧的外部大小。

外框左上角的位置（上图中用'(0)'表示）就是外框的位置。图形帧的外部位置也称为帧的 `位置` ，因为无论何时调整帧大小或更改其布局，它通常在其显示上保持不变。

    外部位置由左侧和顶部帧参数指定并可通过其设置（请参阅位置参数）。对于普通的顶级帧，这些参数通常表示其相对于其显示原点的绝对位置（见下文）。对于子帧（请参阅子帧），这些参数表示其相对于其父帧的原始位置（见下文）的位置。对于文本终端上的帧，这些参数的值是无意义的并且始终为零。
外部边框¶

外部边框是窗口管理器提供的装饰的一部分。它通常用于使用鼠标调整帧的大小，因此不会在 `fullboth` 和最大化的帧上显示（请参阅大小参数）。它的宽度由窗口管理器决定，不能被 `Emacs` 的函数改变。

    文本终端帧上不存在外部边框。对于图形帧，可以通过设置 `override-redirect` 或 `undecorated frame` 参数来抑制它们的显示（请参阅窗口管理参数）。
外边界¶

外边框是一个单独的边框，其宽度可以使用border-width frame 参数指定（请参阅布局参数）。在实践中，帧的外部或外部边界都会显示，但不会同时显示。通常，外边框仅显示为不（完全）由窗口管理器控制的特殊帧，如工具提示帧（参见工具提示）、子帧（参见子帧）和未装饰或覆盖重定向帧（参见窗口管理参数） ~.

   ~ 外部边框永远不会显示在文本终端帧和由 `GTK+` 例程生成的帧上。在 `MS-Windows` 上，外部边框是在一个像素宽的外部边框的帮助下模拟的。基于 `X` 的非工具包构建允许通过设置边框颜色帧参数来更改外边框的颜色（请参阅布局参数）。
标题栏 ~¶

   ~ 标题栏，又称标题栏，也是窗口管理器装饰的一部分，通常显示帧的标题（请参阅帧标题）以及用于最小化、最大化和删除帧的按钮。它也可以用于用鼠标拖动帧。标题栏通常不会为 `fullboth` （请参阅大小参数）、工具提示（请参阅工具提示）和子帧（请参阅子帧）显示，并且对于终端帧也不存在。可以通过设置覆盖重定向或未修饰的帧参数来抑制标题栏的显示（请参阅窗口管理参数）。
菜单栏 ~¶

~ 菜单栏（请参阅菜单栏）可以是内部的（由 `Emacs` 自己绘制）或外部的（由工具包绘制）。大多数构建（GTK+、Lucid、Motif 和 `MS-Windows` ）依赖于外部菜单栏。NS 也使用一个外部菜单栏，但是，它不是外部帧的一部分。非工具包构建可以提供内部菜单栏。在文本终端帧上，菜单栏是帧根窗口的一部分（请参阅 `Windows` 和帧）。通常，菜单栏永远不会显示在子帧上（请参阅子帧）。可以通过将 `menu-bar-lines` 参数（请参阅布局参数）设置为零来抑制菜单栏的显示。

    每当菜单栏的宽度变得太大而无法容纳在其帧上时，菜单栏是被包裹还是被截断取决于工具包。通常，只有 `Motif` 和 `MS-Windows` 版本可以包装菜单栏。当他们（展开）菜单栏时，他们试图保持帧的外部高度不变，因此帧的本机高度（见下文）将会改变。
工具栏¶

与菜单栏一样，工具栏（请参阅工具栏）可以是内部的（由 `Emacs` 本身绘制）或外部的（由工具包绘制）。GTK+ 和 `NS` 构建具有由工具包绘制的工具栏。其余构建使用内部工具栏。使用 `GTK+` ，工具栏可以位于帧的任一侧，紧靠内部边界之外，见下文。子帧通常不显示工具栏（请参阅子帧）。可以通过将 `tool-bar-lines` 参数（请参阅布局参数）设置为零来抑制工具栏的显示。

    如果变量 `auto-resize-tool-bars` 不为 `nil` ，Emacs 会在内部工具栏的宽度变得对其帧来说太大时包装内部工具栏。如果当 `Emacs (un-)` 包裹内部工具栏时，它默认保持帧的外部高度不变，因此帧的原生高度（见下文）将会改变。另一方面，使用 `GTK+` 构建的 `Emacs` 从不包裹工具栏，但可能会自动增加帧的外部宽度以适应过长的工具栏。
标签栏¶

    标签栏（参见 `GNU Emacs` 手册中的标签栏）总是由 `Emacs` 自己绘制。标签栏出现在使用内部工具栏构建的 `Emacs` 工具栏上方，而在使用外部工具栏构建的 `Emacs` 工具栏下方。可以通过将 `tab-bar-lines` 参数（请参阅布局参数）设置为零来抑制标签栏的显示。
原生帧¶

本机帧是完全位于外帧内的矩形。它不包括由外部或外部边框、标题栏和任何外部菜单或工具栏占据的区域。本机帧的边缘称为帧的本机边缘。帧的原生宽度和原生高度一起指定了帧的原生大小。

帧的原生大小是 `Emacs` 在 `Emacs` 中创建或调整帧大小时传递给窗口系统或窗口管理器的大小。它也是 `Emacs` 在调整帧的窗口系统窗口大小时从窗口系统或窗口管理器接收到的大小，例如，在通过单击标题栏中的相应按钮来最大化帧之后，或者在使用老鼠。

原生帧左上角的位置指定了帧的原生位置。上图中的 `(1)` –(3) 表示各种构建的位置：

(1) 非工具包和终端帧
(2) Lucid、Motif 和 `MS-Windows` 帧
(3) GTK+ 和 `NS` 帧

因此，帧的原始高度可能包括工具栏的高度，但不包括菜单栏的高度（Lucid、Motif、MS-Windows）或菜单栏和工具栏的高度（非工具包和文本终端帧） `）` 。

帧的原始位置是设置或返回鼠标当前位置的函数（请参阅鼠标位置）和处理窗口位置的函数（如窗口边缘、窗口位置或窗口坐标）的参考位置-p（参见坐标和窗口）。它还指定了 `(0, 0)` 原点，用于在此帧内定位和定位子帧（请参阅子帧）。

    另请注意，通过更改帧的覆盖重定向或未装饰参数（请参阅窗口管理参数）来删除或添加窗口管理器装饰时，帧的本机位置通常在其显示上保持不变。
内部边框

内部边框是 `Emacs` 围绕内部帧绘制的边框（见下文）。其外观规范取决于给定帧是否为子帧（请参阅子帧）。

对于普通帧，其宽度由 `internal-border-width` 帧参数指定（请参阅布局参数），其颜色由内部边框面的背景指定。

    对于子帧，其宽度由 `child-frame-border-width` 帧参数指定（但将使用 `internal-border-width` 参数作为后备），其颜色由 `child-frame-border` 面的背景指定。
内框¶

内部帧是为帧窗口保留的矩形。它被内部边框包围，但是，它不是内部帧的一部分。它的边缘称为帧的内边缘。内部宽度和内部高度指定矩形的内部大小。内框有时也称为框的显示区域。

    通常，内部帧被细分为帧的根窗口（参见 `Windows` 和帧）和帧的 `minibuffer` 窗口（参见 `Minibuffer Windows` ）。此规则有两个值得注意的例外： `无 minibuffer` 帧仅包含根窗口，不包含 `minibuffer` 窗口。minibuffer-only 帧仅包含一个 `minibuffer` 窗口，该窗口也用作该帧的根窗口。有关如何创建此类帧配置的信息，请参阅初始帧参数。
文本区¶

帧的文本区域是一个有点虚构的区域，可以嵌入到本机帧中。它的位置是未指定的。它的宽度可以通过从本机宽度的宽度中去除内部边框、一个垂直滚动条和一个左右边缘的宽度（如果为此帧指定），请参阅布局参数。它的高度可以通过从本机高度中删除内部边框的宽度以及帧的内部菜单和工具栏、标签栏和一个水平滚动条的高度（如果为此帧指定）来获得。

帧的绝对位置以相对于帧显示的原点 `(0, 0)` 的水平和垂直像素偏移对 `(X, Y)` 的形式给出。相应地，帧的绝对边缘作为从该原点的像素偏移量给出。

请注意，对于多台显示器，显示的原点不一定与终端的整个可用显示区域的左上角重合。因此，在这样的环境中，即使该帧完全可见，帧的绝对位置也可能为负值。

按照惯例，垂直偏移 `向下` 增加。这意味着帧的高度是通过从其底部边缘的偏移量中减去其顶部边缘的偏移量来获得的。正如预期的那样，水平偏移量 `向右` 增加，因此帧的宽度是通过从其右边缘的偏移量中减去其左边缘的偏移量来计算的。

对于图形终端上的帧，以下函数返回上述区域的大小：

    Function: frame-geometry &optional frame ¶

该函数返回帧的几何属性。返回值是下面列出的属性的关联列表。所有坐标、高度和宽度值都是整数，计数像素。请注意，如果尚未映射帧，（请参阅帧的可见性）某些返回值可能仅表示实际值的近似值 `-` 那些在帧映射后可以看到的值。

    outer-position

一个 `cons` 表示外部帧的绝对位置，相对于帧显示位置 `(0, 0)` 的原点。

    outer-size

帧的外部宽度和高度的缺点。

    external-border-size

窗口管理器提供的帧外部边框的水平和垂直宽度的缺点。如果窗口管理器不提供这些值，Emacs 将尝试从外框和内框的坐标中猜测它们。

    outer-border-width

帧外边框的宽度。该值仅对非 `GTK+ X` 构建有意义。

    title-bar-size

窗口管理器或操作系统提供的帧标题栏的宽度和高度的缺点。如果它们都为零，则帧没有标题栏。如果仅宽度为零，则 `Emacs` 无法检索宽度信息。

    menu-bar-external

如果非零，这意味着菜单栏是外部的（不是帧的本机帧的一部分）。

    menu-bar-size

帧菜单栏的宽度和高度的缺点。

    tool-bar-external

如果非零，这意味着工具栏是外部的（不是帧的本机帧的一部分）。

    tool-bar-position

这告诉帧上的工具栏在哪一侧，并且可以是左侧、顶部、右侧或底部之一。目前唯一支持除 `top` 之外的值的工具包是 `GTK+` 。

    tool-bar-size

帧工具栏的宽度和高度的一个缺点。

    internal-border-width

帧内部边框的宽度。

以下函数可用于检索外框、原生框和内框的边缘。

    Function: frame-edges &optional frame type ¶

此函数返回帧的外部、原生或内部帧的绝对边缘。frame 必须是实时帧，默认为选定的帧。返回的列表具有形式（左上右下），其中所有值都以相对于帧显示原点的像素为单位。对于终端帧，left 和 `top` 返回的值始终为零。

可选参数 `type` 指定要返回的边的类型：outer-edges 表示返回帧的外边，native-edges（或 `nil` ）表示返回其原生边，inner-edges 表示返回其内边。

按照惯例，左侧和顶部返回值处的显示像素被认为是在帧内（部分）。因此，如果 `left` 和 `top` 都为零，则显示原点的像素是帧的一部分。另一方面，底部和右侧的像素被认为位于帧外。这意味着，例如，如果您有两个并排的帧，使左侧帧的右外边缘等于右侧帧的左外边缘，则该边缘的像素显示一部分右边的帧。


<a id="org62d9f10"></a>

### 30.3.2 帧字体

每个帧都有一个默认字体，它指定该帧的默认字符大小。此大小是指在检索或更改以列或行为单位的帧大小时（请参阅大小参数）。它也用于调整窗口大小（请参阅窗口大小）或拆分（请参阅拆分窗口）窗口。

有时使用术语行高和规范字符高度来代替 `默认字符高度` 。同样，使用术语列宽和规范字符宽度代替 `默认字符宽度` 。

    Function: frame-char-height &optional frame ¶

    Function: frame-char-width &optional frame ¶

这些函数返回帧中字符的默认高度和宽度，以像素为单位。这些值一起确定了帧上默认字体的大小。这些值取决于帧字体的选择，请参阅字体和颜色参数。

也可以直接使用以下函数设置默认字体：

    Command: set-frame-font font &optional keep-size frames ¶

这会将默认字体设置为字体。当以交互方式调用时，它会提示输入字体的名称，并在所选帧上使用该字体。从 `Lisp` 调用时，字体应该是字体名称（字符串）、字体对象、字体实体或字体规范。

如果可选参数 `keep-size` 为 `nil` ，这将保持帧行数和列数固定。（如果非零，下一节中描述的选项 `frame-inhibit-implied-resize` 将覆盖它。）如果 `keep-size` 非零（或带有前缀参数），它会尝试保持显示的大小通过调整行数和列数来固定当前帧的区域。

如果可选参数 `frames` 为 `nil` ，则仅将字体应用于选定的帧。如果 `frames` 不为零，则它应该是要作用的帧列表，或者 `t` 表示所有现有和所有未来的图形帧。


<a id="orge56b729"></a>

### 30.3.3 帧位置

在图形系统上，普通顶层帧的位置被指定为其外帧的绝对位置（参见帧几何）。子帧的位置（参见子帧）是通过其外边缘相对于其父帧的原始位置的像素偏移量来指定的。

您可以使用左侧和顶部的帧参数访问或更改帧的位置（请参阅位置参数）。这是用于处理现有可见帧位置的两个附加功能。对于这两个函数，参数帧必须表示一个实时帧，并且默认为选定的帧。

    Function: frame-position &optional frame ¶

对于普通的非子帧，此函数返回其外部位置（请参阅帧布局）相对于其显示原点 `(0, 0)` 的像素坐标的 `cons` 。对于子帧（请参阅子帧），此函数返回其外部位置相对于帧父级原始位置的原点 `(0, 0)` 的像素坐标。

负值从不表示从帧的显示或父帧的右边缘或下边缘偏移。相反，它们意味着帧的外部位置在其显示的原点或其父帧的本机位置的左侧和/或上方。这通常意味着帧仅部分可见（或完全不可见）。但是，在显示器的原点与其左上角不一致的系统上，该帧可能在辅助监视器上可见。

在文本终端帧上，两个值都为零。

    Function: set-frame-position frame x y ¶

该函数将frame的外框位置设置为(x, y)。后面的参数指定像素，通常从帧显示位置 `(0, 0)` 的原点开始计数。对于子帧，它们从帧的父帧的本机位置开始计数。

负参数值将外框的右边缘从屏幕的右边缘（或父帧的原生矩形）向左定位 `-x` 像素，将底部边缘从屏幕的底部边缘向上定位 `-y` 像素（或父帧的原生矩形）。

请注意，负值不允许将帧的右边缘或下边缘精确对齐其显示或父帧的右边缘或下边缘。它们也不允许指定不在显示或父帧边缘内的位置。帧参数 `left` 和 `top` （请参阅 `Position Parameters` ）允许这样做，但仍可能无法为初始帧或新帧提供良好的结果。

此功能对文本终端帧没有影响。

    Variable: move-frame-functions ¶

这个钩子指定了当 `Emacs` 帧被窗口系统或窗口管理器移动（分配一个新位置）时运行的函数。这些函数使用一个参数运行，即移动的帧。对于子帧（请参阅子帧），仅当帧的位置相对于其父帧的位置发生变化时，函数才会运行。


<a id="org05052c2"></a>

### 30.3.4 帧大小

在 `Emacs` 中指定帧大小的规范方法是指定其文本大小——帧文本区域的宽度和高度的元组（请参阅帧布局）。它可以以像素为单位或根据帧的规范字符大小来衡量（请参阅帧字体）。

对于带有内部菜单或工具栏的帧，在实际绘制帧之前，无法准确地知道帧的原始高度。这意味着通常您不能使用本机大小来指定帧的初始大小。一旦您知道可见帧的原始大小，您就可以通过从 `frame-geometry` 的返回值中添加剩余的组件来计算其外部大小（请参阅帧布局）。但是，对于不可见的帧或尚未创建的帧，只能估计外部尺寸。这也意味着不可能计算通过屏幕右边缘或下边缘的偏移量指定的帧的精确初始位置（请参阅帧位置）。

任何帧的文本大小都可以在帧高度和宽度参数的帮助下设置和检索（请参阅大小参数）。初始帧的文本大小也可以在 `X` 样式几何规范的帮助下设置。请参阅 `GNU Emacs` 手册中的 `Emacs` 调用的命令行参数。下面我们列出了一些函数来访问和设置现有可见帧的大小，默认情况下是选定的。

    Function: frame-height &optional frame ¶

    Function: frame-width &optional frame ¶

这些函数返回帧文本区域的高度和宽度，以帧的默认字体高度和宽度为单位（请参阅帧字体）。这些函数是编写 `(frame-parameter frame 'height)` 和 `(frame-parameter frame 'width)` 的简写。

如果以像素为单位测量的帧文本区域不是其默认字体大小的倍数，则这些函数返回的值将向下舍入为完全适合文本区域的默认字体的字符数。

接下来的函数返回给定帧的本机、外部和内部帧以及文本区域（请参阅帧布局）的像素宽度和高度。对于文本终端，结果是字符而不是像素。

    Function: frame-outer-width &optional frame ¶

    Function: frame-outer-height &optional frame ¶

这些函数以像素为单位返回帧的外部宽度和高度。

    Function: frame-native-height &optional frame ¶

    Function: frame-native-width &optional frame ¶

这些函数返回帧的原始宽度和高度（以像素为单位）。

    Function: frame-inner-width &optional frame ¶

    Function: frame-inner-height &optional frame ¶

这些函数以像素为单位返回帧的内部宽度和高度。

    Function: frame-text-width &optional frame ¶

    Function: frame-text-height &optional frame ¶

这些函数以像素为单位返回帧文本区域的宽度和高度。

在支持它的窗口系统上，Emacs 默认尝试使以像素为单位测量的帧的文本大小为帧字符大小的倍数。然而，这通常意味着当拖动其外部边框时，只能以字符大小增量来调整帧的大小。它还可能会破坏真正最大化帧或使其 `全高` 或 `全宽` （请参阅​​尺寸参数）的尝试，从而在帧下方和/或右侧留下一些空白空间。在这种情况下，以下选项可能会有所帮助。

    User Option: frame-resize-pixelwise ¶

如果此选项为 `nil` （默认值），则每当调整帧大小时，通常会将帧的文本像素大小四舍五入为该帧的 `frame-char-height` 和 `frame-char-width` 的当前值的倍数。如果这是非零，则不会发生舍入，因此帧大小可以增加/减少一个像素。

设置此变量通常会导致下一次调整大小操作将相应的大小提示传递给窗口管理器。这意味着该变量只能在用户的初始文件中设置；应用程序永远不应该临时绑定它。

此选项的 `nil`  值的确切含义取决于使用的工具包。如果窗口管理器愿意处理相应的大小提示，则用鼠标拖动外部边框是按字符完成的。但是，使用未将帧大小指定为其字符大小的整数倍的参数调用 `set-frame-size` （见下文）可能会：被忽略，导致舍入 `(GTK+)` ，或被接受（Lucid、Motif、微软视窗）。

对于某些窗口管理器，您可能必须将其设置为非零，以使帧真正最大化或全屏显示。

    Function: set-frame-size frame width height &optional pixelwise ¶

此函数设置帧文本区域的大小，以帧上字符的规范高度和宽度来衡量（请参阅帧字体）。

可选参数 `pixelwise non- ~nil` ~ 表示以像素为单位测量新的宽度和高度。请注意，如果 `frame-resize-pixelwise` 为 `nil` ，如果它不将帧大小增加/减小到其字符大小的倍数，某些工具包可能会拒绝真正履行请求。

    Function: set-frame-height frame height &optional pretend pixelwise ¶

此函数将帧的文本区域调整为高度线的高度。帧中现有窗口的大小会按比例更改以适合。

如果假装是非零，那么 `Emacs` 会在帧中显示输出的高度线，但不会改变它的值以适应帧的实际高度。这仅在文本终端上有用。使用比终端实际实现的高度更小的高度可能有助于重现在较小屏幕上观察到的行为，或者如果终端在使用整个屏幕时出现故障。直接设置帧高度并不总是有效，因为可能需要知道正确的实际大小才能在文本终端上正确定位光标。

可选的第四个参数 `pixelwise non- ~nil` ~ 表示帧的高度应该是像素高。请注意，如果 `frame-resize-pixelwise` 为 `nil` ，如果它不将帧高度增加/减少到其字符高度的倍数，某些窗口管理器可能会拒绝真正履行请求。

当交互使用时，此命令将询问用户设置当前所选帧高度的行数。您还可以为该值提供数字前缀。

    Function: set-frame-width frame width &optional pretend pixelwise ¶

此函数设置帧文本区域的宽度，以字符为单位。参数假装与 `set-frame-height` 中的含义相同。

可选的第四个参数 `pixelwise non-nil` 意味着 `frame` 的宽度应该是像素宽。请注意，如果 `frame-resize-pixelwise` 为 `nil` ，如果某些窗口管理器没有将帧宽度增加/减少到其字符宽度的倍数，它可能会拒绝完全接受请求。

当交互使用时，此命令将询问用户列数以设置当前选定帧的宽度。您还可以为该值提供数字前缀。

这三个函数都不会使帧小于显示所有窗口及其滚动条、边缘、边距、分隔线、模式和标题行所需的大小。这与由窗口管理器触发的请求形成对比，例如，通过用鼠标拖动帧的外部边框。如有必要，此类请求始终会通过裁剪无法显示在帧右下角的部分来实现。参数 `min-width` 和 `min-height` （请参阅尺寸参数）可用于在 `Emacs` 中更改帧大小时获得类似的行为。

异常钩子窗口大小更改函数（请参阅窗口滚动和更改钩子）跟踪帧内部大小的所有更改，包括由窗口系统或窗口管理器的请求引起的更改。要排除在仅更改帧窗口的大小而不实际更改内部帧的大小时可能发生的误报，请使用以下函数。

    Function: frame-size-changed-p &optional frame ¶

自上次为 `frame` 运行 `window-size-change-functions` 以来，当 `frame` 的内部宽度或高度发生变化时，此函数返回非 `nil` 。它总是在为 `frame` 运行 `window-size-change-functions` 后立即返回 `nil` 。


<a id="orgcf0d7dd"></a>

### 30.3.5 隐含的帧大小调整

默认情况下，Emacs 尝试保持帧文本区域的行数和列数不变，例如，切换菜单或工具栏、更改其默认字体或设置任何滚动条的宽度。这意味着在这种情况下，Emacs 必须要求窗口管理器调整帧窗口的大小以适应大小变化。

有时，这种隐含的帧调整大小可能是不需要的，例如，当一个帧被最大化或全屏时（默认情况下它被关闭）。通常，用户可以使用以下选项禁用隐式调整大小：

    User Option: frame-inhibit-implied-resize ¶

如果此选项为零，则更改帧的字体、菜单栏、工具栏、内部边框、边缘或滚动条可能会调整其外部帧的大小，以保持其文本区域的列数或行数不变。如果此选项为 `t` ，则不会进行此类调整大小。

该选项的值也可以是帧参数列表。在这种情况下，对于出现在此列表中的参数的更改，将禁止隐式调整大小。此选项当前处理的参数是字体、字体后端、内部边框宽度、菜单栏线和工具栏线。

更改滚动条宽度、滚动条高度、垂直滚动条、水平滚动条、左边缘和右边缘帧参数中的任何一个都会被处理，就好像帧只包含一个实时窗口一样。这意味着，例如，如果此选项为 `nil` ，则在包含多个并排窗口的帧上删除垂直滚动条会将外部帧宽度缩小一个滚动条的宽度，如果此选项为 `t` 或列表，则保持不变包含垂直滚动条。

Lucid、Motif 和 `MS-Windows` 的默认值是 `(tab-bar-lines tool-bar-lines)` （这意味着在那里添加/删除工具或标签栏不会改变外框高度），（标签栏-lines) 在所有其他窗口系统上，包括 `GTK+` （这意味着更改上面列出的任何参数，除了 `tab-bar-lines` 可能会更改外框的大小），否则 `t` （这意味着外框大小当没有窗口系统支持时，永远不会隐式更改）。

请注意，当一个帧不足以容纳上面列出的任何参数的更改时，Emacs 可能会尝试放大帧，即使此选项为非零。

另请注意，窗口管理器在更改外部菜单或工具栏占用的行数时通常不会要求调整帧的大小。通常，当用户水平缩小帧时会发生这种 `环绕` ，从而无法显示其菜单或工具栏的所有元素。它们也可能是由于主模式的改变改变了菜单或工具栏的项目数。任何此类换行都可能隐式更改帧文本区域的行数，并且不受此选项设置的影响。


<a id="org4b7391f"></a>

## 30.4 帧参数

帧有许多控制其外观和行为的参数。帧具有哪些参数取决于它使用的显示机制。

帧参数的存在主要是为了图形显示。大多数帧参数在应用于文本终端上的帧时无效；只有 `height` 、width、name、title、menu-bar-lines、buffer-list 和 `buffer-predicate` 参数有特殊作用。如果终端支持颜色，参数foreground-color、background-color、background-mode和display-type也是有意义的。如果终端支持帧透明，参数alpha也是有意义的。

默认情况下，当变量 `desktop-restore-frames` 不为零时，帧参数由桌面库函数保存和恢复（请参阅桌面保存模式）。应用程序有责任将它们的参数包含在 `frameset-persistent-filter-alist` 中，以避免它们在恢复的会话中获得无意义甚至有害的值。


<a id="org81bf44e"></a>

### 30.4.1 访问帧参数

这些函数使您可以读取和更改帧的参数值。

    Function: frame-parameter frame parameter ¶

该函数返回frame的参数parameter（一个符号）的值。如果 `frame` 为 `nil` ，则返回所选帧的参数。如果 `frame` 没有设置参数，则此函数返回 `nil` 。

    Function: frame-parameters &optional frame ¶

函数 `frame-parameters` 返回一个列表，列出 `frame` 的所有参数及其值。如果 `frame` 为 `nil`  或省略，则返回所选帧的参数

    Function: modify-frame-parameters frame alist ¶

此函数根据 `alist` 的元素更改帧帧。alist 的每个元素都具有 `(parm . value)` 形式，其中 `parm` 是命名参数的符号。如果 `alist` 中没有提及参数，则其值不会改变。如果 `frame` 为 `nil` ，则默认为选定的帧。

某些参数仅对特定类型显示器上的帧有意义（请参阅帧）。如果 `alist` 包含对帧的显示没有意义的参数，则此函数将更改其在帧参数列表中的值，否则将忽略它。

当 `alist` 指定多个参数的值会影响新的帧大小时，帧的最终大小可能会根据使用的工具包而有所不同。例如，指定一个帧从现在开始应该有一个菜单和/或工具栏而不是没有，同时指定帧的新高度将不可避免地导致重新计算帧的高度。从概念上讲，在这种情况下，此函数将尝试使显式高度规范占上风。但是，不能排除菜单或工具栏的添加（或删除）最终由工具包执行时会破坏此意图。

有时，将 `frame-inhibit-implied-resize` （请参阅 `Implied Frame Resizing` ）绑定到调用此函数的非零值可能会解决此处描述的问题。然而，有时，正是这样的绑定可能会受到问题的影响。

    Function: set-frame-parameter frame parm value ¶

此函数将帧参数 `parm` 设置为指定值。如果 `frame` 为 `nil` ，则默认为选定的帧。

    Function: modify-all-frames-parameters alist ¶

此函数根据 `alist` 更改所有现有帧的帧参数，然后修改 `default-frame-alist` （以及，如果需要，initial-frame-alist）以将相同的参数值应用于以后创建的帧。


<a id="orgf8a6933"></a>

### 30.4.2 初始帧参数

您可以通过在初始化文件中设置 `initial-frame-alist` 来指定初始启动帧的参数（请参阅初始化文件）。

    User Option: initial-frame-alist ¶

此变量的值是创建初始帧时使用的参数值列表。您可以设置此变量来指定初始帧的外观，而无需更改后续帧。每个元素具有以下形式：

    (parameter . value)

Emacs 在读取您的 `init` 文件之前创建初始帧。读取该文件后，Emacs 会检查 `initial-frame-alist` ，并将更改后的值中的参数设置应用于已创建的初始帧。

如果这些设置影响帧几何形状和外观，您会看到帧出现错误，然后更改为指定的。如果这让您感到困扰，您可以使用 `X` 资源指定相同的几何图形和外观；这些确实在创建帧之前生效。请参阅 `GNU Emacs` 手册中的 `X` 资源。

X 资源设置通常适用于所有帧。如果您只想为初始帧指定一些 `X` 资源，并且您不希望它们应用于后续帧，这里是如何实现的。在 `default-frame-alist` 中指定参数以覆盖后续帧的 `X` 资源；然后，为了防止这些影响初始帧，在 `initial-frame-alist` 中指定相同的参数，其值与 `X` 资源匹配。

如果这些参数包括 `(minibuffer .  ~nil` )~ ，则表明初始帧应该没有 `minibuffer` 。在这种情况下，Emacs 也会创建一个单独的 `minibuffer-only` 帧。

    User Option: minibuffer-frame-alist ¶

这个变量的值是一个参数值列表，当创建一个初始的 `minibuffer-only` 帧（即，如果 `initial-frame-alist` 指定一个没有 `minibuffer` 的帧，Emacs 创建的 `minibuffer-only` 帧）时使用的参数值列表。

    User Option: default-frame-alist ¶

这是一个列表，指定所有 `Emacs` 帧的帧参数的默认值——第一帧和后续帧。在使用 `X Window System` 时，在很多情况下可以通过 `X` 资源获得相同的结果。

设置此变量不会影响现有帧。此外，在单独的帧中显示缓冲区的函数可以通过提供自己的参数来覆盖默认参数。

如果您使用指定帧外观的命令行选项调用 `Emacs` ，这些选项会通过将元素添加到 `initial-frame-alist` 或 `default-frame-alist` 来生效。仅影响初始帧的选项，例如 `--geometry` 和 `--maximized` ，添加到initial-frame-alist；其他添加到默认帧列表。请参阅 `GNU Emacs` 手册中的 `Emacs` 调用的命令行参数。


<a id="org1643b42"></a>

### 30.4.3 窗框参数

帧具有哪些参数取决于它使用的显示机制。本节介绍在某些或所有类型的终端上具有特殊含义的参数。其中，名称、标题、高度、宽度、缓冲区列表和缓冲区谓词在终端帧中提供有意义的信息，而 `tty-color-mode` 仅对文本终端上的帧有意义。

1.  30.4.3.1 基本参数

    这些帧参数给出了关于帧的最基本信息。title 和 `name` 在所有终端上都有意义。
    
        display
    
    在其上打开此帧的显示器。它应该是 `host:dpy.screen` 形式的字符串，就像 `DISPLAY` 环境变量一样。有关显示名称的更多详细信息，请参阅多个终端。
    
        display-type
    
    这个参数描述了可以在这个帧中使用的可能颜色的范围。它的值是彩色、灰度或单色。
    
        title
    
    如果一个帧有一个非零标题，它会出现在帧顶部的窗口系统的标题栏中，如果 `mode-line-frame-identification` 使用 `'%F'` （请参阅模式行中的 `%-Constructs` ）。当 `Emacs` 不使用窗口系统并且一次只能显示一帧时，通常会出现这种情况。请参阅帧标题。
    
        name
    
    帧的名称。如果标题参数未指定或为零，则帧名称用作帧标题的默认值。如果您不指定名称，Emacs 会自动设置帧名称（请参阅帧标题）。
    
    如果您在创建帧时明确指定帧名称，则在查找帧的 `X` 资源时也会使用该名称（而不是 `Emacs` 可执行文件的名称）。
    
        explicit-name
    
    如果在创建帧时明确指定了帧名称，则此参数将是该名称。如果帧没有明确命名，则此参数将为 `nil` 。

2.  30.4.3.2 位置参数

    描述帧的 `X` 和 `Y` 偏移的参数始终以像素为单位。对于正常的非子帧，它们指定帧相对于其显示原点的外部位置（请参阅帧几何）。对于子帧（请参阅子帧），它们指定帧相对于帧父帧的本地位置的外部位置。（请注意，这些参数在 `TTY` 帧上都没有意义。）
    
        left
    
    帧的左外边缘相对于帧的显示或父帧的左边缘的位置（以像素为单位）。可以通过以下方式之一指定。
    
        an integer
    
    正整数始终将帧的左边缘与其显示或父帧的左边缘相关联。负整数将右帧边缘与显示或父帧的右边缘相关联。
    
        (+ pos)
    
    这指定了左帧边缘相对于其显示或父帧的左边缘的位置。整数 `pos` 可以是正数或负数；负值指定屏幕或父帧之外的位置，或在主显示器以外的显示器上（用于多显示器显示器）。
    
        (- pos)
    
    这指定了右帧边缘相对于显示或父帧的右边缘的位置。整数 `pos` 可以是正数或负数；负值指定屏幕或父帧之外的位置，或在主显示器以外的显示器上（用于多显示器显示器）。
    
        a floating-point value
    
    0.0 到 `1.0` 范围内的浮点值通过帧的左位置比率指定左边缘的偏移量 `-` 其外帧的左边缘与帧工作区（请参阅多个终端）或其父工作区宽度的比率原生帧（参见子帧）减去外帧的宽度。因此，左侧位置比率 `0.0` 将帧刷新到左侧，比率 `0.5` 将其居中，比率 `1.0` 将帧刷新到其显示或父帧的右侧。类似地，帧的顶部位置比率是帧的顶部位置与其工作区或父帧的高度之比减去帧的高度。
    
    如果子帧具有非零保持比率参数（请参阅帧交互参数）并且其父帧被调整大小，Emacs 将尝试保持子帧的位置比率不变。
    
    由于帧的外部尺寸（请参阅帧几何）通常在帧可见之前不可用，因此在创建装饰帧时通常不建议使用浮点值。浮点值更适合确保（未装饰的）子帧很好地定位在其父帧的区域内。
    
    一些窗口管理器会忽略程序指定的位置。如果您想确保您指定的位置不会被忽略，请为 `user-position` 参数指定一个非零值，如下例所示：
    
        (modify-frame-parameters
           ~nil~  '((user-position . t) (left . (+ -4))))
    
    通常，相对于其显示的右边缘或下边缘定位帧并不是一个好主意。定位初始帧或新帧要么不准确（因为在帧可见之前外部帧的大小尚不完全清楚），要么会导致额外的闪烁（如果帧在变得可见后必须重新定位）。
    
    另请注意，相对于显示、工作区或父帧的右/下边缘指定的位置以及浮点偏移量在内部存储为相对于显示、工作区或父帧边缘的左/上边缘的整数偏移量.  它们也由帧参数等函数返回，并由桌面保存例程恢复。
    
        top
    
    顶部（或底部）边缘的屏幕位置，以像素为单位，相对于显示或父帧的顶部（或底部）边缘。它的工作方式与左一样，除了垂直而不是水平。
    
        icon-left
    
    帧图标左边缘的屏幕位置，以像素为单位，从屏幕左边缘开始计数。如果窗口管理器支持此功能，则在帧图标化时生效。如果您为此参数指定一个值，那么您还必须为 `icon-top` 指定一个值，反之亦然。
    
        icon-top
    
    帧图标顶部边缘的屏幕位置，以像素为单位，从屏幕顶部边缘开始计数。如果窗口管理器支持此功能，则在帧图标化时生效。
    
        user-position
    
    当您创建帧并使用 `left` 和 `top` 参数指定其屏幕位置时，使用此参数来说明指定位置是用户指定的（由人类用户以某种方式明确请求）还是仅仅是程序指定的（由程序）。非零值表示该位置是用户指定的。
    
    窗口管理器通常注意用户指定的位置，有些也注意程序指定的位置。但是许多人忽略了程序指定的位置，以默认方式放置窗口或让用户用鼠标放置它。一些窗口管理器，包括 `twm` ，让用户指定是服从程序指定的位置还是忽略它们。
    
    调用 `make-frame` 时，如果 `left` 和 `top` 参数的值代表用户声明的偏好，则应该为此参数指定一个非 `nil`  值；否则，使用 `nil` 。
    
        z-group
    
    此参数指定帧的窗口系统窗口在帧显示的堆叠 `(Z-)` 顺序中的相对位置。
    
    如果高于此值，则窗口系统将在所有其他未设置上述属性的窗口系统窗口上方显示与帧对应的窗口。如果为 `nil` ，则帧的窗口显示在所有设置了上述属性的窗口下方和所有设置了以下属性的窗口上方。如果在下方，则帧的窗口将显示在所有未设置以下属性的窗口下方。
    
    要将帧定位在特定其他帧的上方或下方，请使用函数 `frame-restack` （请参阅提升、降低和重新堆叠帧）。

3.  30.4.3.3 尺寸参数

    帧参数通常以字符为单位指定帧大小。在图形显示上，默认面决定了这些字符单元的实际像素大小（请参阅面属性）。
    
        width
    
    此参数指定帧的宽度。可以通过以下方式指定：
    
        an integer
    
    一个正整数指定帧文本区域的宽度（请参阅帧几何），以字符为单位。
    
        a cons cell
    
    如果这是一个在其 `CAR` 中带有符号 `text-pixels` 的 `cons` 单元格，则该单元格的 `CDR` 指定帧文本区域的宽度（以像素为单位）。
    
        a floating-point value
    
    一个介于 `0.0` 和 `1.0` 之间的浮点数可用于通过其宽度比来指定帧的宽度——其外部宽度（请参阅帧几何）与帧工作区（请参阅多个终端）或其父级宽度的比率帧的（参见子帧）本机帧。因此，值为 `0.5` 使帧占据其工作区或父帧宽度的一半，值为 `1.0` 则为整个宽度。类似地，帧的高度比是其外部高度与其工作区或其父帧的高度之比。
    
    如果子帧具有非零保持比参数（请参阅帧交互参数）并且其父帧已调整大小，Emacs 将尝试保持子帧的宽度和高度比不变。
    
    由于在使帧可见之前通常无法获得帧的外部大小，因此在创建装饰帧时通常不建议使用浮点值。浮点值更适合确保子帧始终适合其父帧的区域，例如，当通过 `display-buffer-in` 自定义 `display-buffer-alist` （请参阅选择用于显示缓冲区的窗口）时-子帧。
    
    无论如何指定此参数，报告此参数值的函数（如 `frame-parameters` ）总是将帧文本区域的宽度（以字符为单位）报告为整数，如有必要，四舍五入为帧默认字符宽度的倍数。桌面保存例程也使用该值。
    
        height
    
    此参数指定帧的高度。它就像宽度一样工作，除了垂直而不是水平。
    
        user-size
    
    这对尺寸参数 `height` 和 `width` 的作用与用户位置参数（参见用户位置）对位置参数 `top` 和 `left` 的作用相同。
    
        min-width
    
    此参数指定帧的最小原始宽度（请参阅帧几何），以字符为单位。通常，建立帧初始宽度或水平调整帧大小的函数确保可以显示帧的所有窗口、垂直滚动条、边缘、边距和垂直分隔线。这个参数，如果非零允许使帧比那个更窄，结果是任何不适合的组件都将被窗口管理器剪裁。
    
        min-height
    
    此参数指定帧的最小原始高度（请参阅帧几何），以字符为单位。通常，建立帧的初始大小或调整帧大小的功能确保可以显示所有帧的窗口、水平滚动条和分隔线、模式和标题行、回显区域以及内部菜单和工具栏。这个参数，如果非零允许使帧小于那个，结果是任何不适合的组件都将被窗口管理器剪裁。
    
        fullscreen
    
    此参数指定是否最大化帧的宽度、高度或两者。它的值可以是 `fullwidth` 、fullheight、fullboth 或最大化。全宽帧尽可能宽，全高帧尽可能高，全宽帧尽可能宽和高。最大化的帧类似于 `fullboth` 帧，不同之处在于它通常保留其标题栏以及用于调整帧大小和关闭帧的按钮。此外，最大化的帧通常会避免隐藏桌面上显示的任何任务栏或面板。另一方面， `fullboth` 帧通常会省略标题栏并占据整个可用屏幕空间。
    
    在这方面，全高和全宽帧更类似于最大化的帧。但是，这些通常会显示一个外部边框，最大化的帧可能会缺少该边框。因此，最大化和全高帧的高度以及最大化和全宽帧的宽度通常相差几个像素。
    
    对于某些窗口管理器，您可能必须自定义变量 `frame-resize-pixelwise` （请参阅 `Frame Size` ），以使帧真正显示为最大化或全屏。此外，一些窗口管理器可能不支持各种全屏或最大化状态之间的平滑过渡。自定义变量 `x-frame-normalize-before-maximize` 可以帮助克服这个问题。
    
    macOS 上的全屏隐藏工具栏和菜单栏，但是如果将鼠标指针移动到屏幕顶部，两者都会显示。
    
        fullscreen-restore
    
    此参数指定在 `fullboth` 状态下调用 `toggle-frame-fullscreen` 命令（参见 `GNU Emacs` 手册中的帧命令）后所需的帧全屏状态。通常，当将状态切换为 `fullboth` 时，该命令会自动安装此参数。但是，如果您以 `fullboth` 状态启动 `Emacs` ，则必须在初始文件中指定所需的行为，例如
    
        (setq default-frame-alist
            '((fullscreen . fullboth)
              (fullscreen-restore . fullheight)))
    
    这将在第一次输入 `F11` 后给出一个新的帧全高。
    
        fit-frame-to-buffer-margins
    
    当使用 `fit-frame-to-buffer` 将此帧拟合到其根窗口的缓冲区时，此参数允许覆盖选项 `fit-frame-to-buffer-margins` 的值（请参阅调整窗口大小）。
    
        fit-frame-to-buffer-sizes
    
    当使用 `fit-frame-to-buffer` 将此帧拟合到其根窗口的缓冲区时，此参数允许覆盖选项 `fit-frame-to-buffer-sizes` 的值（请参阅调整窗口大小）。

4.  30.4.3.4 布局参数

    这些帧参数启用或禁用帧的各个部分，或控制它们的大小。
    
        border-width
    
    帧外边框的宽度（以像素为单位）（请参阅帧几何）。
    
        internal-border-width
    
    帧内部边框的宽度（以像素为单位）（请参阅帧几何）。
    
        child-frame-border-width
    
    如果给定的帧是子帧（请参阅子帧），则以像素为单位的帧内部边框的宽度（请参阅帧几何）。如果为 `nil` ，则使用由 `internal-border-width` 参数指定的值。
    
        vertical-scroll-bars
    
    帧是否有用于垂直滚动的滚动条（请参阅滚动条），以及它们应该位于帧的哪一侧。对于无滚动条，可能的值是 `left` 、right 和 `nil` 。
    
        horizontal-scroll-bars
    
    帧是否有用于水平滚动的滚动条（t 和底部表示是， `nil` 表示否）。
    
        scroll-bar-width
    
    垂直滚动条的宽度，以像素为单位，或 `nil`  表示使用默认宽度。
    
        scroll-bar-height
    
    水平滚动条的高度，以像素为单位，或 `nil`  表示使用默认高度。
    
        left-fringe
    
        right-fringe
    
    此帧中窗口左右边缘的默认宽度（请参阅边缘）。如果其中任何一个为零，则有效地去除了相应的边缘。
    
    当您使用 `frame-parameter` 查询这两个 `frame` 参数中的任何一个的值时，返回值始终是一个整数。使用 `set-frame-parameter` 时，传递一个 `nil`  值会强制使用 `8` 个像素的实际默认值。
    
        right-divider-width
    
    为帧上任何窗口的右分隔线（请参阅窗口分隔线）保留的宽度（厚度），以像素为单位。零值表示不绘制右分隔线。
    
        bottom-divider-width
    
    为帧上任何窗口的底部分隔线（请参阅窗口分隔线）保留的宽度（厚度），以像素为单位。零值表示不绘制底部分隔线。
    
        menu-bar-lines
    
    在帧顶部为菜单栏分配的行数（请参阅菜单栏）。如果启用了菜单栏模式，则默认值为 `1` ，否则为 `0` 。请参阅 `GNU Emacs` 手册中的菜单栏。对于外部菜单栏（请参阅帧布局），即使菜单栏换行为两行或多行，此值也保持不变。在这种情况下，由 `frame-geometry` （参见 `Frame Geometry` ）返回的 `menu-bar-size` 值允许推导出菜单栏是否实际占用一行或多行。
    
        tool-bar-lines
    
    用于工具栏的行数（请参阅工具栏）。如果启用了工具栏模式，则默认值为 `1` ，否则为 `0` 。请参阅 `GNU Emacs` 手册中的工具栏。每当工具栏换行时，此值可能会更改（请参阅帧布局）。
    
        tool-bar-position
    
    使用 `GTK+` 构建 `Emacs` 时工具栏的位置。它的值可以是上、左下、右之一。默认为顶部。
    
        tab-bar-lines
    
    用于标签栏的行数（参见 `GNU Emacs` 手册中的标签栏）。如果启用 `Tab Bar` 模式，则默认值为 `1` ，否则为 `0` 。每当标签栏换行时，此值可能会更改（请参阅帧布局）。
    
        line-spacing
    
    在每个文本行下方留下的额外空间，以像素为单位（正整数）。有关详细信息，请参阅行高。
    
        no-special-glyphs
    
    如果这是非零，它会禁止显示此帧显示的所有缓冲区的任何截断和继续字形（请参阅截断）。当通过 `fit-frame-to-buffer` 将帧拟合到其缓冲区时，这对于消除此类字形很有用（请参阅调整窗口大小）。

5.  30.4.3.5 缓冲区参数

    这些对各种终端都有意义的帧参数处理哪些缓冲区已经或应该显示在帧中。
    
        minibuffer
    
    此帧是否有自己的 `minibuffer` 。值 `t` 表示是， `nil` ~ 表示否，仅表示此帧只是一个 `minibuffer` 。如果该值是一个 `minibuffer` 窗口（在某个其他帧中），则该帧使用该 `minibuffer` 。
    
    该参数在创建帧时生效。如果指定为 `nil` ，Emacs 将尝试将其设置为 `default-minibuffer-frame` 的 `minibuffer` 窗口（参见 `Minibuffers and Frames` ）。对于现有帧，此参数可专门用于指定另一个 `minibuffer` 窗口。不允许将其从 `minibuffer` 窗口更改为 `t` ，反之亦然，或从 `t` 更改为 `nil` 。如果参数已经指定了一个 `minibuffer` 窗口，则将其设置为 `nil`  无效。
    
    特殊值 `child-frame` 意味着创建一个只有 `minibuffer` 的子帧（参见子帧），其父帧成为创建的帧。如同指定为 `nil`  一样，Emacs 会将此参数设置为子帧的 `minibuffer` 窗口，但不会在子帧创建后选择子帧。
    
        buffer-predicate
    
    此帧的缓冲区谓词函数。如果谓词不为零，则函数 `other-buffer` 使用此谓词（来自所选帧）来决定应该考虑哪些缓冲区。它使用一个参数调用谓词，一个缓冲区，每个缓冲区一次；如果谓词返回一个非零值，它会考虑该缓冲区。
    
        buffer-list
    
    已在此帧中选择的缓冲区列表，按最近选择的顺序排列。
    
        unsplittable
    
    如果非零，则此帧的窗口永远不会自动拆分。

6.  30.4.3.6 帧交互参数

    这些参数提供了不同帧之间的交互形式。
    
        parent-frame
    
    如果非零，这意味着这个帧是一个子帧（见子帧），这个参数指定它的父帧。如果为零，这意味着这个帧是一个普通的顶级帧。
    
        delete-before
    
    如果非零，则该参数指定另一个帧，其删除将自动触发该帧的删除。请参阅删除帧。
    
        mouse-wheel-frame
    
    如果非零，则此参数指定每当鼠标滚轮滚动且鼠标指针悬停在此帧上时，该帧的窗口将滚动，请参阅 `GNU Emacs` 手册中的鼠标命令。
    
        no-other-frame
    
    如果这是非零，则此帧不适合作为函数 `next-frame` 、previous-frame（请参阅查找所有帧）和其他帧的候选者，请参阅 `GNU Emacs` 手册中的帧命令。
    
        auto-hide-function
    
    当此参数指定一个函数时，当退出帧的唯一窗口（请参阅退出窗口）并且还有其他帧时，将调用该函数而不是变量 `frame-auto-hide-function` 指定的函数。
    
        minibuffer-exit
    
    当这个参数不为 `nil`  时，Emacs 默认会在 `minibuffer` （见 `Minibuffers` ）退出时使这个帧不可见。或者，它可以指定函数 `iconify-frame` 和 `delete-frame` 。该参数对于在退出 `minibuffer` 时使子帧自动消失（类似于 `Emacs` 处理窗口的方式）很有用。
    
        keep-ratio
    
    此参数目前仅对子帧（请参阅子帧）有意义。如果它不是 `nil` ，那么 `Emacs` 将尝试保持帧的大小（宽度和高度）比率（请参阅大小参数）以及其左右位置比率（请参阅位置参数）在其父帧调整大小时保持不变。
    
    如果该参数的值为 `nil` ，则在调整父帧的大小时，帧的位置和大小保持不变，因此位置和大小的比例可能会发生变化。如果此参数的值为 `t` ，Emacs 将尝试保留帧的大小和位置比例，因此帧相对于其父帧的大小和位置可能会发生变化。
    
    使用 `cons` 单元格可以进行更多的单独控制：在这种情况下，如果单元格的 `CAR` 为 `t` 或仅宽度，则保留帧的宽度比。如果单元格的 `CAR` 为 `t` 或仅高度，则保留高度比。如果单元格的 `CDR` 为 `t` 或 `left-only` ，则保留左侧位置比率。如果单元的 `CDR` 为 `t` 或 `top-only` ，则保留顶部位置比率。

7.  30.4.3.7 鼠标拖动参数

    下面描述的参数支持通过用鼠标拖动帧的内部边框来调整帧的大小。它们还允许通过拖动其最顶部的标题或标签行或最底部窗口的模式行来使用鼠标移动帧。
    
    这些参数对于没有窗口管理器装饰的子帧（参见子帧）非常有用。如有必要，它们也可用于未装饰的顶级帧。
    
        drag-internal-border
    
    如果非零，则可以通过使用鼠标拖动其内部边框（如果存在）来调整帧的大小。
    
        drag-with-header-line
    
    如果非零，则可以通过拖动其最顶部窗口的标题行来使用鼠标移动帧。
    
        drag-with-tab-line
    
    如果非零，则可以通过拖动其最顶部窗口的制表符行来使用鼠标移动帧。
    
        drag-with-mode-line
    
    如果非零，则可以通过拖动其最底部窗口的模式线来使用鼠标移动帧。请注意，这样的帧不允许有自己的 `minibuffer` 窗口。
    
        snap-width
    
    用鼠标移动的帧将 `捕捉` 在显示器的边框或其父帧上，只要它被拖动到接近此参数指定的像素数的边缘。
    
        top-visible
    
    如果此参数是一个数字，则帧的上边缘永远不会出现在其显示或父帧的上边缘之上。此外，当帧移动到其显示或父帧的任何剩余边缘时，该数字指定的尽可能多的帧像素将保持可见。设置此参数对于防止将具有非 `nil drag-with-header-line` 参数的子帧完全拖出其父帧区域很有用。
    
        bottom-visible
    
    如果此参数是一个数字，则帧的底边永远不会出现在其显示或父帧的底边之下。此外，当帧移动到其显示或父帧的任何剩余边缘时，该数字指定的尽可能多的帧像素将保持可见。设置此参数有助于防止将具有非零拖动模式线参数的子帧完全拖出其父帧的区域。

8.  30.4.3.8 窗口管理参数

    以下帧参数控制帧与窗口管理器或窗口系统交互的各个方面。它们对文本终端没有影响。
    
        visibility
    
    帧的可见性状态。有三种可能： `nil` ~ 表示不可见，t 表示可见，icon 表示图标化。请参阅帧的可见性。
    
        auto-raise
    
    如果非 `nil` ，Emacs 会在选择帧时自动提升帧。一些窗口管理器不允许这样做。
    
        auto-lower
    
    如果非零，Emacs 会在取消选择时自动降低帧。一些窗口管理器不允许这样做。
    
        icon-type
    
    用于此帧的图标类型。如果值是字符串，则指定包含要使用的位图的文件； `nil` ~ 不指定图标（在这种情况下，窗口管理器决定显示什么）；任何其他非 `nil`  值指定默认的 `Emacs` 图标。
    
        icon-name
    
    在此帧的图标中使用的名称，何时以及是否出现图标。如果为 `nil` ，则使用帧的标题。
    
        window-id
    
    图形显示用于此帧的 `ID` 号。Emacs 在创建帧时分配这个参数；更改参数对实际 `ID` 号没有影响。
    
        outer-window-id
    
    帧所在的最外层窗口系统窗口的 `ID` 号。与 `window-id` 一样，更改此参数没有实际效果。
    
        wait-for-wm
    
    如果非零，告诉 `Xt` 等待窗口管理器确认几何变化。某些窗口管理器，包括 `Fvwm2` 和 `KDE` 的版本，无法确认，因此 `Xt` 挂起。将此设置为 `nil`  以防止与那些窗口管理器挂起。
    
        sticky
    
    如果非零，则该帧在具有虚拟桌面的系统上的所有虚拟桌面上可见。
    
        inhibit-double-buffering
    
    如果非零，则将帧绘制到屏幕上而不进行双重缓冲。Emacs 通常会尝试在可用的情况下使用双缓冲来减少闪烁。如果您遇到显示错误或因那种复古、闪烁的感觉而感到松懈，请设置此属性。
    
        skip-taskbar
    
    如果非零，这将告诉窗口管理器从与帧的显示关联的任务栏中删除帧的图标，并禁止通过组合 `Alt-TAB` 切换到帧的窗口。在 `MS-Windows` 上，图标化这样的帧将在桌面底部 `滚动` 其窗口系统窗口。某些窗口管理器可能不支持此参数。
    
        no-focus-on-map
    
    如果非零，这意味着帧在映射时不希望接收输入焦点（请参阅帧的可见性）。某些窗口管理器可能不支持此参数。
    
        no-accept-focus
    
    如果非零，这意味着帧不希望通过显式鼠标单击或通过焦点跟随鼠标（请参阅输入焦点）或鼠标自动选择窗口（请参阅鼠标窗口）将鼠标移入其中时接收输入焦点自动选择）。这可能会产生不希望的副作用，即用户无法使用鼠标滚动未选择的帧。某些窗口管理器可能不支持此参数。
    
        undecorated
    
    如果非零，则该帧的窗口系统窗口不带任何装饰，如标题、最小化/最大化框和外部边框。这通常意味着不能用鼠标拖动、调整大小、图标化、最大化或删除窗口。如果为 `nil` ，则通常使用上面列出的所有元素绘制帧的窗口，除非它们的显示已通过窗口管理器设置暂停。
    
    在 `X` 下，Emacs 使用 `Motif` 窗口管理器提示来关闭装饰。一些窗口管理器可能不遵守这些提示。
    
    NS 构建将工具栏视为装饰，因此将其隐藏在未装饰的帧上。
    
        override-redirect ¶
    
    如果非零，这意味着这是一个覆盖重定向帧——在 `X` 下不被窗口管理器处理的帧。覆盖重定向帧没有窗口管理器装饰，只能通过 `Emacs` 的定位和调整大小函数来定位和调整大小，并且通常是绘制在所有其他帧之上。设置此参数对 `MS-Windows` 没有影响。
    
        ns-appearance
    
    仅在 `macOS` 上可用，如果设置为深色，则使用 `充满活力的深色` 主题绘制此帧的窗口系统窗口，如果设置为浅色，则使用 `水色` 主题，否则使用系统默认值。当使用带有深色背景的 `Emacs` 主题时， `充满活力的深色` 主题可用于将工具栏和滚动条设置为深色外观。
    
        ns-transparent-titlebar
    
    仅在 `macOS` 上可用，如果非零，则将标题栏和工具栏设置为透明。这有效地设置了两者的背景颜色以匹配 `Emacs` 背景颜色。

9.  30.4.3.9 光标参数

    此帧参数控制光标的外观。
    
        cursor-type
    
    如何显示光标。合法值是：
    
        box
    
    显示一个填充框。（这是默认设置。）
    
        (box . size)
    
    显示一个填充框。但是，如果点在蒙版图像下大于任一维度中的 `size` 像素，则将其显示为空心框。
    
        hollow
    
    显示一个空心盒子。
    
        nil
    
    不显示光标。
    
        bar
    
    在字符之间显示竖线。
    
        (bar . width)
    
    在字符之间显示一个垂直条宽度像素宽。
    
        hbar
    
    显示一个水平条。
    
        (hbar . height)
    
    显示一个水平条高度像素高。
    
    cursor-type 帧参数可以被变量 `cursor-type` 和 `cursor-in-non-selected-windows` 覆盖：
    
        User Option: cursor-type ¶
    
    此缓冲区局部变量控制光标在显示缓冲区的选定窗口中的外观。如果其值为 `t` ，则表示使用 `cursor-type frame` 参数指定的光标。否则，该值应该是上面列出的游标类型之一，它会覆盖游标类型帧参数。
    
        User Option: cursor-in-non-selected-windows ¶
    
    此缓冲区局部变量控制光标在未选定窗口中的外观。它支持与光标类型帧参数相同的值；此外， `nil` ~ 表示不在未选择的窗口中显示光标，而 `t` （默认值）表示使用通常光标类型的标准修改（实心框变为空心框，条形变为较窄的条形）。
    
        User Option: x-stretch-cursor ¶
    
    此变量控制显示在超宽字形上的块光标的宽度，例如制表符或一段空白区域。默认情况下，块光标仅与字体的默认字符一样宽，如果字形超宽，则不会覆盖其下字形的所有宽度。此变量的非 `nil`  值意味着将块光标绘制为与其下方的字形一样宽。默认值为无。
    
    这个变量对文本模式帧没有影响，因为文本模式光标是由终端绘制的，不受 `Emacs` 的控制。
    
        User Option: blink-cursor-alist ¶
    
    此变量指定如何使光标闪烁。每个元素都有形式（on-state . off-state）。只要光标类型等于 `on-state` （使用 `equal` 进行比较），相应的 `off-state` 就会指定光标闪烁时的样子。开启状态和关闭状态都应该是光标类型帧参数的合适值。
    
    如果在此处未将类型作为开启状态提及，则如何闪烁每种类型的光标有各种默认值。此变量的更改不会立即生效，只有在您指定光标类型帧参数时才会生效。

10. 30.4.3.10 字体和颜色参数

    这些帧参数控制字体和颜色的使用。
    
        font-backend
    
    符号列表，按优先级指定用于在帧上绘制字符的字体后端。在没有在 `X` 上绘制 `Cairo` 的 `Emacs` 中，目前有三种可能可用的字体后端：x（X 核心字体驱动程序）、xft（Xft 字体驱动程序）和 `xfthb` （具有 `HarfBuzz` 文本整形的 `Xft` 字体驱动程序）。如果使用 `Cairo` 绘图构建，那么 `X` 上还有三个潜在可用的字体后端：x、ftcr（Cairo 上的 `FreeType` 字体驱动程序）和 `ftcrhb` （Cairo 上具有 `HarfBuzz` 文本整形的 `FreeType` 字体驱动程序）。使用 `HarfBuzz` 构建 `Emacs` 时，默认字体驱动程序是 `ftcrhb` ，虽然使用 `ftcr` 驱动程序仍然是可能的，但不推荐。在 `MS-Windows` 上，目前有三种可用的字体后端：gdi（核心 `MS-Windows` 字体驱动程序）、uniscribe（用于 `OTF` 和 `TTF` 字体的字体驱动程序，由 `Uniscribe` 引擎进行文本整形）和 `harfbuzz` （用于 `OTF` 和带有 `HarfBuzz` 文本整形的 `TTF` 字体）（参见 `GNU Emacs` 手册中的 `Windows` 字体）。同样推荐使用 `harfbuzz` 驱动程序。在其他系统上，只有一个可用的字体后端，所以修改这个帧参数没有意义。
    
        background-mode
    
    根据背景颜色是浅色还是深色，此参数是深色还是浅色。
    
        tty-color-mode ¶
    
    此参数覆盖系统终端功能数据库给出的终端颜色支持，因为此参数的值指定在文本终端上使用的颜色模式。该值可以是符号或数字。一个数字指定要使用的颜色数量（以及间接地指定发出什么命令来产生每种颜色）。例如，(tty-color-mode . 8) 指定 `ANSI` 转义序列用于 `8` 种标准文本颜色。值 `-1` 关闭颜色支持。
    
    如果参数的值为符号，则通过 `tty-color-mode-alist` 的值指定一个数字，并使用关联的数字代替。
    
        screen-gamma ¶
    
    如果这是一个数字，Emacs 会执行 `gamma` 校正来调整所有颜色的亮度。该值应该是显示器的屏幕伽玛。
    
    通常的 `PC` 显示器的屏幕 `gamma` 为 `2.2` ，因此 `Emacs` 和 `X` 窗口中的颜色值经过校准，可以在具有该 `gamma` 值的显示器上正确显示。如果您为 `screen-gamma` 指定 `2.2` ，这意味着不需要校正。其他值需要校正，旨在使校正后的颜色在屏幕上显示为未经校正而在伽马值为 `2.2` 的普通显示器上出现的方式。
    
    如果您的显示器显示颜色太浅，您应该指定一个小于 `2.2` 的屏幕伽马值。这要求进行使颜色变深的校正。屏幕伽马值 `1.5` 可能会为 `LCD` 彩色显示器提供良好的效果。
    
        alpha ¶
    
    此参数在支持可变不透明度的图形显示上指定帧的不透明度。它应该是 `0` 到 `100` 之间的整数，其中 `0` 表示完全透明，100 表示完全不透明。它也可以有一个 `nil`  值，它告诉 `Emacs` 不要设置帧的不透明度（把它留给窗口管理器）。
    
    为了防止帧从视图中完全消失，变量 `frame-alpha-lower-limit` 定义了不透明度下限。如果 `frame` 参数的值小于这个变量的值，Emacs 使用后者。默认情况下，frame-alpha-lower-limit 为 `20` 。
    
    alpha frame参数也可以是cons单元格（active.inactive），其中active为选中时frame的不透明度，inactive为未选中时的不透明度。
    
    某些窗口系统不支持子帧的 `alpha` 参数（请参阅子帧）。
    
    以下帧参数是半过时的，因为它们自动等效于特定面的特定面属性（请参阅 `Emacs` 手册中的标准面）：
    
        font
    
    用于在帧中显示文本的字体名称。这是一个字符串，可以是系统的有效字体名称，也可以是 `Emacs` 字体集的名称（请参阅字体集）。相当于默认面的字体属性。
    
        foreground-color
    
    用于字符的颜色。它相当于默认面的 `:foreground` 属性。
    
        background-color
    
    用于字符背景的颜色。它相当于默认面的 `:background` 属性。
    
        mouse-color
    
    鼠标指针的颜色。相当于鼠标脸的 `:background` 属性。
    
        cursor-color
    
    显示点的光标颜色。它相当于光标面的 `:background` 属性。
    
        border-color
    
    帧边框的颜色。它相当于边框的 `:background` 属性。
    
        scroll-bar-foreground
    
    如果非零，滚动条前景的颜色。它相当于滚动条面的 `:foreground` 属性。
    
        scroll-bar-background
    
    如果非零，滚动条背景的颜色。它相当于滚动条面的 `:background` 属性。


<a id="orge333478"></a>

### 30.4.4 几何

以下是如何检查 `X` 样式窗口几何规范中的数据：

    Function: x-parse-geometry geom ¶

函数 `x-parse-geometry` 将标准 `X` 窗口几何字符串转换为 `alist` ，您可以将其用作 `make-frame` 参数的一部分。

alist 描述了在 `geom` 中指定了哪些参数，并给出了为它们指定的值。每个元素看起来像（参数。值）。可能的参数值是 `left` 、top、width 和 `height` 。

对于大小参数，值必须是整数。位置参数名称 `left` 和 `top` 并不完全准确，因为某些值指示的是右边缘或下边缘的位置。位置参数的取值可能是：整数、列表（+ pos）或列表（- pos）；如前所述（参见位置参数）。

这是一个例子：

    (x-parse-geometry "35x70+0-0")
         ⇒ ((height . 70) (width . 35)
    	 (top - 0) (left . 0))


<a id="org3fbd76c"></a>

## 30.5 终端参数

每个终端都有一个相关参数列表。这些终端参数大多是终端局部变量的一种方便的存储方式，但有些终端参数有特殊的含义。

本节介绍读取和更改终端参数值的功能。他们都接受终端或帧作为他们的论据；后者意味着使用该帧的终端。 `nil` ~ 参数表示所选帧的终端。

    Function: terminal-parameters &optional terminal ¶

此函数返回一个列表，列出终端的所有参数及其值。

    Function: terminal-parameter terminal parameter ¶

该函数返回终端参数参数（一个符号）的值。如果终端没有参数设置，这个函数返回 `nil` 。

    Function: set-terminal-parameter terminal parameter value ¶

该函数将终端的参数参数设置为指定值，并返回该参数的先前值。

下面列出了一些具有特殊含义的终端参数：

    background-mode

终端背景颜色的分类，浅色或深色。

    normal-erase-is-backspace

值是 `1` 或 `0` ，具体取决于此终端上的 `normal-erase-is-backspace-mode` 是打开还是关闭。请参阅 `Emacs` 手册中的 `DEL` 不删除。

    terminal-initted

终端初始化后，设置为终端特定的初始化函数。

    tty-mode-set-strings

当存在时，包含 `Emacs` 将在配置 `tty` 以进行渲染时输出的转义序列的字符串列表。Emacs 仅在配置终端时发出这些字符串：如果您想在已经处于活动状态的终端上启用模式（例如，在 `tty-setup-hook` 中），请使用 `send-string-to-` 显式输出必要的转义序列终端除了将序列添加到 `tty-mode-set-strings` 之外。

    tty-mode-reset-strings

如果存在，则取消 `tty-mode-set-strings` 中字符串效果的字符串列表。Emacs 在退出、删除终端或挂起自身时会发出这些字符串。


<a id="orgc0bda8e"></a>

## 30.6 帧标题

每帧都有一个名称参数；这用作窗口系统通常显示在帧顶部的帧标题的默认值。您可以通过设置名称帧属性显式指定名称。

通常你不明确指定名称，Emacs 会根据存储在变量 `frame-title-format` 中的模板自动计算帧名称。每次重新显示帧时，Emacs 都会重新计算名称。

    Variable: frame-title-format ¶

当您没有明确指定一个帧时，此变量指定如何计算帧的名称。变量的值实际上是一个模式行结构，就像模式行格式一样，只是忽略了 `%c` 、 `%C` 和 `%l` 结构。请参阅模式行的数据结构。

    Variable: icon-title-format ¶

当您没有明确指定帧标题时，此变量指定如何计算图标化帧的名称。此标题出现在图标本身中。

    Variable: multiple-frames ¶

这个变量是由 `Emacs` 自动设置的。当有两个或更多帧（不包括 `minibuffer-only` 帧或不可见帧）时，其值为 `t` 。frame-title-format 的默认值使用multiple-frames，以便只有在超过一帧时才将缓冲区名称放在帧标题中。

除非在处理 `frame-title-format` 或 `icon-title-format` 时，不能保证此变量的值是准确的。


<a id="org4b98090"></a>

## 30.7 删除帧

实时帧是尚未删除的帧。当一个帧被删除时，它会从它的终端显示中移除，尽管它可能会继续作为一个 `Lisp` 对象存在，直到不再有对它的引用。

    Command: delete-frame &optional frame force ¶

此功能删除帧帧。参数帧必须指定一个实时帧（见下文）并默认为选定的帧。

它首先删除帧的任何子帧（参见子帧）和任何其删除前帧参数（参见帧交互参数）指定帧的帧。所有此类删除都是递归执行的；所以这一步确保不存在其他以 `frame` 为祖先的帧。然后，除非 `frame` 指定了工具提示，否则此函数会在实际终止 `frame` 之前运行钩子 `delete-frame-functions` （每个函数获取一个参数，frame）。在实际杀死帧并从帧列表中删除帧后，delete-frame 运行 `after-delete-frame-functions` 。

请注意，只要它的 `minibuffer` 充当另一个帧的代理 `minibuffer` ，就不能删除一个帧（请参阅 `Minibuffers` 和 `Frames` ）。通常，如果所有其他帧都不可见，则无法删除帧，但如果 `force` 不为零，则允许您这样做。

    Function: frame-live-p frame ¶

如果帧帧没有被删除，此函数返回非零。可能的非零返回值类似于 `framep` 。请参阅帧。

一些窗口管理器提供删除窗口的命令。它们通过向操作窗口的程序发送特殊消息来工作。当 `Emacs` 获得这些命令之一时，它会生成一个 `delete-frame` 事件，其正常定义是调用函数 `delete-frame` 的命令。请参阅其他系统事件。

    Command: delete-other-frames &optional frame iconify ¶

此命令删除帧终端上的所有帧，帧除外。如果 `frame` 使用另一个 `frame` 的 `minibuffer` ，则该 `minibuffer` 帧保持不变。参数帧必须指定一个实时帧并默认为选定的帧。在内部，此命令通过调用 `delete-frame` 和 `force nil` 来处理所有应删除的帧。

此函数不会删除任何帧的子帧（请参阅子帧）。如果 `frame` 是子帧，它只删除帧的兄弟。

使用前缀参数 `iconify` ，帧被图标化而不是被删除。


<a id="org7ba654e"></a>

## 30.8 查找所有帧

    Function: frame-list ¶

该函数返回所有活动帧的列表，即那些未被删除的帧。它类似于缓冲区的缓冲区列表，并包括所有终端上的帧。您获得的列表是新创建的，因此修改列表不会对 `Emacs` 的内部产生任何影响。

    Function: visible-frame-list ¶

此函数返回仅包含当前可见帧的列表。请参阅帧的可见性。文本终端上的帧始终被视为可见，即使实际上只显示了选定的帧。

    Function: frame-list-z-order &optional display ¶

此函数以 `Z` （堆叠）顺序返回 `Emacs` 的帧列表（请参阅提升、降低和重新堆叠帧）。可选参数 `display` 指定轮询哪个显示器。display 应该是一个帧或一个显示名称（一个字符串）。如果省略或为零，则表示所选帧的显示。如果 `display` 不包含 `Emacs` 帧，则返回 `nil` 。

帧从最顶部（第一个）到最底部（最后一个）列出。作为一种特殊情况，如果 `display` 不为零并指定一个活动帧，它会以 `Z` （堆叠）顺序返回该帧的子帧。

此功能在文本终端上没有意义。

    Function: next-frame &optional frame minibuf ¶

此功能可让您从任意起点方便地循环浏览特定终端上的所有帧。它在帧的终端上返回所有活动帧列表中的下一帧。参数帧必须指定一个实时帧并默认为选定的帧。它永远不会返回 `no-other-frame` 参数（请参阅帧交互参数）为非零的帧。

第二个参数 `minibuf` 表示在决定下一帧应该是什么时要考虑哪些帧：

    nil

考虑除 `minibuffer-only` 帧之外的所有帧。

    visible

只考虑可见帧。

    0

只考虑可见或图标化的帧。

    a window

仅考虑使用该特定窗口作为其迷你缓冲区窗口的帧。

    anything else

考虑所有帧。

    Function: previous-frame &optional frame minibuf ¶

与下一帧类似，但以相反方向循环遍历所有帧。

另请参阅 `Windows` 的循环排序中的下一个窗口和上一个窗口。


<a id="orgc09e8be"></a>

## 30.9 小缓冲区和帧

Normally, each frame has its own minibuffer window at the bottom, which is used whenever that frame is selected.  您可以使用 `minibuffer-window` 函数获取该窗口（请参阅 `Minibuffer Windows` ）。

但是，您也可以创建一个没有 `minibuffer` 的帧。这样的帧必须使用某个其他帧的 `minibuffer` 窗口。该其他帧将用作该帧的代理微型缓冲区帧，并且只要该帧处于活动状态，就不能通过删除帧删除（请参阅删除帧）。

创建帧时，您可以使用 `minibuffer` 帧参数（请参阅缓冲区参数）显式指定其 `minibuffer` 窗口（在某些其他帧中）。如果你不这样做，那么 `minibuffer` 会在 `frame` 中找到，它是变量 `default-minibuffer-frame` 的值。它的值应该是一个确实有一个小缓冲区的帧。

如果您使用一个仅包含 `minibuffer` 的帧，您可能希望在进入 `minibuffer` 时提升该帧。如果是这样，请将变量 `minibuffer-auto-raise` 设置为 `t` 。请参阅提升、降低和重新堆叠帧。

    Variable: default-minibuffer-frame ¶

默认情况下，此变量指定用于 `minibuffer` 窗口的帧。它不会影响现有帧。它始终是当前终端本地的，不能是缓冲区本地的。请参阅多个终端。


<a id="org1124ea0"></a>

## 30.10 输入焦点

在任何时候，Emacs 中的一帧都是选中的帧。选定的窗口（请参阅选择窗口）始终驻留在选定的帧上。

当 `Emacs` 在多个终端上显示其帧时（请参阅多个终端），每个终端都有自己的选定帧。但其中只有一个是选定的帧：它是属于最近输入的终端的帧。也就是说，当 `Emacs` 运行来自某个终端的命令时，选定的帧就是那个终端的帧。由于 `Emacs` 在任何给定时间只运行一个命令，它一次只需要考虑一个选定的帧；这个帧就是我们在本手册中所说的选择帧。显示所选帧的显示器是所选帧的显示器。

    Function: selected-frame ¶

此函数返回选定的帧。

一些窗口系统和窗口管理器将键盘输入直接指向鼠标所在的窗口对象；其他需要显式单击或命令才能将焦点转移到各种窗口对象。无论哪种方式，Emacs 都会自动跟踪哪些帧具有焦点。要从 `Lisp` 函数显式切换到不同的帧，请调用 `select-frame-set-input-focus` 。

上一段中的复数 `帧` 是经过深思熟虑的：虽然 `Emacs` 本身只有一个选定的帧，但 `Emacs` 可以在许多不同的终端上拥有帧（回想一下，与窗口系统的连接算作终端），并且每个终端都有自己的哪个帧具有输入焦点的想法。将输入焦点设置为帧时，您为该帧的终端设置焦点，但其他终端上的帧可能仍保持焦点。

Lisp 程序可以通过调用函数 `select-frame` 来临时切换帧。这不会改变窗口系统的焦点概念；相反，它会从窗口管理器的控制中逃脱，直到该控制以某种方式重新生效。

使用文本终端时，终端上一次只能显示一帧，因此调用 `select-frame` 后，下一次重新显示实际上显示新选择的帧。此帧保持选中状态，直到随后调用 `select-frame` 。文本终端上的每一帧都有一个数字，它出现在模式行中缓冲区名称之前（请参阅模式行中使用的变量）。

    Function: select-frame-set-input-focus frame &optional norecord ¶

这个函数选择帧，提升它（如果它碰巧被其他帧遮住）并尝试给它窗口系统的焦点。在文本终端上，下一次重新显示会在整个终端屏幕上显示新帧。可选参数 `norecord` 与 `select-frame` 具有相同的含义（见下文）。这个函数的返回值并不重要。

理想情况下，接下来描述的功能应该聚焦一个帧，而不会将其提升到其他帧之上。不幸的是，许多窗口系统或窗口管理器可能拒绝遵守。

    Function: x-focus-frame frame &optional noactivate ¶

这个函数让 `frame` 成为 `X` 服务器的焦点，而不必提升它。frame nil 表示使用选定的帧。在 `X` 下，可选参数 `noactivate` ，如果非零，则意味着避免使帧的窗口系统窗口成为 `活动` 窗口，这应该更多地坚持避免将帧提升到其他帧之上。

在 `MS-Windows` 上，noactivate 参数无效。但是，如果 `frame` 是子帧（请参阅子帧），此功能通常会聚焦帧而不将其提升到其他子帧之上。

如果没有窗口系统支持，这个函数什么也不做。

    Command: select-frame frame &optional norecord ¶

此函数选择帧帧，暂时忽略 `X` 服务器的焦点（如果有）。帧的选择一直持续到用户下一次选择不同的帧，或者直到下一次调用这个函数。（如果您使用的是窗口系统，返回命令循环后可能会将之前选择的帧恢复为选择的帧，因为它仍然可能具有窗口系统的输入焦点。）

指定的帧成为选定的帧，其终端成为选定的终端。然后这个函数调用 `select-window` 作为一个子例程，传递在 `frame` 中选择的窗口作为它的第一个参数和 `norecord` 作为它的第二个参数（因此，如果 `norecord` 是非零，这避免了改变最近选择的窗口和缓冲区列表的顺序）。请参阅选择窗口。

此函数返回 `frame` ，如果 `frame` 已被删除，则返回 `nil` 。

通常，您永远不应该以一种可以切换到不同终端的方式使用 `select-frame` ，而无需在完成后切换回来。

Emacs 通过安排选择帧作为服务器和窗口管理器的请求来与窗口系统协作。当窗口系统通知 `Emacs` 它的一个帧已被选中时，Emacs 会在内部生成一个焦点事件。当 `Emacs` 帧显示在文本终端模拟器上时，例如 `xterm` ，它支持报告焦点更改通知，即使对于文本模式帧，焦点输入和焦点输出事件也可用。焦点事件通常由 `handle-focus-in` 处理。

    Command: handle-focus-in event ¶

此函数处理来自支持显式焦点通知的窗口系统和终端的焦点事件。它更新帧焦点状态查询的每帧焦点标志，并调用 `after-focus-change-function` 。此外，它会生成一个 `switch-frame` 事件，以便将所选帧的 `Emacs` 概念切换到最近聚焦在某个终端中的帧。需要注意的是，这种将 `Emacs` 选定帧切换到最近聚焦的帧并不意味着其他帧不会继续在其各自的终端中获得焦点。不要自己调用此函数：而是将逻辑附加到 `after-focus-change-function` 。

    Command: handle-switch-frame frame ¶

这个函数处理一个切换帧事件，Emacs 在焦点通知时或在涉及输入事件到达与上一个事件不同的帧的各种其他情况下为自己生成该事件。不要自己调用此函数。

    Function: redirect-frame-focus frame &optional focus-frame ¶

此功能将焦点从帧重定向到焦点帧。这意味着焦点帧将接收后续的击键和用于帧的事件。在这样的事件之后，last-event-frame 的值将是 `focus-frame` 。此外，指定 `frame` 的 `switch-frame` 事件将改为选择 `focus-frame` 。

如果 `focus-frame` 被省略或为零，则取消任何现有的 `frame` 重定向，因此再次接收自己的事件。

焦点重定向的一种用途是用于没有小缓冲区的帧。这些帧在其他帧上使用迷你缓冲区。在另一个帧上激活一个 `minibuffer` 会将焦点重定向到该帧。这将焦点放在它所属的 `minibuffer` 的帧上，即使鼠标停留在激活 `minibuffer` 的帧中。

选择一个帧也可以改变焦点重定向。Selecting frame bar, when foo had been selected, changes any redirections pointing to foo so that they point to bar instead.  当用户使用选择窗口从一帧切换到另一帧时，这允许焦点重定向正常工作。

这意味着焦点重定向到自身的帧与焦点未重定向的帧不同。select-frame 影响前者，但不影响后者。

重定向一直持续到调用 `redirect-frame-focus` 来改变它。

    Function: frame-focus-state frame ¶

此函数检索帧的最后一个已知焦点状态。

如果已知帧没有被聚焦，则返回 `nil` ，如果已知帧被聚焦，则返回 `t` ，如果 `Emacs` 不知道帧的焦点状态，则返回 `unknown` 。（您可能会在不支持显式焦点通知的终端上运行的 `TTY` 帧中看到最后一个状态。）

    Variable: after-focus-change-function ¶

此函数是代码可用于接收焦点已更改通知的扩展点。

当 `Emacs` 注意到焦点帧的集合可能已经改变时，这个函数被调用，不带任何参数。想要在帧焦点变化时做某事的代码应该使用 `add-function` 向这个函数添加一个函数，并在这个添加的函数中，重新扫描焦点帧集，调用 `frame-focus-state` 来检索最后一个已知的焦点状态每一帧。焦点事件是异步传递的，根据外部系统的帧输入焦点可能与 `Emacs` 选定帧的概念不对应。由于焦点事​​件传递的差异、多个 `Emacs` 终端的存在以及其他因素，多个帧可能看起来同时具有输入焦点，面对这种情况，代码应该是健壮的。

根据窗口系统，焦点事件也可以在稳定到预期值之前以不同的焦点状态重复传递。依赖焦点通知的代码应该 `去抖动` 任何由焦点更改引起的用户可见的更新，也许是通过推迟工作直到重新显示。

此函数可以在任意上下文中调用，包括从内部读取事件中调用，因此请像编写进程过滤器时一样小心。

    User Option: focus-follows-mouse ¶

当您将鼠标指针移动到帧中时，此选项会通知 `Emacs` 窗口管理器是否以及如何转移焦点。它可以具有三个有意义的值：

    nil

当您的窗口管理器遵循 `单击聚焦` 策略时，应使用默认值 `nil` ，您必须在帧内单击鼠标才能使该帧获得焦点。

    t

当您的窗口管理器的焦点自动跟随鼠标指针的位置但获得焦点的帧不会自动提升并且甚至可能被其他窗口系统窗口遮挡时，应该使用值 `t` 。

    auto-raise

当窗口管理器的焦点自动跟随鼠标指针的位置并且获得焦点的帧自动升起时，应该使用值 `auto-raise` 。

如果此选项非零，Emacs 将鼠标指针移动到由 `select-frame-set-input-focus` 选择的帧。该函数被许多命令使用，例如其他帧和弹出到缓冲区。

`正常` 帧不需要区分 `t` 值和 `auto-raise` 值，因为窗口管理器通常会负责提升它们。通过 `mouse-autoselect-window` 自动提升子帧很有用（请参阅鼠标窗口自动选择）。

请注意，此选项不区分 `草率` 焦点（只要鼠标指针没有移动到另一个窗口系统窗口，先前具有焦点的帧保持焦点）与 `严格` 焦点（帧立即失去焦点）它由鼠标指针离开）。它也不识别您的窗口管理器是否支持延迟聚焦或自动提升，您可以在其中明确指定新帧获得焦点或自动提升的时间。

您可以通过自定义变量 `mouse-autoselect-window` 为单个 `Emacs` 窗口提供 `焦点跟随鼠标` 策略（请参阅鼠标窗口自动选择）。


<a id="org563005b"></a>

## 30.11 帧的可见性

图形显示上的帧可以是可见的、不可见的或图标化的。如果它是可见的，它的内容就会以通常的方式显示。如果它被图标化，它的内容不会显示，但是在某处有一个小图标可以让帧重新进入视图（一些窗口管理器将此状态称为最小化而不是图标化，但从 `Emacs` 的角度来看，它们是相同的事物）。如果帧不可见，则根本不显示。

可见性的概念与（未）映射帧的概念密切相关。帧（或更准确地说，它的窗口系统窗口）在第一次显示时以及每当它的可见性状态从图标化或不可见变为可见时，都会被映射并变为映射。相反，只要帧将其状态从可见更改为图标化或不可见，它就会变为未映射。

可见性在文本终端上是没有意义的，因为在任何情况下实际上只显示选定的帧。

    Function: frame-visible-p frame ¶

此函数返回帧帧的可见性状态。如果 `frame` 可见，则值为 `t` ，如果不可见，则值为 `nil` ，如果已图标化，则值为 `icon` 。

在文本终端上，出于此功能的目的，所有帧都被视为可见，即使只显示一个帧。请参阅提升、降低和重新堆叠帧。

    Command: iconify-frame &optional frame ¶

此功能图标化帧帧。如果您省略帧，它将图标化选定的帧。这通常会使帧的所有子帧（及其后代）不可见（请参阅子帧）。

    Command: make-frame-visible &optional frame ¶

此功能使帧帧可见。如果您省略帧，它会使选定的帧可见。这不会提升帧，但如果您愿意，您可以使用提升帧来做到这一点（请参阅提升、降低和重新堆叠帧）。

使帧可见通常使其所有子帧（及其后代）也可见（请参阅子帧）。

    Command: make-frame-invisible &optional frame force ¶

此功能使帧帧不可见。如果您省略帧，它会使选定的帧不可见。通常，这会使帧的所有子帧（及其后代）也变得不可见（请参阅子帧）。

除非 `force` 不为零，否则如果所有其他帧都不可见，则此函数拒绝使帧不可见。

帧的可见性状态也可用作帧参数。您可以这样阅读或更改它。请参阅窗口管理参数。用户还可以使用窗口管理器对帧进行图标化和去图标化。这发生在 `Emacs` 可以施加任何控制的级别之下，但 `Emacs` 确实提供了可用于跟踪此类更改的事件。请参阅其他系统事件。

    Function: x-double-buffered-p &optional frame ¶

如果当前正在使用双缓冲渲染帧，则此函数返回非 `nil` 。帧默认为选定的帧。


<a id="org3b9a610"></a>

## 30.12 提升、降低和重新堆叠帧

大多数窗口系统都使用桌面隐喻。这个比喻的一部分是系统级窗口（表示，例如，Emacs 帧）堆叠在垂直于屏幕表面的名义三维中的想法。堆叠引起的顺序是总的，通常称为堆叠（或 `Z-` ）顺序。在两个窗口的区域重叠的地方，按该顺序较高的一个将（部分）覆盖下面的一个。

您可以使用 `raise-frame` 和 `lower-frame` 函数将帧提升到该顺序的顶部或将帧降低到底部。您可以使用函数 `frame-restack` 将帧直接重新堆叠在另一个帧的上方或下方。

请注意，下面描述的所有功能都将尊重帧（和所有其他窗口系统窗口）对其各自 `z` 组的遵守（请参阅位置参数）。例如，通常不能将帧降低到桌面窗口的下方，并且不能将 `z-group` 参数为 `nil`  的帧升高到窗口系统的任务栏或工具提示窗口上方。

    Command: raise-frame &optional frame ¶

此功能将帧帧（默认为选定帧）提升到属于与帧相同或较低 `z` 组的所有其他帧之上。如果帧不可见或图标化，则使其可见。如果 `frame` 是子帧（参见子帧），这会将帧提升到其父帧的所有其他子帧之上。

    Command: lower-frame &optional frame ¶

此功能将帧帧（默认为选定帧）降低到属于与帧相同或更高 `z` 组的所有其他帧之下。如果帧是子帧（请参阅子帧），这会将帧降低到其父帧的所有其他子帧之下。

    Function: frame-restack frame1 frame2 &optional above ¶

此函数将 `frame1` 重新堆叠到 `frame2` 之下。这意味着如果两个帧都是可见的并且它们的显示区域重叠，那么帧 `2` 将（部分）遮盖帧 `1` 。如果上面可选的第三个参数不为 `nil` ，则此函数将 `frame1` 重新堆叠在 `frame2` 之上。这意味着如果两个帧都是可见的并且它们的显示区域重叠，那么帧 `1` 将（部分）遮盖帧 `2` 。

从技术上讲，这个函数可以被认为是分两步执行的原子动作： `第` 一步从显示中删除 `frame1` 的窗口系统窗口。第二步将 `frame1` 的窗口重新插入到 `frame2` 的下方（如果上面为真，则在上方）的显示中。因此，frame2 在其显示的 `Z` （堆叠）顺序中相对于除 `frame1` 之外的所有其他帧的位置保持不变。

一些窗口管理器可能拒绝重新堆叠窗口。

请注意，仅当所涉及的帧都没有被图标化或不可见时，重新堆叠的效果才会生效。您可以使用 `z-group` （请参阅位置参数）帧参数将帧添加到永久显示在其他帧上方或下方的一组帧中。只要一个帧属于这些组之一，重新堆叠它只会影响其在该组中的相对堆叠位置。重新堆叠属于不同 `z` 组的帧的效果是不确定的。您可以使用函数 `frame-list-z-order` 按当前堆叠顺序列出帧（请参阅查找所有帧）。

    User Option: minibuffer-auto-raise ¶

如果这是非零，则激活 `minibuffer` 会提升 `minibuffer` 窗口所在的帧。

在窗口系统上，您还可以使用帧参数启用自动升高（在帧选择时）或自动降低（在帧取消选择时）。请参阅窗口管理参数。

升高和降低帧的概念也适用于文本终端帧。在每个文本终端上，任何时候都只显示顶部帧。

    Function: tty-top-frame &optional terminal ¶

此函数返回终端上的顶部帧。terminal 应该是一个终端对象、一个帧（表示该帧的终端）或 `nil` （表示所选帧的终端）。如果它不引用文本终端，则返回值为 `nil` 。


<a id="orgd05c13e"></a>

## 30.13 帧配置

帧配置记录了帧的当前排列、它们的所有属性以及每个帧的窗口配置。（请参阅窗口配置。）

    Function: current-frame-configuration ¶

此函数返回一个帧配置列表，该列表描述了帧的当前排列及其内容。

    Function: set-frame-configuration configuration &optional nodelete ¶

此函数恢复配置中描述的帧的状态。但是，此功能不会恢复已删除的帧。

通常，此功能会删除所有未在配置中列出的现有帧。但如果 `nodelete` 不为零，则将不需要的帧图标化。


<a id="org4ec871f"></a>

## 30.14 子帧

子帧是介于窗口（参见 `Windows` ）和 `正常` 帧之间的对象。像窗户一样，它们连接到一个拥有的帧上。与窗口不同，它们可能会相互重叠——改变一个子帧的大小或位置不会改变其任何兄弟子帧的大小或位置。

根据设计，制作或修改子帧的操作是在帧参数（参见帧参数）的帮助下实现的，无需任何专门的函数或可定制的变量。请注意，子帧仅在图形终端上有意义。

要创建新的子帧或将普通帧转换为子帧，请将该帧的父帧参数（请参阅帧交互参数）设置为现有帧的参数。只要该参数未更改或重置，该参数指定的帧将成为该帧的父帧。从技术上讲，这使得子帧的窗口系统窗口成为父帧的窗口系统窗口的子窗口。

parent-frame 参数可以随时更改。将其设置为另一个帧将重新设置子帧。将其设置为另一个子帧会使该帧成为嵌套子帧。将其设置为 `nil`  会将帧的状态恢复为顶级帧——其窗口系统窗口是其显示根窗口的子窗口的帧。

由于子帧可以任意嵌套，因此一个帧既可以是子帧，也可以是父帧。此外，子帧和父帧的相对角色可以随时颠倒（尽管保持子帧的大小足够小于其父帧的大小通常是个好主意）。尝试使帧成为其自身的祖先时，将发出错误信号。

大多数窗口系统在其父帧的本机边缘（请参阅帧几何）处剪辑一个子帧——这些边缘之外的所有东西通常都是不可见的。子帧的 `left` 和 `top` 参数指定相对于其父帧的左上角的位置。当父帧调整大小时，这个位置在概念上保持不变。

NS 构建不会在父帧的边缘剪裁子帧，从而允许它们被定位，这样它们就不会遮挡父帧，同时它们本身仍然可见。

通常，移动父帧会沿着其所有子帧及其后代移动，保持它们的相对位置不变。请注意，仅当子帧相对于其父帧的位置发生变化时，才会为子帧运行钩子移动帧功能（请参阅帧位置）。

当父帧调整大小时，其子帧在概念上保留其先前的大小和它们相对于父帧左上角的位置。这意味着当父帧缩小时，子帧可能变得（部分）不可见。参数 `keep-ratio` （请参阅帧交互参数）可用于在调整父帧大小时按比例调整子帧的大小和重新定位。这可以避免在其父帧收缩时遮挡帧的某些部分。

可见的子帧总是出现在其父帧的顶部，因此遮盖了它的一部分，除非在 `NS` 构建中它可能位于父帧之下。这类似于顶层帧的窗口系统窗口，它也始终出现在其父窗口（桌面的根窗口）的顶部。当父帧被图标化或使其不可见时（请参阅帧的可见性），其子帧将变为不可见。当父帧被取消图标化或可见时，其子帧变为可见。

当一个父帧即将被删除时（参见删除帧），它的子帧在它之前被递归删除。此规则有一个例外：当子帧充当另一个帧的代理微型缓冲区帧（请参阅微型缓冲区和帧）时，它会一直保留到父帧被删除为止。如果此时没有剩余的帧使用子帧作为其 `minibuffer` 帧，Emacs 也会尝试删除子帧。如果该删除由于某种原因而失败，则子帧将成为顶级帧。

子帧是否可以有菜单或工具栏取决于窗口系统或窗口管理器。大多数窗口系统明确禁止子帧的菜单栏。通过帧的初始参数设置禁用菜单和工具栏似乎是可取的。

通常，子帧不显示窗口管理器装饰，如标题栏或外部边框（请参阅帧几何）。当子帧不显示菜单或工具栏时，可以使用帧的任何其他边框（请参阅布局参数）代替外部边框。

特别是，在 `X` 下（但不是在使用 `GTK+` 构建时），可以使用帧的外边框。在 `MS-Windows` 上，指定非零外边框宽度将显示一个像素宽的外边框。在所有窗口系统下，都可以使用内部边框。在任何一种情况下，建议使用 `undecorated frame` 参数禁用子帧的窗口管理器装饰（请参阅窗口管理参数）。

要使用鼠标调整大小或移动未修饰的子帧，必须使用特殊的帧参数（请参阅鼠标拖动参数）。子帧的内部边框（如果存在）可用于使用鼠标调整帧的大小，前提是该帧具有非零的 `drag-internal-border` 参数。如果设置，则 `snap-width` 参数指示帧在其父帧的相应边缘或角处捕捉的像素数。

有两种方法可以用鼠标拖动整个子帧： `drag-with-mode-line` 参数，如果非零，允许通过其最底部的模式行区域拖动没有 `minibuffer` 窗口的帧（参见 `Minibuffer Windows` ）窗户。drag-with-header-line 参数，如果非零，允许通过其最顶部窗口的标题行区域拖动帧。

为了给子帧一个可拖动的标题或模式行，窗口参数 `mode-line-format` 和 `header-line-format` 很方便（请参阅窗口参数）。这些允许删除不需要的模式线（选择标头线时）并删除可能干扰帧拖动的鼠标敏感区域。

当用户用鼠标拖动一个帧并超出范围时，很容易将一个帧拖出其父级的屏幕区域。一旦释放鼠标按钮，检索这样的帧可能会很麻烦。为防止出现这种情况，建议设置帧的顶部可见或底部可见参数（请参阅鼠标拖动参数）。

当您打算允许用户通过其标题行拖动该帧时，将子帧的 `top-visible` 参数设置为一个数字。将 `top-visible` 设置为数字会禁止将子帧的上边缘拖动到其父帧的上边缘之上。当您打算通过其模式线拖动该帧时，将底部可见参数设置为一个数字；这禁止将子帧的底部边缘拖到其父帧的底部边缘下方。在任何一种情况下，该数字还指定在拖动期间保持可见的子帧区域的宽度和高度（以像素为单位）。

当子帧用于通过 `display-buffer-in-child-frame` 显示缓冲区时（请参阅缓冲区显示的动作函数），可以将帧的自动隐藏函数参数（请参阅帧交互参数）设置为函数，为了在显示缓冲区的窗口应退出时适当地处理帧。

当在 `minibuffer` 交互期间使用子帧时，例如，在单独的窗口中显示完成时，minibuffer-exit 参数（请参阅帧交互参数）对于在 `minibuffer` 退出时处理帧很有用。

子帧的行为在许多其他方面也与顶级帧的行为有所不同。在这里，我们勾勒出其中的一些：

最大化和图标化子帧的语义高度依赖于窗口系统。通常，应用程序永远不应该在子帧上调用这些操作。默认情况下，在子帧上调用 `iconify-frame` 将尝试图标化与该子帧对应的顶级帧。为了获得不同的行为，用户可以自定义下面描述的选项 `iconify-child-frame` 。
提升、降低和重新堆叠子帧（请参阅提升、降低和重新堆叠帧）或更改子帧的 `z` 组（请参阅位置参数）只会更改具有相同父级的子帧的堆叠顺序。
许多窗口系统无法更改子帧的不透明度（请参阅字体和颜色参数）。
在某些窗口系统中，通过在祖先窗口的可见部分中单击鼠标将焦点从子帧转移到不是其父帧的祖先可能会失败。您可能必须先单击直接父级的窗口系统窗口。
窗口管理器可能不会费心将焦点按照鼠标策略扩展到子帧。自定义 `mouse-autoselect-window` 可以在这方面有所帮助（请参阅鼠标窗口自动选择）。
子帧上的拖放（请参阅拖放）不能保证在所有窗口系统上都有效。有些会将对象放在父帧或某个祖先上。

在处理子帧和父帧时，以下两个函数很有用：

    Function: frame-parent &optional frame ¶

该函数返回frame的父frame。frame 的父帧是 `Emacs` 帧，其窗口系统窗口是帧的窗口系统窗口的父窗口。如果存在这样的帧，则认为帧是该帧的子帧。

如果帧没有父帧，此函数返回 `nil` 。

    Function: frame-ancestor-p ancestor descendant ¶

如果祖先是后代的祖先，则此函数返回非零。当它是后代的父帧或者它是后代的父帧的祖先时，祖先是后代的祖先。祖先和后代都必须指定实时帧。

还要注意函数 `window-largest-empty-rectangle` （参见坐标和窗口），它可用于在现有窗口的最大空白区域中嵌入子帧。这对于避免子帧遮盖该窗口中显示的任何文本很有用。

自定义以下选项对于调整子帧的 `iconify-frame` 行为很有用。

    User Option: iconify-child-frame ¶

此选项告诉 `Emacs` 在要求图标化子帧时如何继续。如果它是 `nil` ，iconify-frame 在子帧上调用时什么也不做。如果它是 `iconify-top-level` ，Emacs 将尝试图标化作为此子帧祖先的顶级帧。如果它是不可见的，Emacs 将尝试使这个子帧不可见而不是图标化它。

任何其他值都意味着尝试图标化子帧。由于这种尝试可能不会被所有窗口管理器接受，甚至可能导致子帧对用户操作没有响应，因此默认情况下是图标化顶级帧。


<a id="org6145f59"></a>

## 30.15 鼠标跟踪

有时跟踪鼠标很有用，这意味着显示一些东西来指示鼠标在哪里，并在鼠标移动时移动指示器。为了有效地跟踪鼠标，您需要一种等待鼠标实际移动的方法。

跟踪鼠标的便捷方法是请求事件来表示鼠标运动。然后，您可以通过等待事件来等待动作。此外，您可以轻松处理可能发生的任何其他类型的事件。这很有用，因为通常您不希望永远跟踪鼠标——只在其他一些事件之前，例如释放按钮。

    Macro: track-mouse body… ~¶

~ 此宏执行主体，并启用鼠标运动事件的生成。通常，body 会使用 `read-event` 来读取运动事件并相应地修改显示。有关鼠标运动事件的格式，请参阅运动事件。

track-mouse 的值是 `body` 中最后一个形式的值。您应该将 `body` 设计为在看到指示按钮释放的向上事件时返回，或者任何类型的事件意味着是时候停止跟踪了。

track-mouse 形式使 `Emacs` 通过将变量 `track-mouse` 绑定到一个非 `nil`  值来生成鼠标运动事件。如果该变量具有特殊值 `dragging` ，它还指示显示引擎不要更改鼠标指针的形状。这在需要鼠标在 `Emacs` 显示的大部分区域上拖动的 `Lisp` 程序中是可取的，否则可能会导致鼠标指针根据其悬停的显示部分改变其形状（请参阅指针形状）。因此，在拖动过程中需要鼠标指针保持其原始形状的 `Lisp` 程序应该将 `track-mouse` 绑定到其主体开始处拖动的值。

跟踪鼠标运动的通常目的是在屏幕上指示在当前位置按下或释放按钮的结果。

在许多情况下，您可以通过使用 `mouse-face` 文本属性来避免跟踪鼠标的需要（请参阅具有特殊含义的属性）。与 `Lisp` 级别的鼠标跟踪相比，它的工作水平要低得多，运行起来更流畅。


<a id="org28172ab"></a>

## 30.16 鼠标位置

函数 `mouse-position` 和 `set-mouse-position` 可以访问鼠标的当前位置。

    Function: mouse-position ¶

此函数返回鼠标位置的描述。该值看起来像 `(frame x . y)` ，其中 `x` 和 `y` 是整数，给出相对于 `frame` 的原始位置（参见 `Frame Geometry` ）的帧默认字符大小的倍数（可能是四舍五入的）位置（参见 `Frame Font` ） ~.

    Variable: mouse-position-function ¶

~ 如果非零，则此变量的值是鼠标位置调用的函数。mouse-position 在返回之前调用这个函数，它的正常返回值作为唯一的参数，它返回这个函数返回给它的任何东西。

这个异常钩子的存在是为了像 `xt-mouse.el` 这样需要在 `Lisp` 级别进行鼠标处理的包。

    Variable: tty-menu-calls-mouse-position-function ¶

如果非零，TTY 菜单将调用鼠标位置函数，如上所述。这存在于 `TTY` 菜单调用 `mouse-position-function` 不安全的情况下，例如它是否可以触发重新显示。

    Function: set-mouse-position frame x y ¶

此函数将鼠标扭曲到帧中的 `x` 、y 位置。参数 `x` 和 `y` 是整数，以帧的默认字符大小（请参阅帧字体）相对于帧的原始位置（请参阅帧几何）的倍数给出位置。

生成的鼠标位置被限制在 `frame` 的原生帧内。如果帧不可见，则此函数不执行任何操作。返回值不重要。

    Function: mouse-pixel-position ¶

此函数类似于 `mouse-position` ，不同之处在于它以像素为单位返回坐标，而不是以字符为单位。

    Function: set-mouse-pixel-position frame x y ¶

这个函数像 `set-mouse-position` 一样扭曲鼠标，除了 `x` 和 `y` 是像素单位而不是字符单位。

生成的鼠标位置不受帧的本机帧的限制。如果帧不可见，则此函数不执行任何操作。返回值不重要。

在图形终端上，以下两个函数允许检索和设置鼠标光标的绝对位置。

    Function: mouse-absolute-pixel-position ¶

此函数返回鼠标光标位置坐标的 `cons` 单元格 `(x . y)` ，以像素为单位，相对于所选帧显示的位置 `(0, 0)` 。

    Function: set-mouse-absolute-pixel-position x y ¶

此函数将鼠标光标移动到位置 `(x, y)` 。坐标 `x` 和 `y` 以相对于所选帧显示的位置 `(0, 0)` 的像素为单位进行解释。

以下函数可以判断鼠标光标当前是否在帧上可见：

    Function: frame-pointer-visible-p &optional frame ¶

如果显示在帧上的鼠标指针可见，则此谓词函数返回非零；否则返回零。frame 省略或 `nil`  表示选择的帧。这在 `make-pointer-invisible` 设置为 `t` 时很有用：它允许您知道指针是否已被隐藏。请参阅 `Emacs` 手册中的鼠标避免。


<a id="orga16cb5a"></a>

## 30.17 弹出菜单

Lisp 程序可以弹出一个菜单，以便用户可以用鼠标选择一个选项。在文本终端上，如果鼠标不可用，用户可以使用键盘移动键（Cn、Cp 或上下箭头键）选择替代方案。

    Function: x-popup-menu position menu ¶

此函数显示一个弹出菜单并返回用户所做选择的指示。

参数位置指定在屏幕上放置菜单左上角的位置。它可以是鼠标按钮事件（表示将菜单放在用户按下按钮的位置）或以下形式的列表：

    ((xoffset yoffset) window)

其中 `xoffset` 和 `yoffset` 是坐标，以像素为单位，从窗口的左上角开始计数。window 可以是窗口或帧。

如果 `position` 为 `t` ，则表示使用当前鼠标位置（如果鼠标在文本终端上不可用，则使用帧的左上角）。如果 `position` 为 `nil` ，则表示预先计算 `menu` 中指定的键映射的键绑定等效项，而不实际显示或弹出菜单。

参数 `menu` 说明要在菜单中显示的内容。它可以是键盘映射或键盘映射列表（请参阅菜单键盘映射）。在这种情况下，返回值是与用户选择相对应的事件列表。如果选择发生在子菜单中，则该列表具有多个元素。（请注意，x-popup-menu 实际上并不执行绑定到该事件序列的命令。）在支持菜单标题的文本终端和工具包上，如果 `menu` 是键盘映射，则标题取自 `menu` 的提示字符串，或者取自如果是键映射列表，则菜单中第一个键映射的提示字符串（请参阅定义菜单）。

或者，菜单可以具有以下形式：

    (title pane1 pane2...)

其中每个窗格都是表单列表

    (title item1 item2...)

每个项目都应该是一个 `cons` 单元格 `(line . value)` ，其中 `line` 是一个字符串，而 `value` 是选择该行时要返回的值。与菜单键映射不同， `nil` ~ 值不会使菜单项不可选择。或者，每个项目都可以是一个字符串而不是一个 `cons` 单元格；这使得一个不可选择的菜单项。

如果用户在没有做出有效选择的情况下退出菜单，例如通过在有效选择之外单击鼠标或键入 `Cg` ，则这通常会导致退出并且 `x-popup-menu` 不会返回。但是如果 `position` 是一个鼠标按钮事件（表明用户用鼠标调用了菜单），那么不会发生退出并且 `x-popup-menu` 返回 `nil` 。

使用说明：如果您可以使用由菜单键映射定义的前缀键来完成这项工作，请不要使用 `x-popup-menu` 来显示菜单。如果您使用菜单键映射来实现菜单，则 `Ch c` 和 `Ch a` 可以看到该菜单中的各个项目并为它们提供帮助。相反，如果您通过定义调用 `x-popup-menu` 的命令来实现菜单，则帮助工具无法知道该命令内部发生了什么，因此它们无法为菜单项提供任何帮助。

允许您通过移动鼠标在子菜单之间切换的菜单栏机制无法在命令的定义中查看它是否调用了 `x-popup-menu` 。因此，如果您尝试使用 `x-popup-menu` 实现子菜单，则它无法以集成方式与菜单栏一起使用。这就是为什么所有菜单栏子菜单都使用父菜单中的菜单键映射实现，而不是使用 `x-popup-menu` 。请参阅菜单栏。

如果您希望菜单栏子菜单具有不同的内容，您仍然应该使用菜单键映射来实现它。要使内容变化，请在 `menu-bar-update-hook` 中添加一个钩子函数，以根据需要更新菜单键映射的内容。


<a id="org44004ef"></a>

## 30.18 对话框

对话框是弹出菜单的一种变体——它看起来有点不同，它总是出现在帧的中心，并且只有一个级别和一个或多个按钮。对话框的主要用途是提出问题，用户可以用 `是` 、 `否` 和其他一些选择来回答。通过一个按钮，他们还可以强制用户确认重要信息。y-or-np 和 `yes-or-no-p` 函数在通过鼠标点击调用的命令调用时使用对话框而不是键盘。

    Function: x-popup-dialog position contents &optional header ¶

此函数显示一个弹出对话框并返回用户所做选择的指示。参数内容指定提供的替代方案；它有这种格式：

    (title (string . value)…)

它看起来像为 `x-popup-menu` 指定单个窗格的列表。

返回值是来自所选备选方案的值。

至于 `x-popup-menu` ，列表的元素可能只是一个字符串，而不是一个 `cons` 单元格（字符串 `.` 值）。这使一个无法选择的框。

如果 `nil`  出现在列表中，它将左侧项目与右侧项目分开； `nil` ~ 之前的项目出现在左侧， `nil` ~ 之后的项目出现在右侧。如果列表中不包含 `nil` ，则大约一半的项目出现在每一侧。

对话框总是出现在帧的中心；参数位置指定哪个帧。可能的值与 `x-popup-menu` 中的一样，但精确坐标或单个窗口无关紧要；只有帧很重要。

如果 `header` 不为零，则框的帧标题为 `信息` ，否则为 `问题` 。前者用于消息框（见消息框）。（在文本终端上，不显示框标题。）

在某些配置中，Emacs 无法显示真正的对话框；因此，它会在帧中心的弹出菜单中显示相同的项目。

如果用户在没有做出有效选择的情况下退出对话框，例如使用窗口管理器，那么这会产生退出并且 `x-popup-dialog` 不会返回。


<a id="org51d45ae"></a>

## 30.19 指针形状

您可以使用指针文本属性为特定文本或图像指定鼠标指针样式，并为具有 `:pointer` 和 `:map` 图像属性的图像指定鼠标指针样式。您可以在这些属性中使用的值如下表所示。实际形状可能因系统而异；描述是示例。

    text

    nil

在文本上使用的常用鼠标指针样式（类似 `I` 的形状）。

    arrow

    vdrag

    modeline

指向西北的箭头。

    hand

一只指向上方的手。

    hdrag

一个左右箭头。

    nhdrag

一个上下箭头。

    hourglass

一个旋转的环。

在窗口的空白部分（与任何缓冲区内容不对应的部分）上，鼠标指针通常使用箭头样式，但您可以通过设置 `void-text-area-` 来指定不同的样式（上述样式之一）指针。

    User Option: void-text-area-pointer ¶

此变量指定空白文本区域的鼠标指针样式。这些包括缓冲区中一行结束之后或最后一行之下的区域。默认是使用箭头（非文本）指针样式。

使用 `X` 时，您可以通过设置变量 `x-pointer-shape` 来指定文本指针样式的真实外观。

    Variable: x-pointer-shape ¶

此变量指定通常在 `Emacs` 帧中使用的指针形状，用于文本指针样式。

    Variable: x-sensitive-text-pointer-shape ¶

此变量指定当鼠标悬停在鼠标敏感文本上时要使用的指针形状。

这些变量会影响新创建的帧。它们通常不会影响现有帧；但是，如果您设置帧的鼠标颜色，也会安装这两个变量的当前值。请参阅字体和颜色参数。

用于指定这些指针形状中的任何一个的值在文件 `lisp/term/x-win.el` 中定义。使用 `Mx apropos RET x-pointer RET` 查看它们的列表。


<a id="org1c85c69"></a>

## 30.20 窗口系统选择

在诸如 `X` 之类的窗口系统中，可以通过选择在不同应用程序之间传输数据。X 定义了任意数量的选择类型，每个选择类型都可以存储自己的数据；但是，只有三个常用：剪贴板、主要选择和次要选择。其他窗口系统仅支持剪贴板。有关使用这些选择的 `Emacs` 命令，请参阅 `GNU Emacs` 手册中的剪切和粘贴。本节记录了用于读取和设置窗口系统选择的低级函数。

    Command: gui-set-selection type data ¶

此函数设置窗口系统选择。它有两个参数：一个选择类型类型，以及分配给它的值，数据。

类型应该是一个符号；它通常是主要、次要或剪贴板之一。这些是具有大写名称的符号，符合 `X Window` 系统约定。如果 `type` 为 `nil` ，则代表 `PRIMARY` 。

如果 `data` 为 `nil` ，则表示清除选择。否则，数据可能是字符串、符号、整数（或两个整数的 `cons` 或两个整数的列表）、覆盖或指向同一缓冲区的两个标记的 `cons` 。一个叠加层或一对标记代表叠加层中或标记之间的文本。自变量数据也可以是有效的非向量选择值的向量。

该函数返回数据。

    Function: gui-get-selection &optional type data-type ¶

此功能访问由 `Emacs` 或其他程序设置的选择。它有两个可选参数，类型和数据类型。类型（选择类型）的默认值是 `PRIMARY` 。

data-type 参数指定要使用的数据转换形式，将从另一个程序获得的原始数据转换为 `Lisp` 数据。有意义的值包括 `TEXT` 、STRING、UTF8<sub>STRING</sub>、TARGETS、LENGTH、DELETE、FILE<sub>NAME</sub>、CHARACTER<sub>POSITION</sub>、NAME、LINE<sub>NUMBER</sub>、COLUMN<sub>NUMBER</sub>、OWNER<sub>OS</sub>、HOST<sub>NAME</sub>、USER、CLASS、ATOM 和 `INTEGER` 。（这些是与 `X` 约定一致的大写名称的符号。）数据类型的默认值是 `STRING` 。除了 `STRING` 之外，X 以外的窗口系统通常只支持这些类型的一小部分。

    User Option: selection-coding-system ¶

此变量指定在读取和写入选择或剪贴板时要使用的编码系统。请参阅编码系统。默认值为复合文本与扩展，它转换为 `X11` 通常使用的文本表示。

当 `Emacs` 在 `MS-Windows` 上运行时，它通常不实现 `X` 选择，但它确实支持剪贴板。MS-Windows 上的 `gui-get-selection` 和 `gui-set-selection` 仅支持文本数据类型；如果剪贴板包含其他类型的数据，Emacs 会将剪贴板视为空的。支持的数据类型是 `STRING` 。

为了向后兼容，有过时的别名 `x-get-selection` 和 `x-set-selection` ，它们是 `Emacs 25.1` 之前的 `gui-get-selection` 和 `gui-set-selection` 的名称。


<a id="org51b0cf1"></a>

## 30.21 拖放

当用户通过 `Emacs` 从另一个应用程序拖动某些东西时，该应用程序希望 `Emacs` 告诉它 `Emacs` 是否可以处理被拖动的数据。Emacs 使用变量 `x-dnd-test-function` 来确定要回复的内容。默认值为 `x-dnd-default-test-function` ，如果要删除的数据类型存在于 `x-dnd-known-types` 中，则接受删除。如果您希望 `Emacs` 根据其他一些标准接受或拒绝丢弃，您可以自定义 `x-dnd-test-function` 和/或 `x-dnd-known-types` 。

如果你想改变 `Emacs` 处理丢弃不同类型或添加新类型的方式，自定义 `x-dnd-types-alist` 。这需要详细了解其他应用程序用于拖放的类型。

当在 `Emacs` 上放置一个 `URL` 时，它可能是一个文件，但也可能是另一种 `URL` 类型（https 等）。Emacs 首先检查 `dnd-protocol-alist` 以确定如何处理 `URL` 。如果那里没有匹配项，Emacs 会在 `browse-url-handlers` 和 `browse-url-default-handlers` 中查找匹配项。如果仍未找到匹配项，则插入 `URL` 的文本。如果你想改变 `Emacs` 的行为，你可以自定义这些变量。


<a id="org648f669"></a>

## 30.22 颜色名称

颜色名称是指定颜色的文本（通常在字符串中）。允许使用 `黑色` 、 `白色` 、 `红色` 等符号名称；使用 `Mx list-colors-display` 查看已定义名称的列表。您还可以以数字形式指定颜色，例如 `'#rgb'` 和 `'RGB:r/g/b'` ，其中 `r` 指定红色级别，g 指定绿色级别，b 指定蓝色级别。r 可以使用一个、两个、三个或四个十六进制数字；那么您也必须对所有 `g` 和 `b` 使用相同数量的十六进制数字，总共 `3` 、6、9 或 `12` 个十六进制数字。（有关颜色的数字 `RGB` 规范的更多详细信息，请参阅 `X Window` 系统的文档。）

这些函数提供了一种方法来确定哪些颜色名称是有效的，以及它们的外观。在某些情况下，该值取决于所选帧，如下所述；有关术语 `选定帧` 的含义，请参见输入焦点。

要完整读取用户输入的颜色名称，请使用 `read-color` （请参阅 `read-color` ）。

    Function: color-defined-p color &optional frame ¶

此函数报告颜色名称是否有意义。如果是，则返回 `t` ；否则，无。参数帧说明要询问哪个帧的显示；如果 `frame` 被省略或为零，则使用选定的帧。

请注意，这并不能告诉您您使用的显示器是否真的支持该颜色。使用 `X` 时，您可以在任何类型的显示器上请求任何定义的颜色，并且您会得到一些结果——通常是它所能做的最接近的结果。要确定一个帧是否真的可以显示某种颜色，请使用 `color-supported-p` （见下文）。

该函数以前称为 `x-color-defined-p` ，并且该名称仍被支持作为别名。

    Function: defined-colors &optional frame ¶

此函数返回在帧帧（默认为选定帧）上定义和支持的颜色名称列表。如果 `frame` 不支持颜色，则值为 `nil` 。

该函数以前称为 `x-defined-colors` ，并且该名称仍被支持作为别名。

    Function: color-supported-p color &optional frame background-p ¶

如果 `frame` 真的可以显示颜色颜色（或至少接近它的颜色），则返回 `t` 。如果帧被省略或为零，则问题适用于所选帧。

一些终端支持一组不同的前景和背景颜色。如果 `background-p` 不为零，则表示您在询问是否可以将颜色用作背景；否则你在问它是否可以用作前景。

参数颜色必须是有效的颜色名称。

    Function: color-gray-p color &optional frame ¶

如果颜色是灰色阴影，则返回 `t` ，如帧的显示所定义。如果帧被省略或为零，则问题适用于所选帧。如果 `color` 不是有效的颜色名称，则此函数返回 `nil` 。

    Function: color-values color &optional frame ¶

此函数返回一个值，该值描述了帧上理想的颜色。如果定义了颜色，则该值是三个整数的列表，它们给出了红色的数量、绿色的数量和蓝色的数量。每个整数范围原则上从 `0` 到 `65535` ，但有些显示器可能不会使用全范围。这个三元素列表称为颜色的 `rgb` 值。

如果未定义颜色，则值为 `nil` 。

    (color-values "black")
         ⇒ (0 0 0)
    (color-values "white")
         ⇒ (65535 65535 65535)
    (color-values "red")
         ⇒ (65535 0 0)
    (color-values "pink")
         ⇒ (65535 49344 52171)
    (color-values "hungry")
         ⇒ nil

为帧的显示返回颜色值。如果 `frame` 被省略或为零，则返回所选帧显示的信息。如果帧不能显示颜色，则值为 `nil` 。

此函数过去称为 `x-color-values` ，并且该名称仍支持作为别名。


<a id="orgc76ede3"></a>

## 30.23 文本终端颜色

文本终端通常只支持少量的颜色，计算机使用小整数在终端上选择颜色。这意味着计算机无法可靠地判断所选颜色的外观；相反，您必须通知您的应用程序哪些小整数对应于哪些颜色。但是，Emacs 确实知道标准的颜色集，并且会尝试自动使用它们。

本节中描述的函数控制 `Emacs` 如何使用终端颜色。

其中一些函数使用或返回 `rgb` 值，如颜色名称中所述。

这些函数接受显示（帧或终端名称）作为可选参数。我们希望将来让 `Emacs` 在不同的文本终端上支持不同的颜色；然后此参数将指定要在哪个终端上进行操作（默认为所选帧的终端；请参阅输入焦点）。但目前，帧参数无效。

    Function: tty-color-define name number &optional rgb frame ¶

该函数将颜色名称名称与终端上的颜色编号相关联。

可选参数 `rgb` （如果指定）是一个 `rgb` 值，一个由三个数字组成的列表，用于指定颜色的实际外观。如果不指定 `rgb` ，那么这个颜色不能被 `tty-color-approximate` 用来逼近其他颜色，因为 `Emacs` 不会知道它长什么样。

    Function: tty-color-clear &optional frame ¶

此函数清除文本终端的已定义颜色表。

    Function: tty-color-alist &optional frame ¶

此函数返回一个记录文本终端支持的已知颜色的列表。

每个元素的格式为 `(name number .rgb)` 或 `(name number)` 。这里，name 是颜色名称，number 是用来指定给终端的数字。如果存在，则 `rgb` 是三个颜色值（红色、绿色和蓝色）的列表，表示颜色的实际外观。

    Function: tty-color-approximate rgb &optional frame ¶

此函数在支持显示的已知颜色中查找与 `rgb` 值 `rgb` （颜色值列表）所描述的颜色最接近的颜色。返回值是 `tty-color-alist` 的一个元素。

    Function: tty-color-translate color &optional frame ¶

此函数在支持显示的已知颜色中找到最接近颜色的颜色，并返回其索引（整数）。如果名称颜色未定义，则值为 `nil` 。


<a id="org5fde2c9"></a>

## 30.24 X 资源

本节介绍一些用于查询和使用 `X` 资源的函数和变量，或者它们在您的操作系统上的等价物。有关 `X` 资源的更多信息，请参阅 `GNU Emacs` 手册中的 `X` 资源。

    Function: x-get-resource attribute class &optional component subclass ¶

函数 `x-get-resource` 从 `X Window` 默认数据库中检索资源值。

资源由键和类的组合来索引。该函数使用 `instance.attribute` 形式的键（其中instance 是调用Emacs 的名称）进行搜索，并使用 `Emacs.class` 作为类。

可选参数组件和子类分别添加到键和类。您必须同时指定它们或都不指定。如果你指定它们，键是'instance.component.attribute'，类是'Emacs.class.subclass'。

    Variable: x-resource-class ¶

此变量指定 `x-get-resource` 应查找的应用程序名称。默认值为 `Emacs` 。您可以通过将此变量绑定到某个其他字符串（围绕对 `x-get-resource` 的调用）来检查其他应用程序名称的 `X` 资源。

    Variable: x-resource-name ¶

此变量指定 `x-get-resource` 应查找的实例名称。默认值是调用 `Emacs` 时使用的名称，或者是使用 `-name` 或 `-rn` 开关指定的值。

为了说明上述一些内容，假设您有以下行：

    xterm.vt100.background: yellow

在您的 `X` 资源文件中（其名称通常为 `/.Xdefaults` 或 `/.Xresources` ）。然后：

    (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
      (x-get-resource "vt100.background" "VT100.Background"))
         ⇒ "yellow"
    
    (let ((x-resource-class "XTerm") (x-resource-name "xterm"))
      (x-get-resource "background" "VT100" "vt100" "Background"))
         ⇒ "yellow"

    Variable: inhibit-x-resources ¶

如果这个变量不为 `nil` ，Emacs 不会查找X 资源，X 资源在创建新帧时没有任何作用。


<a id="orgb89dc2c"></a>

## 30.25 显示功能测试

本节中的功能描述了特定显示器的基本功能。Lisp 程序可以使用它们来调整它们的行为以适应显示器的功能。例如，如果不支持弹出菜单，通常使用弹出菜单的程序可以使用 `minibuffer` 。

这些函数中的可选参数 `display` 指定要询问问题的显示器。它可以是显示名称、帧（指定该帧所在的显示）或 `nil` （表示所选帧的显示，请参阅输入焦点）。

有关获取有关显示信息的其他功能，请参阅颜色名称、文本终端颜色。

    Function: display-popup-menus-p &optional display ¶

如果显示支持弹出菜单，则此函数返回 `t` ，否则返回 `nil` 。对弹出菜单的支持需要鼠标可用，因为在 `Emacs` 显示的某些部分上单击鼠标会弹出菜单。

    Function: display-graphic-p &optional display ¶

如果 `display` 是能够同时显示多个帧和几种不同字体的图形显示，则此函数返回 `t` 。对于使用诸如 `X` 之类的窗口系统的显示器来说是这样，对于文本终端来说是假的。

    Function: display-mouse-p &optional display ¶

如果显示器有鼠标可用，此函数返回 `t` ，否则返回 `nil` 。

    Function: display-color-p &optional display ¶

如果屏幕是彩色屏幕，此函数返回 `t` 。它曾经被称为 `x-display-color-p` ，并且仍然支持该名称作为别名。

    Function: display-grayscale-p &optional display ¶

如果屏幕可以显示灰色阴影，则此函数返回 `t` 。（所有彩色显示器都可以做到这一点。）

    Function: display-supports-face-attributes-p attributes &optional display ¶

如果支持属性中的所有面部属性，则此函数返回非零（请参阅面部属性）。

`支持` 的定义有点启发式，但基本上意味着包含属性中所有属性的面，当与显示的默认面合并时，可以用以下方式表示

外观与默认面不同，并且
在精神上接近属性指定的内容，如果不准确的话。

点 `(2)` 意味着任何可以显示粗体的显示都将满足 `:weight black` 属性，只要可以显示一些淡黄色， `:foreground "yellow"` 也会满足，但是 `tty` 不会满足 `:slant italic` 显示代码自动将暗面替换为斜体。

    Function: display-selections-p &optional display ¶

如果显示支持选择，则此函数返回 `t` 。窗口显示通常支持选择，但在某些其他情况下也可能支持它们。

    Function: display-images-p &optional display ¶

如果 `display` 可以显示图像，此函数返回 `t` 。窗口化显示器原则上应该处理图像，但有些系统缺乏对此的支持。在不支持图像的显示器上，Emacs 无法显示工具栏。

    Function: display-screens &optional display ¶

此函数返回与显示器关联的屏幕数。

    Function: display-pixel-height &optional display ¶

此函数以像素为单位返回屏幕的高度。在字符终端上，它以字符为单位给出高度。

对于图形终端，请注意，在多显示器设置中，这是指与显示器相关的所有物理显示器的像素高度。请参阅多个终端。

    Function: display-pixel-width &optional display ¶

此函数以像素为单位返回屏幕的宽度。在字符终端上，它以字符为单位给出宽度。

对于图形终端，请注意，在多显示器设置中，这是指与显示器相关的所有物理显示器的像素宽度。请参阅多个终端。

    Function: display-mm-height &optional display ¶

此函数以毫米为单位返回屏幕高度，如果 `Emacs` 无法获取该信息，则返回 `nil` 。

对于图形终端，请注意，在多显示器设置中，这是指与显示器相关的所有物理显示器的高度。请参阅多个终端。

    Function: display-mm-width &optional display ¶

此函数以毫米为单位返回屏幕宽度，如果 `Emacs` 无法获取该信息，则返回 `nil` 。

对于图形终端，请注意，在多显示器设置中，这是指与显示器相关的所有物理显示器的宽度。请参阅多个终端。

    User Option: display-mm-dimensions-alist ¶

此变量允许用户指定 `display-mm-height` 和 `display-mm-width` 返回的图形显示的尺寸，以防系统提供不正确的值。

    Function: display-backing-store &optional display ¶

此函数返回显示器的后备存储功能。后备存储是指记录未曝光的窗口（和部分窗口）的像素，以便在曝光时可以非常快速地显示出来。

值可以是始终、映射时或无用的符号。当问题不适用于某种显示时，该函数也可以返回 `nil` 。

    Function: display-save-under &optional display ¶

如果显示器支持 `SaveUnder` 功能，则此函数返回非 `nil` 。弹出窗口使用该功能来保存它们模糊的像素，以便它们可以快速弹出。

    Function: display-planes &optional display ¶

此函数返回显示器支持的平面数。这通常是每个像素的位数。对于 `tty` 显示，它以支持的颜色数中的两个为基数。

    Function: display-visual-class &optional display ¶

此函数返回屏幕的视觉类。该值是以下符号之一：static-gray（有限的、不可改变的灰度）、gray-scale（全范围的灰度）、static-color（有限的、不可改变的颜色）、pseudo-color（有限的颜色）、真彩色（全系列颜色）和直接彩色（全系列颜色）。

    Function: display-color-cells &optional display ¶

此函数返回屏幕支持的颜色单元数。

这些函数获取有关 `Emacs` 显示指定显示的正在使用的窗口系统的附加信息。（出于历史原因，它们的名称以 `x-` 开头。）

    Function: x-server-version &optional display ¶

该函数返回在显示器上运行的 `GUI` 窗口系统的版本号列表，例如 `GNU` 和 `Unix` 系统上的 `X` 服务器。该值是一个由三个整数组成的列表：协议的主要版本号和次要版本号，以及窗口系统软件本身的特定于发行商的版本号。在 `GNU` 和 `Unix` 系统上，这些通常是 `X` 协议的版本和 `X` 服务器软件的发行商特定的版本号。在 `MS-Windows` 上，这是 `Windows` 操作系统的版本。

    Function: x-server-vendor &optional display ¶

此函数返回提供窗口系统软件的供应商（作为字符串）。在 `GNU` 和 `Unix` 系统上，这实际上意味着分发 `X` 服务器的人。在 `MS-Windows` 上，这是 `Windows` 操作系统 `(Microsoft)` 的供应商 `ID` 字符串。

当 `X` 的开发人员将软件分销商标记为 `供应商` 时，他们表明了他们的错误假设，即任何系统都不能以非商业方式开发和分发。

