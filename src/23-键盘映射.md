# 23 键盘映射

输入事件的命令绑定记录在称为键映射的数据结构中。键盘映射中的每个条目将单个事件类型关联（或绑定）到另一个键盘映射或命令。当一个事件类型绑定到一个键映射时，该键映射用于查找下一个输入事件； ~ 这一直持续到找到命令为止。整个过程称为键查找。


<a id="orge9efa85"></a>

## 23.1 按键序列

键序列，或简称键，是一个或多个输入事件的序列，它们构成一个单元。输入事件包括字符、功能键、鼠标操作或 `Emacs` 外部的系统事件，例如 `iconify-frame` （请参阅输入事件）。键序列的 `Emacs Lisp` 表示是字符串或向量。除非另有说明，否则任何接受键序列作为参数的 `Emacs Lisp` 函数都可以处理这两种表示。

在字符串表示中，字母数字字符通常代表它们自己；例如， `a` 代表a， `2` 代表2。控制字符事件以子字符串 `\C-` 为前缀，元字符以 `\M-` 为前缀；例如， `\Cx` 表示键 `Cx` 。此外，TAB、RET、ESC 和 `DEL` 事件分别用 `\t` 、 `\r` 、 `\e` 和 `\d` 表示。完整键序列的字符串表示是组成事件的字符串表示的串联；因此， `\C-xl` 表示密钥序列 `Cxl` 。

包含功能键、鼠标按钮事件、系统事件或非 `ASCII` 字符（如 `C-=` 或 `Ha` ）的键序列不能表示为字符串；它们必须表示为向量。

在向量表示中，向量的每个元素都以 `Lisp` 形式表示一个输入事件。请参阅输入事件。例如，向量 `[?\Cx ?l]` 表示密钥序列 `Cx l` 。

有关以字符串和向量表示形式编写的键序列的示例，请参阅 `The GNU Emacs Manual` 中的 `Init Rebinding` 。

    Function: kbd keyseq-text ¶

此函数将文本 `keyseq-text` （字符串常量）转换为键序列（字符串或向量常量）。keyseq-text 的内容应该使用与 `Cx Ck RET (kmacro-edit-macro)` 命令调用的缓冲区中相同的语法；特别是，您必须用 `<` …>~ 将功能键名称括起来。请参阅 `GNU Emacs` 手册中的编辑键盘宏。

    (kbd "C-x") ⇒ "\C-x"
    (kbd "C-x C-f") ⇒ "\C-x\C-f"
    (kbd "C-x 4 C-f") ⇒ "\C-x4\C-f"
    (kbd "X") ⇒ "X"
    (kbd "RET") ⇒ "\^M"
    (kbd "C-c SPC") ⇒ "\C-c "
    (kbd "<f1> SPC") ⇒ [f1 32]
    (kbd "C-M-<down>") ⇒ [C-M-down]


<a id="orge19675d"></a>

## 23.2 键盘映射基础

键映射是一种 `Lisp` 数据结构，它为各种键序列指定键绑定。

单个键映射直接指定各个事件的定义。当键序列由单个事件组成时，它在键映射中的绑定就是该事件的键映射定义。一个较长的键序列的绑定是通过一个迭代过程找到的：首先找到第一个事件的定义（它本身必须是一个键映射）；然后在该键映射中找到第二个事件的定义，依此类推，直到键序列中的所有事件都已被处理。

如果键序列的绑定是一个键映射，我们称该键序列为前缀键。否则，我们称它为一个完整的键（因为它不能再添加任何事件）。如果绑定为 `nil` ，我们称键未定义。前缀键的示例是 `Cc` 、Cx 和 `Cx 4` 。定义的完整键的示例是 `X` 、RET 和 `Cx 4 Cf` 。未定义的完整键的示例是 `Cx Cg` 和 `Cc 3` 。有关详细信息，请参阅前缀键。

查找键序列绑定的规则假定中间绑定（为最后一个事件之前的事件找到）都是键映射；如果不是这样，则事件序列不会形成一个单元——它实际上不是一个键序列。换句话说，从任何有效键序列的末尾删除一个或多个事件必须始终产生一个前缀键。例如，Cf Cn 不是键序列；Cf 不是前缀键，因此以 `Cf` 开头的较长序列不能是键序列。

可能的多事件键序列集取决于前缀键的绑定；因此，不同的键盘映射可能会有所不同，并且可以在更改绑定时更改。但是，单事件序列始终是键序列，因为它的格式良好不依赖于任何前缀键。

在任何时候，都有几个主键映射处于活动状态，即用于查找键绑定。这些是全局映射，由所有缓冲区共享；本地键盘映射，通常与特定的主要模式相关联；和零个或多个次要模式键盘映射，它们属于当前启用的次要模式。（并非所有次要模式都有键映射。）本地键映射绑定会影响（即优先于）相应的全局绑定。次要模式键映射会影响本地和全局键映射。有关详细信息，请参阅活动键盘映射。


<a id="orgcd02840"></a>

## 23.3 键盘映射格式

每个键映射是一个列表，其 `CAR` 是符号键映射。列表的其余元素定义键映射的键绑定。功能定义为键映射的符号也是键映射。使用函数 `keymapp` （见下文）来测试一个对象是否是一个键盘映射。

几种元素可能会出现在一个键映射中，在开始它的符号键映射之后：

    (type . binding)

这为类型类型的事件指定了一个绑定。每个普通绑定都适用于特定事件类型的事件，该事件类型始终是字符或符号。请参阅分类事件。在这种绑定中，绑定是一个命令。

    (type item-name . binding)

这指定了一个绑定，它也是一个简单的菜单项，在菜单中显示为 `item-name` 。请参阅简单菜单项。

    (type item-name help-string . binding)

这是一个带有帮助字符串 `help-string` 的简单菜单项。

    (type menu-item . details)

这指定了一个绑定，它也是一个扩展的菜单项。这允许使用其他功能。请参阅扩展菜单项。

    (t . binding) ¶

这指定了一个默认的键绑定；任何不受键映射其他元素绑定的事件都被赋予绑定作为其绑定。默认绑定允许键映射绑定所有可能的事件类型，而不必枚举所有事件类型。具有默认绑定的键映射完全屏蔽任何较低优先级的键映射，但显式绑定到 `nil`  的事件除外（见下文）。

    char-table

如果 `keymap` 的元素是 `char-table` ，则它被视为持有所有没有修饰符位的字符事件的绑定（请参阅修饰符位）：索引为 `c` 的元素是字符 `c` 的绑定。这是一种记录大量绑定的紧凑方式。具有这种字符表的键映射称为完整键映射。其他键映射称为稀疏键映射。

    vector

这种元素类似于 `char-table` ：索引为 `c` 的元素是字符 `c` 的绑定。由于可以以这种方式绑定的字符范围受向量大小的限制，并且向量创建为从 `0` 开始的所有字符代码分配空间，因此不应使用这种格式，除非创建菜单键映射（请参阅菜单键映射），其中绑定本身并不重要。

    string ¶

除了为键指定绑定的元素外，键映射还可以将字符串作为元素。这称为整体提示字符串，可以将键盘映射用作菜单。请参阅定义菜单。

    (keymap …)

如果一个键映射的元素本身就是一个键映射，那么它就好像这个内部键映射被内联在外部键映射中一样。这用于多重继承，例如在 `make-composed-keymap` 中。

当绑定为 `nil`  时，它不构成定义，但它确实优先于默认绑定或父键映射中的绑定。另一方面， `nil`  的绑定不会覆盖优先级较低的键映射；因此，如果本地映射提供 `nil`  绑定，Emacs 将使用来自全局映射的绑定。

键映射不直接记录元字符的绑定。取而代之的是，元字符在键查找时被视为两个字符的序列，其中第一个字符是 `ESC` （或任何当前元前缀字符的值）。因此，键 `Ma` 在内部表示为 `ESCa` ，并且它的全局绑定在 `esc-map` 中的 `a` 插槽中找到（请参阅前缀键）。

此转换仅适用于字符，不适用于功能键或其他输入事件；因此，M端与ESC端无关。

这里以 `Lisp` 模式的本地键映射为例，一个稀疏键映射。它定义了 `DEL` 、Cc Cz、CMq 和 `CMx` 的绑定（实际值还包含菜单绑定，为简洁起见，此处省略）。

    lisp-mode-map
    ⇒
    
    (keymap
     (3 keymap
        ;; C-c C-z
        (26 . run-lisp))
    
     (27 keymap
         ;; C-M-x, treated as ESC C-x
         (24 . lisp-send-defun))
    
     ;; This part is inherited from lisp-mode-shared-map.
     keymap
     ;; DEL
     (127 . backward-delete-char-untabify)
    
     (27 keymap
         ;; C-M-q, treated as ESC C-q
         (17 . indent-sexp)))

    Function: keymapp object ¶

如果 `object` 是 `keymap` ，则此函数返回 `t` ，否则返回 `nil` 。更准确地说，此函数测试其 `CAR` 为 `keymap` 的列表，或测试其函数定义满足 `keymapp` 的符号。

    (keymapp '(keymap))
        ⇒ t
    
    (fset 'foo '(keymap))
    (keymapp 'foo)
        ⇒ t
    
    (keymapp (current-global-map))
        ⇒ t


<a id="orgb2f3448"></a>

## 23.4 创建键盘映射

在这里，我们描述了创建键盘映射的功能。

    Function: make-sparse-keymap &optional prompt ¶

此函数创建并返回一个没有条目的新稀疏键盘映射。（稀疏键映射是您通常想要的那种键映射。）与 `make-keymap` 不同，新的键映射不包含字符表，并且不绑定任何事件。

    (make-sparse-keymap)
        ⇒ (keymap)

如果您指定提示，它将成为键盘映射的整体提示字符串。您应该只为菜单键映射指定此项（请参阅定义菜单）。具有整体提示字符串的键盘映射将始终显示鼠标菜单或键盘菜单，如果它处于活动状态以查找下一个输入事件。不要为主要或次要模式的主映射指定整体提示字符串，因为这会导致命令循环每次都显示键盘菜单。

    Function: make-keymap &optional prompt ¶

此函数创建并返回一个新的完整键盘映射。该键映射包含一个字符表（请参阅字符表），其中包含所有字符的插槽，没有修饰符。新的键盘映射最初将所有这些字符绑定到 `nil` ，并且不绑定任何其他类型的事件。参数 `prompt` 指定一个提示字符串，如 `make-sparse-keymap` 中一样。

    (make-keymap)
        ⇒ (keymap #^[nil nil keymap nil nil nil …])

当拥有大量绑定时，完整的键映射比稀疏键映射更有效；对于少数人来说，稀疏键映射更好。

    Function: copy-keymap keymap ¶

此函数返回键盘映射的副本。这几乎不需要。如果您想要一个与另一个类似但有一些更改的键映射，您应该使用映射继承而不是复制。即，类似：

    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map <theirmap>)
      (define-key map ...)
      ...)

执行复制键映射时，任何直接作为绑定出现在键映射中的键映射也被递归地复制，依此类推到任意数量的级别。但是，当字符的定义是一个符号，其功能定义是一个键映射时，递归复制不会发生；相同的符号出现在新副本中。

    (setq map (copy-keymap (current-local-map)))
    ⇒ (keymap
    
         ;; (This implements meta characters.)
         (27 keymap
    	 (83 . center-paragraph)
    	 (115 . center-line))
         (9 . tab-to-tab-stop))
    
    
    (eq map (current-local-map))
        ⇒ nil
    
    (equal map (current-local-map))
        ⇒ t


<a id="org8f907ca"></a>

## 23.5 继承和键映射

一个键映射可以继承另一个键映射的绑定，我们称之为父键映射。这样的键盘映射如下所示：

    (keymap elements… ~. parent-keymap)

~ 效果是这个键映射继承了父键映射的所有绑定，无论它们在查找键时可能是什么，但可以添加到它们或用元素覆盖它们。

如果您使用 `define-key` 或其他键绑定函数更改父键映射中的绑定，则这些更改的绑定在继承键映射中可见，除非被元素所做的绑定遮蔽。反之则不然：如果您使用 `define-key` 更改继承键映射中的绑定，这些更改会记录在元素中，但对父键映射没有影响。

使用父级构造键映射的正确方法是使用 `set-keymap-parent` ；如果您有直接使用父级构造键映射的代码，请将程序转换为使用 `set-keymap-parent` 。

    Function: keymap-parent keymap ¶

这将返回 `keymap` 的父 `keymap` 。如果 `keymap` 没有父级，则 `keymap-parent` 返回 `nil` 。

    Function: set-keymap-parent keymap parent ¶

这会将 `keymap` 的父 `keymap` 设置为 `parent` ，并返回 `parent` 。如果 `parent` 为 `nil` ，则此函数根本没有给 `keymap` 提供父级。

如果键映射具有子映射（前缀键的绑定），它们也会收到新的父键映射，这些键映射反映了父为这些前缀键指定的内容。

下面是一个示例，展示了如何创建一个继承自 `text-mode-map` 的键盘映射：

    (let ((map (make-sparse-keymap)))
      (set-keymap-parent map text-mode-map)
      map)

非稀疏键映射也可以有父级，但这不是很有用。非稀疏键映射总是为每个没有修饰符位的数字字符代码指定一些绑定，即使它是 `nil` ，所以这些字符的绑定永远不会从父键映射继承。

有时你想创建一个从多个地图继承的键映射。您可以为此使用函数 `make-composed-keymap` 。

    Function: make-composed-keymap maps &optional parent ¶

此函数返回一个由现有键映射映射组成的新键映射，并且可以选择从父键映射父级继承。maps 可以是单个 `keymap` 或多个列表。在生成的新映射中查找键时，Emacs 依次在每个映射中搜索，然后在父映射中搜索，在第一个匹配时停止。任何一个映射中的 `nil`  绑定都会覆盖父映射中的任何绑定，但它不会覆盖任何其他映射中的任何非 `nil`  绑定。

例如，这里是 `Emacs` 如何设置 `help-mode-map` 的父级，以便它继承自 `button-buffer-map` 和 `special-mode-map` ：

    (defvar help-mode-map
      (let ((map (make-sparse-keymap)))
        (set-keymap-parent map
          (make-composed-keymap button-buffer-map special-mode-map))
        ... map) ... )


<a id="org6cac941"></a>

## 23.6 前缀键

前缀键是一个键序列，其绑定是一个键映射。键映射定义了如何处理扩展前缀键的键序列。例如，Cx 是一个前缀键，它使用一个也存储在变量 `ctl-x-map` 中的键映射。此键映射定义以 `Cx` 开头的键序列的绑定。

一些标准的 `Emacs` 前缀键使用也可以在 `Lisp` 变量中找到的键映射：

1.  esc-map 是 `ESC` 前缀键的全局键映射。因此，所有元字符的全局定义实际上都可以在这里找到。这个映射也是ESC-prefix的函数定义。
2.  help-map 是 `Ch` 前缀键的全局键映射。
3.  mode-specific-map 是前缀键 `Cc` 的全局键映射。这个映射实际上是全局的，而不是特定于模式的，但它的名称在 `Ch b` （显示绑定）的输出中提供了有关 `Cc` 的有用信息，因为此前缀键的主要用途是用于特定于模式的绑定。
4.  ctl-x-map 是用于 `Cx` 前缀键的全局键映射。该映射是通过符号 `Control-X-prefix` 的功能单元找到的。
5.  mule-keymap 是用于 `Cx RET` 前缀键的全局键映射。
6.  ctl-x-4-map 是用于 `Cx 4` 前缀键的全局键映射。
7.  ctl-x-5-map 是用于 `Cx 5` 前缀键的全局键映射。
8.  2C-mode-map 是用于 `Cx 6` 前缀键的全局键映射。
9.  tab-prefix-map 是用于 `Cx t` 前缀键的全局键映射。
10. vc-prefix-map 是用于 `Cx v` 前缀键的全局键映射。
11. goto-map 是用于 `Mg` 前缀键的全局键映射。
12. search-map 是用于 `Ms` 前缀键的全局键映射。
13. 其他 `Emacs` 前缀键是 `Cx @` 、Cx ai、Cx ESC 和 `ESC ESC` 。他们使用没有特殊名称的键盘映射。

前缀键的键映射绑定用于查找前缀键之后的事件。（它可能是一个符号，其功能定义是一个键映射。效果是一样的，但符号用作前缀键的名称。）因此，Cx的绑定是符号Control-X-prefix，其功能单元格保存 `Cx` 命令的键盘映射。（同样的keymap也是ctl-x-map的值。）

前缀键定义可以出现在任何活动的键盘映射中。Cc、Cx、Ch 和 `ESC` 作为前缀键的定义出现在全局映射中，因此这些前缀键始终可用。主要和次要模式可以通过在本地映射或次要模式的映射中放置前缀键定义来将键重新定义为前缀。请参阅活动键盘映射。

如果一个键在多个活动映射中被定义为前缀，那么它的各种定义实际上是合并的：在次要模式键映射中定义的命令首先出现，然后是本地映射前缀定义中的命令，然后是来自全球地图。

在下面的示例中，我们将 `Cp` 作为本地键映射中的前缀键，这样 `Cp` 与 `Cx` 相同。那么 `Cp Cf` 的绑定就是函数 `find-file` ，就像 `Cx Cf` 一样。在任何活动键映射中都找不到键序列 `Cp 6` 。

    (use-local-map (make-sparse-keymap))
        ⇒ nil
    
    (local-set-key "\C-p" ctl-x-map)
        ⇒ nil
    
    (key-binding "\C-p\C-f")
        ⇒ find-file
    
    
    (key-binding "\C-p6")
        ⇒ nil

    Function: define-prefix-command symbol &optional mapvar prompt ¶

此函数准备用作前缀键绑定的符号：它创建一个稀疏键映射并将其存储为符号的函数定义。随后将键序列绑定到符号将使该键序列成为前缀键。返回值是符号。

此函数还将符号设置为变量，键映射为其值。但如果 `mapvar` 不是 `nil` ，它会将 `mapvar` 设置为变量。

如果 `prompt` 不为 `nil` ，则它将成为键盘映射的整体提示字符串。应为菜单键映射提供提示字符串（请参阅定义菜单）。


<a id="org6e74fd3"></a>

## 23.7 活动键盘映射

Emacs 包含许多键盘映射，但在任何时候只有少数键盘映射处于活动状态。当 `Emacs` 接收到用户输入时，它会转换输入事件（请参阅 `Keymaps` 以了解转换事件序列），并在活动键盘映射中查找键绑定。

通常，活动的键盘映射是：(i) 由 `keymap` 属性指定的键盘映射，(ii) 启用的次要模式的键盘映射，(iii) 当前缓冲区的本地键盘映射，以及 `(iv)` 全局键盘映射，按此顺序。Emacs 在所有这些键映射中搜索每个输入键序列。

在这些常用的键映射中，优先级最高的键映射由点处的键映射文本或覆盖属性（如果有）指定。（对于鼠标输入事件，Emacs 使用事件位置而不是点；请参阅搜索活动键盘映射。）

下一个优先级是由启用的次要模式指定的键盘映射。这些键映射（如果有）由变量 `emulation-mode-map-alist` 、minor-mode-overriding-map-alist 和 `minor-mode-map-alist` 指定。请参阅控制活动键盘映射。

下一个优先级是缓冲区的本地键映射，包含特定于缓冲区的键绑定。minibuffer 也有一个本地键映射（参见 `Minibuffers` 简介）。如果点有本地映射文本或覆盖属性，则指定要使用的本地键映射，以代替缓冲区的默认本地键映射。

本地键映射通常由缓冲区的主模式设置，并且具有相同主模式的每个缓冲区共享相同的本地键映射。因此，如果您调用 `local-set-key` （请参阅绑定键的命令）来更改一个缓冲区中的本地键盘映射，这也会影响具有相同主要模式的其他缓冲区中的本地键盘映射。

最后，全局键映射包含定义与当前缓冲区无关的键绑定，例如 `Cf` 。它始终处于活动状态，并绑定到变量 `global-map` 。

除了上述常用的键盘映射外，Emacs 还为程序提供了特殊的方法来激活其他键盘映射。首先，变量overriding-local-map 指定了一个替换通常的活动键映射的键映射，除了全局键映射。其次，终端局部变量 `overriding-terminal-local-map` 指定优先于所有其他键映射（包括覆盖本地映射）的键映射；这通常用于模态/瞬态键绑定（函数 `set-transient-map` 为此提供了一个方便的接口）。有关详细信息，请参阅控制活动键盘映射。

激活键盘映射并不是使用它们的唯一方法。键映射也用于其他方式，例如用于翻译读取键序列中的事件。请参阅用于翻译事件序列的键映射。

有关一些标准键盘映射的列表，请参阅标准键盘映射。

    Function: current-active-maps &optional olp position ¶

这将返回当前情况下命令循环将使用的活动键映射列表来查找键序列。通常它会忽略覆盖本地映射和覆盖终端本地映射，但如果 `olp` 不为零，那么它会注意它们。position 可以选择是 `event-start` 返回的事件位置或缓冲区位置，并且可以更改键映射描述的键绑定。

    Function: key-binding key &optional accept-defaults no-remap position ¶

此函数根据当前活动的键映射返回键的绑定。如果键映射中未定义键，则结果为零。

参数accept-defaults 控制检查默认绑定，如lookup-key（请参阅Key Lookup 函数）。

当命令被重新映射时（参见重新映射命令），键绑定通常会处理命令重新映射，以便返回实际执行的重新映射命令。但是，如果 `no-remap` 不为零，则键绑定会忽略重新映射并返回直接为键指定的绑定。

如果键以鼠标事件开始（可能在前缀事件之后），则要查阅的地图是根据事件的位置确定的。否则，它们是根据点的值确定的。但是，您可以通过指定位置来覆盖它们中的任何一个。如果位置不是零，它应该是缓冲区位置或事件位置，如 `event-start` 的值。然后根据位置确定参考的地图。

如果 `key` 不是字符串或向量，Emacs 会发出错误信号。

    (key-binding "\C-x\C-f")
        ⇒ find-file


<a id="org321f25d"></a>

## 23.8 搜索活动键盘映射

这是 `Emacs` 如何搜索活动键盘映射的伪 `Lisp` 总结：

    (or (if overriding-terminal-local-map
    	(find-in overriding-terminal-local-map))
        (if overriding-local-map
    	(find-in overriding-local-map)
          (or (find-in (get-char-property (point) 'keymap))
    	  (find-in-any emulation-mode-map-alists)
    	  (find-in-any minor-mode-overriding-map-alist)
    	  (find-in-any minor-mode-map-alist)
    	  (if (get-text-property (point) 'local-map)
    	      (find-in (get-char-property (point) 'local-map))
    	    (find-in (current-local-map)))))
        (find-in (current-global-map)))

在这里，find-in 和 `find-in-any` 是伪函数，它们分别在一个键映射和键映射列表中进行搜索。请注意，set-transient-map 函数通过设置覆盖终端本地映射来工作（请参阅控制活动键盘映射）。

在上面的伪代码中，如果按键序列以鼠标事件（请参阅鼠标事件）开始，则使用该事件的位置而不是点，并且使用事件的缓冲区而不是当前缓冲区。特别是，这会影响键映射和本地映射属性的查找方式。如果鼠标事件发生在嵌入了 `display` 、before-string 或 `after-string` 属性的字符串上（请参阅具有特殊含义的属性），并且该字符串具有非 `nil`  键映射或本地映射属性，它会覆盖相应的属性在底层缓冲区文本中（即，底层文本指定的属性被忽略）。

当在其中一个活动键映射中找到键绑定，并且该绑定是命令时，搜索结束——命令被执行。但是，如果绑定是带有值或字符串的符号，Emacs 会用变量的值或字符串替换输入的键序列，并重新开始搜索活动的键映射。请参阅密钥查找。

最后找到的命令也可能被重新映射。请参阅重新映射命令。


<a id="orge726cb8"></a>

## 23.9 控制激活的键盘映射

    Variable: global-map ¶

此变量包含将 `Emacs` 键盘输入映射到命令的默认全局键盘映射。全局键映射通常是这个键映射。默认的全局键映射是一个完整的键映射，它将 `self-insert-command` 绑定到所有打印字符。

通常的做法是更改全局键映射中的绑定，但不应为该变量分配除它开始时使用的键映射之外的任何值。

    Function: current-global-map ¶

此函数返回当前的全局键盘映射。这与 `global-map` 的值相同，除非您更改其中一个。返回值是一个引用，而不是一个副本；如果您在其上使用 `define-key` 或其他功能，您将更改全局绑定。

    
    
    (current-global-map)
    ⇒ (keymap [set-mark-command beginning-of-line …
    	    delete-backward-char])

    Function: current-local-map ¶

此函数返回当前缓冲区的本地键盘映射，如果没有则返回 `nil` 。在以下示例中，\*scratch\* 缓冲区的键映射（使用 `Lisp` 交互模式）是一个稀疏键映射，其中 `ESC` 的条目 `ASCII` 代码 `27` 是另一个稀疏键映射。

    
    
    (current-local-map)
    ⇒ (keymap
        (10 . eval-print-last-sexp)
        (9 . lisp-indent-line)
        (127 . backward-delete-char-untabify)
    
        (27 keymap
    	(24 . eval-defun)
    	(17 . indent-sexp)))

current-local-map 返回对本地键盘映射的引用，而不是它的副本；如果您在其上使用 `define-key` 或其他功能，您将更改本地绑定。

    Function: current-minor-mode-maps ¶

此函数返回当前启用的次要模式的键盘映射列表。

    Function: use-global-map keymap ¶

此函数使键映射成为新的当前全局键映射。它返回零。

更改全局键映射是非常不寻常的。

    Function: use-local-map keymap ¶

此函数使 `keymap` 成为当前缓冲区的新本地 `keymap` 。如果 `keymap` 为 `nil` ，则缓冲区没有本地 `keymap` 。use-local-map 返回 `nil` 。大多数主要模式命令都使用此功能。

    Variable: minor-mode-map-alist ¶

这个变量是一个列表，描述了根据某些变量的值可能会或可能不会被激活的键映射。它的元素如下所示：

    (variable . keymap)

每当变量具有非零值时，键映射键映射都是活动的。通常变量是启用或禁用次要模式的变量。请参阅键盘映射和次要模式。

请注意，minor-mode-map-alist 的元素与 `minor-mode-alist` 的元素的结构不同。map必须是元素的CDR；将地图作为第二个元素的列表是行不通的。CDR 可以是键映射（列表）或功能定义为键映射的符号。

当多个次要模式键映射处于活动状态时，次要模式映射列表中较早的一个优先。但是您应该设计次要模式，以便它们不会相互干扰。如果您正确执行此操作，则顺序将无关紧要。

有关次要模式的更多信息，请参阅键盘映射和次要模式。另请参阅次要模式键绑定（请参阅键查找函数）。

    Variable: minor-mode-overriding-map-alist ¶

此变量允许主要模式覆盖特定次要模式的键绑定。这个 `alist` 的元素看起来像 `minor-mode-map-alist` 的元素：（变量 `.keymap` ）。

如果变量显示为 `minor-mode-overriding-map-alist` 的元素，则该元素指定的映射完全替换为 `minor-mode-map-alist` 中相同变量指定的任何映射。

minor-mode-overriding-map-alist 在所有缓冲区中自动为缓冲区本地。

    Variable: overriding-local-map ¶

如果非零，则此变量保存要使用的键映射，而不是缓冲区的本地键映射、任何文本属性或覆盖键映射以及任何次要模式键映射。此键映射（如果指定）将覆盖所有其他可能处于活动状态的映射，当前全局映射除外。

    Variable: overriding-terminal-local-map ¶

如果非零，则此变量保存要使用的键映射，而不是覆盖本地映射、缓冲区的本地键映射、文本属性或覆盖键映射以及所有次要模式键映射。

此变量始终是当前终端的本地变量，不能是缓冲区本地的。请参阅多个终端。用于实现增量搜索模式。

    Variable: overriding-local-map-menu-flag ¶

如果此变量非零，overriding-local-map 或 `overriding-terminal-local-map` 的值会影响菜单栏的显示。默认值为 `nil` ，因此这些地图变量对菜单栏没有影响。

请注意，这两个映射变量确实会影响使用菜单栏输入的键序列的执行，即使它们不影响菜单栏的显示。因此，如果出现菜单栏键序列，则应在查找和执行该键序列之前清除变量。无论如何，使用变量的模式通常都会这样做；通常，他们通过 `未读` 并退出来响应他们不处理的事件。

    Variable: special-event-map ¶

此变量保存特殊事件的键映射。如果一个事件类型在这个 `keymap` 中有一个绑定，那么它是特殊的，并且该事件的绑定直接由 `read-event` 运行。请参阅特别活动。

    Variable: emulation-mode-map-alists ¶

此变量保存用于仿真模式的键盘映射列表列表。它适用于使用多个次要模式键盘映射的模式或包。每个元素都是一个keymap alist，其格式和含义与minor-mode-map-alist 相同，或者是一个带有变量绑定的符号，就是这样一个alist。每个 `alist` 中的活动键映射在 `minor-mode-map-alist` 和 `minor-mode-overriding-map-alist` 之前使用。

    Function: set-transient-map keymap &optional keep-pred on-exit ¶

此函数将键映射添加为临时键映射，对于一个（或多个）后续键，它优先于其他键映射。

通常，keymap 只使用一次，以查找下一个键。如果可选参数 `keep-pred` 为 `t` ，只要用户键入 `keymap` 中定义的键，映射就会保持活动状态；当用户键入不在键映射中的键时，临时键映射将被停用，并继续对该键进行正常键查找。

keep-pred 参数也可以是一个函数。在这种情况下，在运行每个命令之前调用不带参数的函数，而键盘映射处于活动状态；如果键映射应该保持活动状态，它应该返回非零。

退出时的可选参数，如果非零，则指定在停用键盘映射后调用的不带参数的函数。

此函数通过从变量 `overriding-terminal-local-map` 中添加和删除键盘映射来工作，该变量优先于所有其他活动键盘映射（请参阅搜索活动键盘映射）。


<a id="org68057c8"></a>

## 23.10 密钥查找

键查找是从给定键映射中查找键序列绑定的过程。绑定的执行或使用不是键查找的一部分。

键查找仅使用键序列中每个事件的事件类型；事件的其余部分被忽略。事实上，用于键查找的键序列可以仅用它的类型（一个符号）而不是整个事件（一个列表）来指定一个鼠标事件。请参阅输入事件。这样的键序列不足以运行命令执行，但足以查找或重新绑定键。

当key序列由多个事件组成时，key lookup依次处理事件：找到第一个事件的绑定，必须是keymap；然后在该键映射中找到第二个事件的绑定，依此类推，直到键序列中的所有事件都用完。（因此为最后一个事件找到的绑定可能是也可能不是键映射。）因此，键查找的过程是根据在键映射中查找单个事件的更简单过程来定义的。如何完成取决于与该键映射中的事件关联的对象类型。

让我们使用术语键映射条目来描述通过在键映射中查找事件类型找到的值。（这不包括菜单项的键映射元素中的项字符串和其他额外元素，因为查找键和其他键查找函数不将它们包含在返回值中。）虽然任何 `Lisp` 对象都可以存储在一个键映射作为一个键映射条目，并不是所有的键查找都有意义。以下是有意义的键盘映射条目类型的表格：

    nil ¶

`nil`  表示到目前为止在查找中使用的事件形成了一个未定义的键。当 `keymap` 根本没有提及事件类型并且没有默认绑定时，这等效于该事件类型的 `nil`  绑定。

    command ¶

到目前为止在查找中使用的事件形成了一个完整的键，命令是它的绑定。请参阅什么是函数？

    array ¶

数组（字符串或向量）是键盘宏。到目前为止在查找中使用的事件形成了一个完整的键，而数组是它的绑定。有关详细信息，请参阅键盘宏。

    keymap ¶

到目前为止在查找中使用的事件形成前缀键。在 `keymap` 中查找键序列的下一个事件。

    list ¶

列表的含义取决于它包含的内容：

如果列表的 `CAR` 是符号键映射，则列表是键映射，并被视为键映射（见上文）。
如果列表的 `CAR` 是 `lambda` ，则列表是 `lambda` 表达式。这被假定为一个函数，并被视为这样（见上文）。为了作为键绑定正确执行，这个函数必须是一个命令——它必须有一个交互式规范。请参阅定义命令。

    symbol ¶

使用符号的函数定义代替符号。如果这也是一个符号，那么这个过程会重复任意次。最终，这将导致一个对象是键盘映射、命令或键盘宏。

请注意，键盘映射和键盘宏（字符串和向量）不是有效的函数，因此以键盘映射、字符串或向量作为其函数定义的符号作为函数是无效的。但是，它作为键绑定是有效的。如果定义是键盘宏，则该符号也可作为命令执行的参数有效（请参阅交互式调用）。

符号 `undefined` 值得特别一提：它表示将键视为未定义。严格来说，key是定义好的，它的绑定就是命令undefined；但是该命令执行与未定义键自动执行的相同操作：它响铃（通过调用 `ding` ）但不表示错误。

undefined 用于本地键映射以覆盖全局键绑定并使键在本地未定义。 `nil` ~ 的本地绑定将无法做到这一点，因为它不会覆盖全局绑定。

    anything else

如果找到任何其他类型的对象，则到目前为止在查找中使用的事件形成一个完整的键，并且该对象是它的绑定，但该绑定不能作为命令执行。

简而言之，键映射条目可以是键映射、命令、键盘宏、通向其中之一的符号或 `nil` 。


<a id="org05753be"></a>

## 23.11 键查找函数

以下是与键查找有关的函数和变量。

    Function: lookup-key keymap key &optional accept-defaults ¶

此函数返回 `keymap` 中键的定义。本章描述的所有其他查找键的函数都使用查找键。以下是示例：

    
    
    (lookup-key (current-global-map) "\C-x\C-f")
        ⇒ find-file
    
    (lookup-key (current-global-map) (kbd "C-x C-f"))
        ⇒ find-file
    
    (lookup-key (current-global-map) "\C-x\C-f12345")
        ⇒ 2

如果根据 `keymap` 中指定的前缀键，字符串或向量键不是有效的键序列，则它必须太长并且末尾有额外的事件不适合单个键序列。然后 `value` 是一个数字，即构成完整 `key` 的 `key` 前面的事件数。

如果accept-defaults 不为 `nil` ，则lookup-key 会考虑默认绑定以及key 中特定事件的绑定。否则，lookup-key 仅报告特定序列键的绑定，忽略默认绑定，除非您明确询问它们。（为此，提供 `t` 作为 `key` 的元素；请参阅 `Keymap` 的格式。）

如果 `key` 包含元字符（不是功能键），则该字符隐式替换为两个字符序列：元前缀字符的值，后跟相应的非元字符。因此，下面的第一个示例通过转换为第二个示例来处理。

    
    
    (lookup-key (current-global-map) "\M-f")
        ⇒ forward-word
    
    (lookup-key (current-global-map) "\ef")
        ⇒ forward-word

键映射参数也可以是键映射列表。

与 `read-key-sequence` 不同，此函数不会以丢弃信息的方式修改指定的事件（请参阅 `Key Sequence Input` ）。特别是，它不会将字母转换为小写，也不会将拖动事件更改为单击。

    Command: undefined ¶

用于键映射以取消定义键。它调用 `ding` ，但不会导致错误。

    Function: local-key-binding key &optional accept-defaults ¶

此函数返回当前本地键映射中键的绑定，如果未定义，则返回 `nil` 。

参数accept-defaults 控制检查默认绑定，如lookup-key（上图）。

    Function: global-key-binding key &optional accept-defaults ¶

此函数返回当前全局键映射中命令键的绑定，如果在那里未定义，则返回 `nil` 。

参数accept-defaults 控制检查默认绑定，如lookup-key（上图）。

    Function: minor-mode-key-binding key &optional accept-defaults ¶

此函数返回 `key` 的所有活动次要模式绑定的列表。更准确地说，它返回一个对列表（modename . binding），其中 `modename` 是启用次要模式的变量，而 `binding` 是该模式下的键绑定。如果 `key` 没有次要模式绑定，则值为 `nil` 。

如果找到的第一个绑定不是前缀定义（键映射或定义为键映射的符号），则忽略来自其他次要模式的所有后续绑定，因为它们将被完全隐藏。同样，该列表省略了前缀绑定之后的非前缀绑定。

参数accept-defaults 控制检查默认绑定，如lookup-key（上图）。

    User Option: meta-prefix-char ¶

这个变量是元前缀字符代码。它用于将元字符转换为两个字符序列，以便可以在键盘映射中查找。对于有用的结果，该值应该是前缀事件（请参阅前缀键）。默认值为 `27` ，这是 `ESC` 的 `ASCII` 码。

只要 `meta-prefix-char` 的值保持为 `27` ，key lookup 就会将 `Mb` 转换为 `ESC b` ，这通常定义为 `back-word` 命令。但是，如果您将 `meta-prefix-char` 设置为 `24` ，即 `Cx` 的代码，那么 `Emacs` 会将 `Mb` 转换为 `Cx b` ，其标准绑定是 `switch-to-buffer` 命令。（实际上不要这样做！）以下是会发生什么的说明：

    meta-prefix-char                    ; The default value.
         ⇒ 27
    
    (key-binding "\M-b")
         ⇒ backward-word
    
    ?\C-x                               ; The print representation
         ⇒ 24                          ;   of a character.
    
    (setq meta-prefix-char 24)
         ⇒ 24
    
    (key-binding "\M-b")
         ⇒ switch-to-buffer            ; Now, typing M-b is
    				    ;   like typing C-x b.
    
    (setq meta-prefix-char 27)          ; Avoid confusion!
         ⇒ 27                          ; Restore the default value!

这种将一个事件转换为两个事件仅发生在字符上，而不是其他类型的输入事件。因此，功能键 `M-F1` 不会转换为 `ESC F1` 。


<a id="org688aa47"></a>

## 23.12 更改键绑定

重新绑定键的方法是更改​​其在键映射中的条目。如果您更改全局键映射中的绑定，则更改在所有缓冲区中都有效（尽管它在将全局绑定与本地绑定遮蔽的缓冲区中没有直接影响）。如果更改当前缓冲区的本地映射，通常会影响使用相同主要模式的所有缓冲区。global-set-key 和 `local-set-key` 函数是这些操作的方便接口（请参阅绑定键的命令）。你也可以使用define-key，一个更通用的功能；那么您必须明确指定要更改的地图。

在为 `Lisp` 程序选择键序列以重新绑定时，请遵循 `Emacs` 约定以使用各种键（请参阅键绑定约定）。

在编写要重新绑定的键序列时，最好对控制字符和元字符使用特殊的转义序列（请参阅字符串类型）。语法 `\C-` 表示后面的字符是控制字符， `\M-` 表示后面的字符是元字符。因此，字符串 `\Mx` 被读取为包含单个 `Mx` ， `\Cf` 被读取为包含单个 `Cf` ，并且 `\M-\Cx` 和 `\C-\Mx` 都被读取为包含一个单个 `CMx` 。您还可以在向量中使用这种转义语法，以及在字符串中不允许使用的其他语法；一个例子是'[?\C-\Hx home]'。请参阅字符类型。

键定义和查找函数接受作为向量的键序列中事件类型的替代语法：您可以使用包含修饰符名称和一个基本事件（字符或功能键名称）的列表。例如，(control ?a) 等价于 `?\Ca` ，(hyper control left) 等价于 `CH-left` 。此类列表的一个优点是修饰符位的精确数字代码不会出现在编译文件中。

如果 `keymap` 不是 `keymap` ，或者 `key` 不是表示键序列的字符串或向量，则下面的函数会发出错误信号。您可以使用事件类型（符号）作为列表事件的简写。kbd 函数（请参阅键序列）是指定键序列的便捷方式。

    Function: define-key keymap key binding ¶

此函数设置键映射中键的绑定。（如果 `key` 的长度超过一个事件，则更改实际上是在从 `keymap` 到达的另一个 `keymap` 中进行的。）参数绑定可以是任何 `Lisp` 对象，但只有某些类型是有意义的。（有关有意义类型的列表，请参阅键查找。）define-key 返回的值是绑定的。

如果 `key` 是 `[t]` ，这将在 `keymap` 中设置默认绑定。当一个事件没有它自己的绑定时，Emacs 命令循环使用键盘映射的默认绑定，如果有的话。

key 的每个前缀必须是前缀键（即绑定到 `keymap` ）或未定义；否则会发出错误信号。如果 `key` 的某些前缀未定义，则 `define-key` 将其定义为前缀 `key` ，以便 `key` 的其余部分可以按指定定义。

如果 `keymap` 中之前没有 `key` 的绑定，则在 `keymap` 的开头添加新的绑定。键映射中的绑定顺序对键盘输入没有影响，但对菜单键映射很重要（请参阅菜单键映射）。

此示例创建一个稀疏键映射并在其中进行许多绑定：

    
    
    (setq map (make-sparse-keymap))
        ⇒ (keymap)
    
    (define-key map "\C-f" 'forward-char)
        ⇒ forward-char
    
    map
        ⇒ (keymap (6 . forward-char))
    
    
    ;; Build sparse submap for C-x and bind f in that.
    (define-key map (kbd "C-x f") 'forward-word)
        ⇒ forward-word
    
    map
    ⇒ (keymap
        (24 keymap                ; C-x
    	(102 . forward-word)) ;      f
        (6 . forward-char))       ; C-f
    
    
    ;; Bind C-p to the ctl-x-map.
    (define-key map (kbd "C-p") ctl-x-map)
    ;; ctl-x-map
    ⇒ [nil … ~find-file~ … ~backward-kill-sentence]
    
    
    ;; Bind C-f to foo in the ctl-x-map.
    (define-key map (kbd "C-p C-f") 'foo)
    ⇒ 'foo
    
    map
    ⇒ (keymap     ; Note foo in ctl-x-map.
        (16 keymap [nil~ … ~foo~ … ~backward-kill-sentence])
        (24 keymap
    	(102 . forward-word))
        (6 . forward-char))

~ 请注意，为 `Cp Cf` 存储新绑定实际上是通过更改 `ctl-x-map` 中的条目来工作的，这具有更改默认全局映射中 `Cp Cf` 和 `Cx Cf` 的绑定的效果。

函数替代键定义扫描键映射以查找具有特定绑定的键，并使用不同的绑定重新绑定它们。另一个更简洁且通常可以产生相同结果的功能是将一个命令重新映射到另一个命令（请参阅重新映射命令）。

    Function: substitute-key-definition olddef newdef keymap &optional oldmap ¶

对于绑定到 `olddef` 的键映射中的任何键，此函数将 `olddef` 替换为 `newdef` 。换句话说，无论它出现在哪里，olddef 都会被替换为 `newdef` 。该函数返回零。

例如，如果您在具有标准绑定的 `Emacs` 中执行此操作，则会重新定义 `Cx Cf` ：

    (substitute-key-definition
     'find-file 'find-file-read-only (current-global-map))

如果 `oldmap` 不是 `nil` ，那会改变替换键定义的行为：oldmap 中的绑定确定要重新绑定哪些键。重新绑定仍然发生在 `keymap` 中，而不是 `oldmap` 中。因此，您可以在另一张地图的绑定控制下更改一张地图。例如，

    (substitute-key-definition
      'delete-backward-char 'my-funny-delete
      my-map global-map)

对于全局绑定到标准删除命令的任何键，将特殊删除命令放在 `my-map` 中。

这是一个显示替换前后的键映射的示例：

    (setq map (list 'keymap
    		(cons ?1 olddef-1)
    		(cons ?2 olddef-2)
    		(cons ?3 olddef-1)))
    ⇒ (keymap (49 . olddef-1) (50 . olddef-2) (51 . olddef-1))
    
    
    (substitute-key-definition 'olddef-1 'newdef map)
    ⇒ nil
    
    map
    ⇒ (keymap (49 . newdef) (50 . olddef-2) (51 . newdef))

    Function: suppress-keymap keymap &optional nodigits ¶

此函数通过将 `self-insert-command` 重新映射到未定义的命令来更改完整键盘映射 `keymap` 的内容（请参阅重新映射命令）。这具有取消定义所有打印字符的效果，因此无法正常插入文本。抑制键映射返回 `nil` 。

如果 `nodigits` 为 `nil` ，则 `suppress-keymap` 定义数字以运行数字参数，并定义 `-` 以运行否定参数。否则，它会使它们像其他打印字符一样未定义。

抑制键映射功能不会使修改缓冲区成为不可能，因为它不会抑制诸如 `yank` 和quoted-insert 之类的命令。要防止对缓冲区进行任何修改，请将其设为只读（请参阅只读缓冲区）。

由于此函数会修改键盘映射，因此您通常会在新创建的键盘映射上使用它。对用于其他目的的现有键盘映射进行操作可能会造成麻烦；例如，抑制 `global-map` 将使大多数 `Emacs` 无法使用。

此函数可用于初始化不需要插入文本的主要模式的本地键盘映射。但通常这种模式应该从特殊模式派生（参见基本主要模式）；那么它的键映射将自动从已经被抑制的特殊模式映射继承。以下是特殊模式映射的定义方式：

    (defvar special-mode-map
      (let ((map (make-sparse-keymap)))
        (suppress-keymap map)
        (define-key map "q" 'quit-window)
        …
        map))


<a id="orgfc3967c"></a>

## 23.13 重映射命令

可以使用一种特殊的键绑定将一个命令重新映射到另一个命令，而不必参考绑定到原始命令的键序列。要使用此功能，请对以虚拟事件重映射开头的键序列进行键绑定，后跟要重映射的命令名称；对于绑定，指定新定义（通常是命令名称，但可能是键绑定的任何其他有效定义）。

例如，假设我的模式提供了一个特殊的命令 `my-kill-line` ，应该调用它而不是 `kill-line` 。为了确定这一点，它的模式键映射应包含以下重新映射：

    (define-key my-mode-map [remap kill-line] 'my-kill-line)

然后，每当 `my-mode-map` 处于活动状态时，如果用户键入 `Ck` （kill-line 的默认全局键序列），Emacs 将改为运行 `my-kill-line` 。

请注意，重新映射只能通过活动键盘映射进行；例如，在像 `ctl-x-map` 这样的前缀键映射中重新映射通常没有效果，因为这样的键映射本身不是活动的。此外，重新映射只能通过一个级别进行；在以下示例中，

    (define-key my-mode-map [remap kill-line] 'my-kill-line)
    (define-key my-mode-map [remap my-kill-line] 'my-other-kill-line)

kill-line 不会重新映射到 `my-other-kill-line` 。相反，如果一个普通的键绑定指定了 `kill-line` ，它会重新映射到 `my-kill-line` ；如果普通绑定指定了 `my-kill-line` ，它会重新映射到 `my-other-kill-line` 。

要撤消命令的重新映射，请将其重新映射为 `nil` ；例如，

    (define-key my-mode-map [remap kill-line] nil)

    Function: command-remapping command &optional position keymaps ¶

给定当前活动的键盘映射，此函数返回命令（符号）的重新映射。如果 `command` 没有重新映射（这是通常的情况），或者不是符号，则函数返回 `nil` 。position 可以选择指定缓冲区位置或事件位置来确定要使用的键映射，如键绑定。

如果可选参数 `keymaps` 不为零，则它指定要搜索的键盘映射列表。如果 `position` 不为零，则忽略此参数。


<a id="orgb37351c"></a>

## 23.14 用于翻译事件序列的键映射


<a id="org341f0c4"></a>

### 23.14.1 与普通键盘映射的交互

当 `read-key-sequence` 函数读取一个键序列（请参阅键序列输入）时，它使用转换键映射将某些事件序列转换为其他事件序列。翻译键映射是 `input-decode-map` 、local-function-key-map 和 `key-translation-map` （按优先级顺序）。

翻译键映射与其他键映射具有相同的结构，但使用方式不同：它们指定在读取键序列时进行的翻译，而不是完整键序列的绑定。在读取每个键序列时，会根据每个翻译键映射对其进行检查。如果其中一个翻译键映射将 `k` 绑定到向量 `v` ，则每当 `k` 作为键序列中任何位置的子序列出现时，该子序列就会被 `v` 中的事件替换。

例如，当按下键盘按键 `PF1` 时，VT100 终端发送 `ESC OP` 。在这样的终端上，Emacs 必须将该事件序列转换为单个事件 `pf1` 。这是通过将 `ESC OP` 绑定到 `input-decode-map` 中的 `[pf1]` 来完成的。因此，当您在终端上键入 `Cc PF1` 时，终端会发出字符序列 `Cc ESC OP` ，而 `read-key-sequence` 会将其转换回 `Cc PF1` 并将其作为向量 `[?\Cc pf1]` 返回。

翻译键盘映射只有在 `Emacs` 解码了键盘输入后才生效（通过键盘编码系统指定的输入编码系统）。请参阅终端 `I/O` 编码。

    Variable: input-decode-map ¶

这个变量保存了一个键映射，描述了普通字符终端上功能键发送的字符序列。

input-decode-map 的值通常根据终端的 `Terminfo` 或 `Termcap` 条目自动设置，但有时需要终端特定的 `Lisp` 文件的帮助。Emacs 带有许多常见终端的终端特定文件；它们的主要目的是使输入解码映射中的条目超出可以从 `Termcap` 和 `Terminfo` 推导出的条目。请参阅特定于终端的初始化。

    Variable: local-function-key-map ¶

这个变量拥有一个类似于 `input-decode-map` 的键映射，除了它描述了应该被翻译成通常首选的替代解释的键序列。它适用于 `input-decode-map` 之后和 `key-translation-map` 之前。

如果 `local-function-key-map` 中的条目与在次要模式、本地或全局键映射中进行的绑定冲突，则它们将被忽略。即，仅当原始键序列不具有任何绑定时才适用重新映射。

local-function-key-map 继承自 `function-key-map` 。如果您希望绑定适用于所有终端，则仅应更改后者，因此几乎总是首选使用前者。

    Variable: key-translation-map ¶

这个变量是另一个键盘映射，就像 `input-decode-map` 一样用于将输入事件转换为其他事件。它与 `input-decode-map` 的不同之处在于它在 `local-function-key-map` 完成之后而不是之前开始工作；它通过 `local-function-key-map` 接收翻译结果。

与 `input-decode-map` 类似，但与 `local-function-key-map` 不同，无论输入键序列是否具有正常绑定，都会应用此键映射。但是请注意，实际的键绑定可能会对键翻译映射产生影响，即使它们被它覆盖。实际上，实际的键绑定会覆盖 `local-function-key-map` ，因此可能会改变 `key-translation-map` 接收到的键序列。显然，最好避免这种情况。

key-translation-map 的目的是让用户将一个字符集映射到另一个字符集，包括通常绑定到 `self-insert-command` 的普通字符。

您可以将 `input-decode-map` 、local-function-key-map 和 `key-translation-map` 用于更多的简单别名，方法是使用函数而不是键序列作为键的翻译。然后调用这个函数来计算那个键的翻译。

键翻译函数接收一个参数，它是在 `read-key-sequence` 中指定的提示符，如果编辑器命令循环正在读取键序列，则为 `nil` 。在大多数情况下，您可以忽略提示值。

如果函数本身读取输入，它可以具有改变随后事件的效果。例如，下面是如何定义 `Cc h` 以将后面的字符转换为 `Hyper` 字符：

    (defun hyperify (prompt)
      (let ((e (read-event)))
        (vector (if (numberp e)
    		(logior (ash 1 24) e)
    	      (if (memq 'hyper (event-modifiers e))
    		  e
    		(add-event-modifier "H-" e))))))
    
    (defun add-event-modifier (string e)
      (let ((symbol (if (symbolp e) e (car e))))
        (setq symbol (intern (concat string
    				 (symbol-name symbol))))
        (if (symbolp e)
    	symbol
          (cons symbol (cdr e)))))
    
    (define-key local-function-key-map "\C-ch" 'hyperify)


<a id="orgb44669b"></a>

### 23.14.1 与普通键盘映射的交互

当键序列绑定到命令时，或者当 `Emacs` 确定没有其他事件可以导致绑定到命令的序列时，会检测到键序列的结尾。

这意味着，尽管无论原始键序列是否具有绑定，输入解码映射和键翻译映射都适用，但这种绑定的存在仍然会阻止翻译发生。例如，让我们回到上面的 `VT100` 示例，将 `Cc ESC` 的绑定添加到全局映射；现在，当用户点击 `Cc PF1` 时，Emacs 将无法将 `Cc ESC OP` 解码为 `Cc PF1` ，因为它将在 `Cc ESC` 之后立即停止读取键，将 `OP` 留待以后使用。这是在用户真的按下 `Cc ESC` 的情况下，在这种情况下 `Emacs` 不应该坐在那里等待下一个键来决定用户是真的按下 `ESC` 还是 `PF1` 。

出于这个原因，最好避免将命令绑定到键序列的结尾是键转换的前缀的键序列。此类有问题的后缀/前缀主要是 `ESC` 、MO（实际上是 `ESC O` ）和 `M-[` （实际上是 `ESC [` ）。


<a id="org706ad15"></a>

## 23.15 绑定键的命令

本节介绍一些用于更改键绑定的便捷交互界面。他们通过调用define-key来工作。

人们经常在他们的 `init` 文件（参见 `The Init File` ）中使用 `global-set-key` 来进行简单的定制。例如，

    (global-set-key (kbd "C-x C-\\") 'next-line)

或者

    (global-set-key [?\C-x ?\C-\\] 'next-line)

或者

    (global-set-key [(control ?x) (control ?\\)] 'next-line)

重新定义 `Cx C-\` 以向下移动一行。

    (global-set-key [M-mouse-1] 'mouse-set-point)

将使用 `Meta` 键输入的第一个（最左侧）鼠标按钮重新定义为您单击的设置点。

在要绑定的键的 `Lisp` 规范中使用非 `ASCII` 文本字符时要小心。如果这些被读取为多字节文本，因为它们通常位于 `Lisp` 文件中（请参阅加载非 `ASCII` 字符），则您也必须将键键入为多字节。例如，如果你使用这个：

    (global-set-key "ö" 'my-function) ; bind o-umlaut

或者

    (global-set-key ?ö 'my-function) ; bind o-umlaut

并且您的语言环境是多字节 `Latin-1` ，这些命令实际上将多字节字符与代码 `246` 绑定，而不是由 `Latin-1` 终端发送的字节代码 `246 (Mv)` 。为了使用这个绑定，您需要教 `Emacs` 如何使用适当的输入法来解码键盘（参见 `GNU Emacs` 手册中的输入法）。

    Command: global-set-key key binding ¶

该函数将当前全局映射中key的绑定设置为绑定。

    (global-set-key key binding)
    ≡
    (define-key (current-global-map) key binding)

    Command: global-unset-key key ¶

此函数从当前全局映射中删除键的绑定。

此函数的一个用途是准备定义一个使用 `key` 作为前缀的更长的键——如果 `key` 具有非前缀绑定，则不允许这样做。例如：

    (global-unset-key "\C-l")
        ⇒ nil
    
    (global-set-key "\C-l\C-l" 'redraw-display)
        ⇒ nil

这个函数相当于使用define-key，如下：

    (global-unset-key key)
    ≡
    (define-key (current-global-map) key nil)

    Command: local-set-key key binding ¶

该函数将当前本地keymap中key的绑定设置为绑定。

    (local-set-key key binding)
    ≡
    (define-key (current-local-map) key binding)

    Command: local-unset-key key ¶

此函数从当前本地地图中删除键的绑定。

    (local-unset-key key)
    ≡
    (define-key (current-local-map) key nil)


<a id="org4a19934"></a>

## 23.16 扫描键盘映射

本节介绍用于扫描所有当前键盘映射以打印帮助信息的功能。要在特定的键盘映射中显示绑定，可以使用 `describe-keymap` 命令（参见 `GNU Emacs` 手册中的其他帮助命令）

    Function: accessible-keymaps keymap &optional prefix ¶

此函数返回可以从键映射（通过零个或多个前缀键）到达的所有键映射的列表。该值是一个具有表单元素的关联列表 `(key.map)` ，其中 `key` 是一个前缀键，其在 `keymap` 中的定义是 `map` 。

alist 的元素是有序的，因此键的长度会增加。第一个元素始终是 `([] . keymap)` ，因为指定的 `keymap` 可以从其自身访问，其前缀为 `no events` 。

如果给出了前缀，则应该是前缀键序列；那么accessible-keymaps 只包含前缀以prefix 开头的子图。这些元素看起来就像它们在 `(accessible-keymaps)` 的值中所做的一样；唯一的区别是省略了一些元素。

在下面的示例中，返回的 `alist` 表示键 `ESC` ，显示为 `'^['` ，是一个前缀键，其定义为稀疏键映射 `(keymap (83 .center-paragraph) (115 . foo))` 。

    (accessible-keymaps (current-local-map))
    ⇒(([] keymap
          (27 keymap   ; Note this keymap for ESC is repeated below.
    	  (83 . center-paragraph)
    	  (115 . center-line))
          (9 . tab-to-tab-stop))
    
    
       ("^[" keymap
        (83 . center-paragraph)
        (115 . foo)))

在以下示例中，Ch 是一个前缀键，它使用以 `(keymap (118 . describe-variable)...)` 开头的稀疏键映射。另一个前缀 `Cx 4` 使用一个键映射，它也是变量 `ctl-x-4-map` 的值。事件模式行是几个虚拟事件之一，用作窗口特殊部分中鼠标操作的前缀。

    
    
    (accessible-keymaps (current-global-map))
    ⇒ (([] keymap [set-mark-command beginning-of-line …
    		   delete-backward-char])
    
        ("^H" keymap (118 . describe-variable) …
         (8 . help-for-help))
    
        ("^X" keymap [x-flush-mouse-queue …
         backward-kill-sentence])
    
        ("^[" keymap [mark-sexp backward-sexp …
         backward-kill-word])
    
        ("^X4" keymap (15 . display-buffer) …)
    
        ([mode-line] keymap
         (S-mouse-2 . mouse-split-window-horizontally) …))

这些并不是您实际看到的所有键盘映射。

    Function: map-keymap function keymap ¶

函数 `map-keymap` 为 `keymap` 中的每个绑定调用一次函数。它传递两个参数，事件类型和绑定值。如果 `keymap` 有父级，则也包括父级的绑定。这以递归方式工作：如果父级本身有一个父级，那么祖父级的绑定也包括在内，依此类推。

此函数是检查键盘映射中所有绑定的最简洁方法。

    Function: where-is-internal command &optional keymap firstonly noindirect no-remap ¶

该函数是 `where-is` 命令使用的子例程（参见 `GNU Emacs` 手册中的帮助）。它返回绑定到一组键映射中的命令的所有键序列（任意长度）的列表。

参数命令可以是任何对象；它与使用 `eq` 的所有键盘映射条目进行比较。

如果 `keymap` 为 `nil` ，则使用的映射是当前活动的 `keymap` ，忽略 `overriding-local-map` （即假装其值为 `nil` ）。如果 `keymap` 是 `keymap` ，则搜索的映射是 `keymap` 和全局 `keymap` 。如果 `keymap` 是 `keymap` 列表，则仅搜索这些 `keymap` 。

通常最好使用 `overriding-local-map` 作为 `keymap` 的表达式。然后 `where-is-internal` 精确搜索活动的键盘映射。要仅搜索全局映射，请将值 `(keymap)` （一个空的 `keymap` ）作为 `keymap` 传递。

如果 `firstonly` 是非 `ascii` ，则该值是表示找到的第一个键序列的单个向量，而不是所有可能键序列的列表。如果 `firstonly` 是 `t` ，则该值是第一个键序列，除了完全由 `ASCII` 字符（或 `ASCII` 字符的元变体）组成的键序列优于所有其他键序列并且返回值永远不能是菜单绑定。

如果 `noindirect` 不为零，则 `where-is-internal` 不会在菜单项内部查找它们的命令。这使得搜索菜单项本身成为可能。

第五个参数 `no-remap` 确定此函数如何处理命令重映射（请参阅重映射命令）。有两个感兴趣的案例：

如果命令 `other-command` 重新映射到命令：

     如果 `no-remap` 为 `nil` ，则查找 `other-command` 的绑定并将它们视为它们也是 `command` 的绑定。如果 `no-remap` 不为零，则将向量 `[remap other-command]` 包含在可能的键序列列表中，而不是查找那些绑定。
如果命令被重新映射到其他命令：

如果 `no-remap` 为 `nil` ，则返回 `other-command` 而不是 `command` 的绑定。如果 `no-remap` 不为零，则返回 `command` 的绑定，忽略它被重新映射的事实。

    Command: describe-bindings &optional prefix buffer-or-name ¶

此函数创建所有当前键绑定的列表，并将其显示在名为 `*Help*` 的缓冲区中。文本按模式分组——首先是次要模式，然后是主要模式，然后是全局绑定。

如果 `prefix` 不是 `nil` ，它应该是一个前缀键；那么该列表仅包含以前缀开头的键。

当具有连续 `ASCII` 码的多个字符具有相同定义时，它们会一起显示，如 `'firstchar..lastchar'` 。在这种情况下，您需要知道 `ASCII` 代码才能理解这意味着哪些字符。例如，在默认全局映射中，字符 `SPC .. ~由单行描述。SPC是ASCII 32，~是ASCII 126，它们之间的字符包括所有正常的打印字符，（例如，字母、数字、标点符号等）；所有这些字符都绑定到 ~self-insert-command` 。

如果 `buffer-or-name` 不为 `nil` ，则它应该是缓冲区或缓冲区名称。然后 `describe-bindings` 列出该缓冲区的绑定，而不是当前缓冲区的绑定。


<a id="org48e1d0c"></a>

## 23.17 菜单键映射

键盘映射可以作为菜单操作，也可以定义键盘键和鼠标按钮的绑定。菜单通常用鼠标启动，但也可以用键盘操作。如果菜单键映射对于下一个输入事件是活动的，则激活键盘菜单功能。


<a id="org9e166c4"></a>

### 23.17.1 定义菜单

如果键映射具有整体提示字符串，则它充当菜单，该字符串是作为键映射元素出现的字符串。（请参阅键盘映射格式。）该字符串应描述菜单命令的用途。在某些情况下，Emacs 将整体提示字符串显示为菜单标题，具体取决于用于显示菜单的工具包（如果有）。16 键盘菜单也显示整体提示字符串。

使用提示字符串构造键映射的最简单方法是在调用 `make-keymap` 、make-sparse-keymap（请参阅创建键映射）或 `define-prefix-command` （请参阅 `define-prefix` 的定义）时将字符串指定为参数-命令）。如果您不希望键盘映射作为菜单操作，请不要为其指定提示字符串。

    Function: keymap-prompt keymap ¶

此函数返回 `keymap` 的整体提示字符串，如果没有则返回 `nil` 。

菜单项是键映射中的绑定。每个绑定都将事件类型与定义相关联，但事件类型对菜单外观没有意义。（通常我们使用伪事件（键盘无法生成的符号）作为菜单项绑定的事件类型。）菜单完全由与这些事件对应的键映射中的绑定生成。

菜单中项目的顺序与键映射中的绑定顺序相同。由于 `define-key` 将新绑定放在前面，如果您关心顺序，您应该从菜单底部开始定义菜单项并移至顶部。将项目添加到现有菜单时，可以使用 `define-key-after` 指定其在菜单中的位置（请参阅修改菜单）。

1.  23.17.1.1 简单菜单项

    定义菜单项的更简单（和原始）方法是将某些事件类型（与事件类型无关）绑定到如下绑定：
    
        (item-string . real-binding)
    
    CAR，item-string，是要在菜单中显示的字符串。它应该简短——最好是一到三个词。它应该描述它对应的命令的动作。请注意，并非所有图形工具包都可以在菜单中显示非 `ASCII` 文本（它适用于键盘菜单，并且在很大程度上适用于 `GTK+` 工具包）。
    
    您还可以提供第二个字符串，称为帮助字符串，如下所示：
    
        (item-string help . real-binding)
    
    help 指定当鼠标在该项目上时要显示的帮助回显字符串，其方式与帮助回显文本属性相同（请参阅帮助显示）。
    
    就 `define-key` 而言，item-string 和 `help-string` 是事件绑定的一部分。但是，lookup-key 只返回 `real-binding` ，并且只有 `real-binding` 用于执行 `key` 。
    
    如果 `real-binding` 为 `nil` ，则 `item-string` 出现在菜单中但无法选择。
    
    如果 `real-binding` 是一个符号并且具有非 `nil`  menu-enable 属性，则该属性是一个控制菜单项是否启用的表达式。每次使用 `keymap` 显示菜单时，Emacs 都会计算表达式，并且仅当表达式的值为非 `nil`  时才会启用菜单项。当一个菜单项被禁用时，它以模糊的方式显示，并且不能被选择。
    
    每次查看菜单时，菜单栏不会重新计算启用了哪些项目。这是因为 `X` 工具包需要预先设置整个菜单树。要强制重新计算菜单栏，请调用 `force-mode-line-update` （请参阅模式行格式）。

2.  23.17.1.2 扩展菜单项

    扩展格式的菜单项是比简单格式更灵活、更简洁的替代方案。您定义一个事件类型，其绑定是一个以符号菜单项开头的列表。对于不可选择的字符串，绑定如下所示：
    
        (menu-item item-name)
    
    以两个或多个破折号开头的字符串指定分隔线；请参阅菜单分隔符。
    
    要定义一个可以选择的真实菜单项，扩展格式绑定如下所示：
    
        (menu-item item-name real-binding
            . item-property-list)
    
    这里，item-name 是一个表达式，计算结果为菜单项字符串。因此，字符串不必是常数。
    
    第三个元素，real-binding，可以是要执行的命令（在这种情况下，您会得到一个普通的菜单项）。也可以是keymap，会产生一个子菜单，item-name作为子菜单名。最后，它可以为 `nil` ，在这种情况下，您将获得一个不可选择的菜单项。这在创建分隔线等时非常有用。
    
    列表的尾部 `item-property-list` 具有包含其他信息的属性列表的形式。
    
    以下是支持的属性表：
    
        :enable form
    
    评估表单的结果确定该项目是否启用（非零表示是）。如果该项目未启用，则您无法真正单击它。
    
        :visible form
    
    评估表单的结果确定该项目是否应该实际出现在菜单中（非零表示是）。如果该项目未出现，则显示菜单，就好像根本没有定义该项目一样。
    
        :help help
    
    此属性的值 `help` 指定当鼠标在该项目上时要显示的帮助回显字符串。这与 `help-echo` 文本属性的显示方式相同（请参阅帮助显示）。请注意，这必须是一个常量字符串，这与文本和叠加层的 `help-echo` 属性不同。
    
        :button (type . selected)
    
    此属性提供了一种定义单选按钮和切换按钮的方法。CAR，类型，说明：它应该是 `:toggle` 或 `:radio` 。选择的 `CDR` 应该是一个表格；评估它的结果表明当前是否选择了此按钮。
    
    切换是一个菜单项，根据 `selected` 的值标记为打开或关闭。命令本身应该切换选中状态，如果它是 `nil` ，则将其设置为 `t` ，如果它是 `t` ，则将其设置为 `nil` 。以下是用于切换错误调试标志的菜单项的定义方式：
    
        (menu-item "Debug on Error" toggle-debug-on-error
        	   :button (:toggle
        		    . (and (boundp 'debug-on-error)
        			   debug-on-error)))
    
    这是有效的，因为 `toggle-debug-on-error` 被定义为切换变量 `debug-on-error` 的命令。
    
    单选按钮是一组菜单项，在任何时候只有一个被选中。应该有一个变量，其值表明在任何时候都选择了哪一个。组中每个单选按钮的选定表单应检查变量是否具有选择该按钮的正确值。单击按钮应设置变量，以便您单击的按钮被选中。
    
        :key-sequence key-sequence
    
    此属性指定要显示为等效键盘的键序列。在 `Emacs` 在菜单中显示 `key-sequence` 之前，它会验证 `key-sequence` 是否真的等同于这个菜单项，因此只有指定正确的键序列才会生效。为 `key-sequence` 指定 `nil`  相当于不存在 `:key-sequence` 属性。
    
        :keys string
    
    此属性指定 `string` 是要显示为此菜单项的键盘等效项的字符串。您可以在字符串中使用 `'\\[...]'` 文档结构。
    
        :filter filter-fn
    
    此属性提供了一种动态计算菜单项的方法。属性值 `filter-fn` 应该是一个参数的函数；当它被调用时，它的参数将是真正的绑定。该函数应返回要使用的绑定。
    
    Emacs 可以在重新显示或对菜单数据结构进行操作的任何时候调用此函数，因此您应该编写它以便可以随时安全地调用它。

3.  23.17.1.3 菜单分隔符

    菜单分隔符是一种不显示任何文本的菜单项，而是用一条水平线将菜单分成子部分。分隔符在菜单键映射中如下所示：
    
        (menu-item separator-type)
    
    其中 `separator-type` 是以两个或多个破折号开头的字符串。
    
    在最简单的情况下，separator-type 仅包含破折号。这指定了默认的分隔符类型。（为了兼容性， `和 ~-` 也算作分隔符。）
    
    separator-type 的某些其他值指定了不同样式的分隔符。这是他们的表格：
    
        "--no-line"
    
        "--space"
    
    一个额外的垂直空间，没有实际的线条。
    
        "--single-line"
    
    菜单前景色中的单行。
    
        "--double-line"
    
    菜单前景色中的双线。
    
        "--single-dashed-line"
    
    菜单前景色中的单条虚线。
    
        "--double-dashed-line"
    
    菜单前景色中的双虚线。
    
        "--shadow-etched-in"
    
    具有 `3D` 凹陷外观的单行。这是默认使用的分隔符，仅由破折号组成。
    
        "--shadow-etched-out"
    
    具有 `3D` 凸起外观的单行。
    
        "--shadow-etched-in-dash"
    
    具有 `3D` 凹陷外观的单虚线。
    
        "--shadow-etched-out-dash"
    
    具有 `3D` 凸起外观的单虚线。
    
        "--shadow-double-etched-in"
    
    两条具有 `3D` 凹陷外观的线条。
    
        "--shadow-double-etched-out"
    
    两条带有 `3D` 凸起外观的线条。
    
        "--shadow-double-etched-in-dash"
    
    两条具有 `3D` 凹陷外观的虚线。
    
        "--shadow-double-etched-out-dash"
    
    两条具有 `3D` 凸起外观的虚线。
    
    您还可以以另一种样式命名这些名称，在双破折号后添加一个冒号，并将每个单破折号替换为以下单词的大写。因此， `--:singleLine` 等价于 `--single-line` 。
    
    您可以使用更长的形式来指定关键字，例如 `:enable` 和 `:visible` 作为菜单分隔符：
    
        (menu-item separator-type nil . item-property-list)
    
    例如：
    
        (menu-item "--" nil :visible (boundp 'foo))
    
    一些系统和显示工具包并不能真正处理所有这些分隔符类型。如果您使用不受支持的类型，则菜单会显示受支持的类似分隔符。

4.  23.17.1.4 别名菜单项

    有时制作使用相同命令但具有不同启用条件的菜单项很有用。现在在 `Emacs` 中做到这一点的最好方法是使用扩展菜单项；在该功能存在之前，可以通过定义别名命令并在菜单项中使用它们来完成。这是一个为只读模式创建两个别名并为它们提供不同启用条件的示例：
    
        (defalias 'make-read-only 'read-only-mode)
        (put 'make-read-only 'menu-enable '(not buffer-read-only))
        (defalias 'make-writable 'read-only-mode)
        (put 'make-writable 'menu-enable 'buffer-read-only)
    
    在菜单中使用别名时，显示实际命令名称的等效键绑定通常很有用，而不是别名（通常除了菜单本身没有任何键绑定）。要请求这个，请给别名符号一个非零菜单别名属性。因此，
    
        (put 'make-read-only 'menu-alias t)
        (put 'make-writable 'menu-alias t)
    
    使 `make-read-only` 和 `make-writable` 的菜单项显示只读模式的键盘绑定。


<a id="org4fc954d"></a>

### 23.17.2 菜单和鼠标

使菜单键映射生成菜单的常用方法是使其成为前缀键的定义。（Lisp 程序可以显式弹出一个菜单并接收用户的选择——参见弹出菜单。）

如果前缀键以鼠标事件结束，Emacs 通过弹出一个可见菜单来处理菜单键映射，以便用户可以用鼠标选择一个选项。当用户单击一个菜单项时，所生成的事件是任何具有导致该菜单项的绑定的字符或符号。（如果菜单具有多个级别或来自菜单栏，则菜单项可能会生成一系列事件。）

通常最好使用按钮按下事件来触发菜单。然后用户可以通过释放按钮来选择菜单项。

如果菜单键映射包含到嵌套键映射的绑定，则嵌套键映射指定子菜单。会有一个菜单项，由嵌套的keymap的item字符串标记，点击这个item会自动弹出指定的子菜单。作为一个特殊的例外，如果菜单键映射包含单个嵌套键映射并且没有其他菜单项，则菜单直接显示嵌套键映射的内容，而不是作为子菜单。

但是，如果 `Emacs` 在没有 `X` 工具包支持的情况下编译，或者在文本终端上，则不支持子菜单。每个嵌套的键盘映射都显示为一个菜单项，但单击它不会自动弹出子菜单。如果你想模仿子菜单的效果，你可以通过给嵌套的键盘映射一个以'@'开头的项目字符串来做到这一点。这会导致 `Emacs` 使用单独的菜单窗格显示嵌套的键盘映射；'@' 之后的项目字符串的其余部分是窗格标签。如果在没有 `X` 工具包支持的情况下编译 `Emacs` ，或者如果在文本终端上显示菜单，则不使用菜单窗格；在这种情况下，显示菜单标签时会省略项目字符串开头的 `@` ，并且没有其他效果。


<a id="org122bd1b"></a>

### 23.17.3 菜单和键盘

当以键盘事件（字符或功能键）结尾的前缀键定义为菜单键映射时，键映射作为键盘菜单操作；用户通过使用键盘选择一个菜单项来指定下一个事件。

Emacs 在回显区域显示带有地图整体提示字符串的键盘菜单，然后是替代项（地图绑定的项目字符串）。如果绑定不能一次全部适合，用户可以键入 `SPC` 以查看下一行替代项。连续使用 `SPC` 最终会到达菜单的末尾，然后循环到开头。（变量 `menu-prompt-more-char` 指定使用哪个字符；SPC 是默认值。）

当用户从菜单中找到所需的替代项时，他或她应该键入相应的字符——其绑定是该替代项的字符。

    Variable: menu-prompt-more-char ¶

此变量指定用于请求查看菜单下一行的字符。它的初始值为 `32` ，即 `SPC` 的代码。


<a id="orgbac2113"></a>

### 23.17.4 菜单示例

这是定义菜单键映射的完整示例。它是菜单栏 `编辑` 菜单中 `替换` 子菜单的定义，它使用扩展菜单项格式（见扩展菜单项）。首先我们创建keymap，并给它一个名字：

    (defvar menu-bar-replace-menu (make-sparse-keymap "Replace"))

接下来我们定义菜单项：

    (define-key menu-bar-replace-menu [tags-repl-continue]
      '(menu-item "Continue Replace" multifile-continue
    	      :help "Continue last tags replace operation"))
    (define-key menu-bar-replace-menu [tags-repl]
      '(menu-item "Replace in tagged files" tags-query-replace
    	      :help "Interactively replace a regexp in all tagged files"))
    (define-key menu-bar-replace-menu [separator-replace-tags]
      '(menu-item "--"))
    ;; …

注意绑定的符号；这些出现在方括号内，在定义的键序列中。在某些情况下，此符号与命令名称相同；有时它是不同的。这些符号被视为功能键，但它们不是键盘上的真正功能键。它们不影响菜单本身的功能，但当用户从菜单中选择时，它们会在回显区域中回显，并出现在 `where-is` 和 `apropos` 的输出中。

此示例中的菜单旨在与鼠标一起使用。如果菜单打算与键盘一起使用，也就是说，如果它绑定到以键盘事件结尾的键序列，那么菜单项应该绑定到可以用键盘键入的字符或实际功能键。

定义为 `("--")` 的绑定是分隔线。与真正的菜单项一样，分隔符有一个键符号，在本例中为 `separator-replace-tags` 。如果一个菜单有两个分隔符，它们必须有两个不同的键符号。

下面是我们如何让这个菜单在父菜单中显示为一个项目：

    (define-key menu-bar-edit-menu [replace]
      (list 'menu-item "Replace" menu-bar-replace-menu))

请注意，这包含子菜单键映射，它是变量 `menu-bar-replace-menu` 的值，而不是符号 `menu-bar-replace-menu` 本身。在父菜单项中使用该符号将毫无意义，因为 `menu-bar-replace-menu` 不是命令。

如果您想将相同的替换菜单附加到鼠标单击上，您可以这样做：

    (define-key global-map [C-S-down-mouse-1]
       menu-bar-replace-menu)


<a id="org459cc1d"></a>

### 23.17.5 菜单栏

Emacs 通常在每一帧的顶部显示一个菜单栏。请参阅 `GNU Emacs` 手册中的菜单栏。菜单栏项目是假功能键 `MENU-BAR` 的子命令，如活动键盘映射中所定义。

要将项目添加到菜单栏，请发明一个您自己的假功能键（我们称之为键），并为键序列 `[` 菜单栏键] 进行绑定。大多数情况下，绑定是菜单键映射，因此按下菜单栏项上的按钮会导致另一个菜单。

当多个活动键盘映射为菜单栏定义相同的功能键时，该项目只出现一次。如果用户单击该菜单栏项，它会弹出一个组合菜单，其中包含该项的所有子命令——全局子命令、本地子命令和次要模式子命令。

在确定菜单栏内容时，变量overriding-local-map 通常会被忽略。也就是说，如果 `overriding-local-map` 为 `nil` ，则菜单栏是根据将处于活动状态的键映射计算出来的。请参阅活动键盘映射。

这是设置菜单栏项的示例：

    
    
    ;; Make a menu keymap (with a prompt string)
    ;; and make it the menu bar item’s definition.
    (define-key global-map [menu-bar words]
      (cons "Words" (make-sparse-keymap "Words")))
    
    
    ;; Define specific subcommands in this menu.
    (define-key global-map
      [menu-bar words forward]
      '("Forward word" . forward-word))
    
    (define-key global-map
      [menu-bar words backward]
      '("Backward word" . backward-word))

本地键映射可以取消由全局键映射创建的菜单栏项，方法是重新绑定具有 `undefined` 作为绑定的相同假功能键。例如，这是 `Dired` 抑制 `编辑` 菜单栏项的方式：

    (define-key dired-mode-map [menu-bar edit] 'undefined)

在这里，edit 是由假功能键产生的符号，它被全局映射用于 `编辑` 菜单栏项。抑制全局菜单栏项的主要原因是为特定于模式的项重新获得空间。

    Variable: menu-bar-final-items ¶

通常，菜单栏会显示全局项目，然后是本地地图定义的项目。

这个变量保存了一个伪功能键列表，用于显示在菜单栏末尾而不是按正常顺序显示的项目。默认值为（帮助菜单）；因此， `帮助` 菜单项通常出现在菜单栏的末尾，位于本地菜单项之后。

    Variable: menu-bar-update-hook ¶

在重新显示菜单栏之前，此正常挂钩由重新显示运行以更新菜单栏内容。您可以使用它来更新内容应该不同的菜单。由于这个钩子经常运行，我们建议您确保它调用的函数在通常情况下不会花费太多时间。

在每个菜单栏项旁边，Emacs 会显示一个运行相同命令的键绑定（如果存在这样的键绑定）。这为不知道键绑定的用户提供了方便的提示。如果一个命令有多个绑定，Emacs 通常会显示它找到的第一个。您可以通过将 `:advertised-binding` 符号属性分配给命令来指定一个特定的键绑定。请参阅替换文档中的键绑定。


<a id="org5cfd075"></a>

### 23.17.6 工具栏

工具栏是框架顶部的一排可点击图标，就在菜单栏的下方。请参阅 `GNU Emacs` 手册中的工具栏。Emacs 通常在图形显示器上显示一个工具栏。

在每一帧上，框架参数 `tool-bar-lines` 控制为工具栏保留多少行的高度。零值会抑制工具栏。如果该值不为零，并且 `auto-resize-tool-bars` 不为零，则工具栏会根据需要自动扩展和收缩以保存指定的内容。如果值为 `grow-only` ，则工具栏会自动扩展，但不会自动收缩。

工具栏内容由附加到名为 `TOOL-BAR` 的假功能键的菜单键映射控制（很像控制菜单栏的方式）。所以你使用define-key定义一个工具栏项，像这样：

    (define-key global-map [tool-bar key] item)

其中 `key` 是一个伪造的功能键，用于将该项目与其他项目区分开来，而 `item` 是一个菜单项键绑定（请参阅扩展菜单项），它说明如何显示该项目及其行为方式。

常用的菜单键映射项属性 `:visible` 、:enable、:button 和 `:filter` 在工具栏绑定中很有用并且具有它们的正常含义。item中的real-binding必须是一个命令，而不是一个keymap；换句话说，将工具栏图标定义为前缀键不起作用。

:help 属性指定当鼠标在该项目上时要显示的帮助回显字符串。这与 `help-echo` 文本属性的显示方式相同（请参阅帮助显示）。

此外，您应该使用 `:image` 属性；这是您指定要在工具栏中显示的图像的方式：

    :image image

image 可以是单个图像规范（请参阅图像）或四个图像规范的向量。如果您使用四个向量，则根据情况使用其中一个：

    item 0

在启用和选择项目时使用。

    item 1

在启用和取消选择项目时使用。

    item 2

当项目被禁用和选择时使用。

    item 3

当项目被禁用和取消选择时使用。

Emacs 的 `GTK+` 和 `NS` 版本忽略了项目 `1` 到 `3` ，因为禁用和/或取消选择的图像是从项目 `0` 自动计算的。

如果图像是单个图像规范，Emacs 通过对图像应用边缘检测算法将工具栏按钮绘制为禁用状态。

:rtl 属性指定用于从右到左语言的替代图像。目前只有 `GTK+` 版本的 `Emacs` 支持这个。

与菜单栏一样，工具栏也可以显示分隔符（请参阅菜单分隔符）。但是，工具栏分隔符是垂直的而不是水平的，并且只支持一种样式。它们在工具栏键盘映射中由 `(menu-item "--")` 条目表示；工具栏分隔符不支持 `:visible` 等属性。分隔符在 `GTK+` 和 `Nextstep` 工具栏中原生呈现；在其他情况下，它们使用垂直线的图像进行渲染。

定义了默认工具栏，这样特定于编辑的项目不会出现在其命令符号具有特殊模式类属性的主要模式中（请参阅主要模式约定）。主要模式可以通过在其本地地图中绑定 `[tool-bar foo]` 来将项目添加到全局栏。一些主要模式完全替换默认工具栏项目是有意义的，因为不能方便地容纳很多，并且默认绑定通过使用通过工具栏映射的间接来使这很容易。

    Variable: tool-bar-map ¶

默认情况下，全局地图绑定[tool-bar]如下：

    (global-set-key [tool-bar]
    		`(menu-item ,(purecopy "tool bar") ignore
    			    :filter tool-bar-make-keymap))

反过来，函数 `tool-bar-make-keymap` 从变量 `tool-bar-map` 的值动态地导出实际的工具栏映射。因此，您通常应该通过更改该地图来调整默认（全局）工具栏。一些主要模式，例如 `Info` 模式，通过将 `tool-bar-map buffer-local` 并将其设置为不同的 `keymap` 来完全替换全局工具栏。

定义工具栏项有两个便捷功能，如下所示。

    Function: tool-bar-add-item icon def key &rest props ¶

该函数通过修改 `tool-bar-map` 向工具栏添加一个项目。要使用的图像由 `icon` 定义，它是 `find-image` 要定位的 `XPM` 、XBM 或 `PBM` 图像文件的基本名称。例如，给定一个值 `exit` ，exit.xpm、exit.pbm 和 `exit.xbm` 将在彩色显示器上按该顺序搜索。在单色显示器上，搜索顺序是 `.pbm` 、 `.xbm` 和 `.xpm` 。要使用的绑定是命令 `def` ，key 是前缀键盘映射中的假功能键符号。其余的参数 `props` 是要添加到菜单项规范的附加属性列表元素。

要在某些本地地图中定义项目，请将 `tool-bar-map` 与 `let around` 调用此函数绑定：

    (defvar foo-tool-bar-map
      (let ((tool-bar-map (make-sparse-keymap)))
        (tool-bar-add-item …)
        …
        tool-bar-map))

    Function: tool-bar-add-item-from-menu command icon &optional map &rest props ¶

此功能便于定义与现有菜单栏绑定一致的工具栏项。command的绑定在map（默认global-map）的菜单栏中查找，修改为icon添加图片规范，查找方式与tool-bar-add-item相同。然后将生成的绑定放置在工具栏地图中，因此仅将此功能用于全局工具栏项目。

map 必须包含绑定到 `[menu-bar]` 的适当键映射。其余的参数 `props` 是要添加到菜单项规范的附加属性列表元素。

    Function: tool-bar-local-item-from-menu command icon in-map &optional from-map &rest props ¶

此函数用于制作非全局工具栏项。像 `tool-bar-add-item-from-menu` 一样使用它，除了 `in-map` 指定要在其中进行定义的本地地图。参数 `from-map` 类似于 `tool-bar-add-item-from-` 的 `map` 参数菜单。

    Variable: auto-resize-tool-bars ¶

如果此变量不为零，则工具栏会自动调整大小以显示所有已定义的工具栏项目——但不大于框架高度的四分之一。

如果值为 `grow-only` ，则工具栏会自动扩展，但不会自动收缩。要收缩工具栏，用户必须通过输入 `Cl` 重新绘制框架。

如果 `Emacs` 是用 `GTK+` 或 `Nextstep` 构建的，工具栏只能显示一行，所以这个变量没有作用。

    Variable: auto-raise-tool-bar-buttons ¶

如果此变量不为零，则当鼠标移到工具栏项目上时，工具栏项目会以凸起的形式显示。

    Variable: tool-bar-button-margin ¶

此变量指定要在工具栏项目周围添加的额外边距。该值是一个整数，像素数。默认值为 `4` 。

    Variable: tool-bar-button-relief ¶

此变量指定工具栏项的阴影宽度。该值是一个整数，像素数。默认值为 `1` 。

    Variable: tool-bar-border ¶

此变量指定在工具栏区域下方绘制的边框的高度。整数将高度指定为像素数。如果该值为 `internal-border-width` （默认）或border-width 之一，则工具栏边框高度对应相应的frame 参数。

您可以使用 `shift` 、control、meta 等修饰符定义单击工具栏项的特殊含义。为此，您可以通过假功能键设置与原始项目相关的附加项目。具体来说，附加项目应使用用于命名原始项目的相同假功能键的修改版本。

因此，如果原始项目是这样定义的，

    (define-key global-map [tool-bar shell]
      '(menu-item "Shell" shell
    	      :image (image :type xpm :file "shell.xpm")))

那么这里是您如何定义使用 `shift` 修饰符单击同一工具栏图像的方法：

    (define-key global-map [tool-bar S-shell] 'some-command)

有关如何将修饰符添加到功能键的更多信息，请参阅功能键。

如果您具有更改工具栏项是否启用的功能，则此状态不一定会立即以视觉方式更新。要强制重新计算工具栏，请调用 `force-mode-line-update` （请参阅模式行格式）。


<a id="org2a97fcd"></a>

### 23.17.7 修改菜单

在现有菜单中插入新项目时，您可能希望将其放在菜单现有项目中的特定位置。如果您使用define-key 添加项目，它通常位于菜单的前面。要将其放在菜单中的其他位置，请使用 `define-key-after` ：

    Function: define-key-after map key binding &optional after ¶

在 `map` 中为 `key` 定义一个绑定，使用 `value` 绑定，就像 `define-key` 一样，但是将 `map` 中的绑定定位在 `event` 的绑定之后。参数键的长度应该是一——一个只有一个元素的向量或字符串。但是 `after` 应该是一个单一的事件类型——一个符号或一个字符，而不是一个序列。新绑定在绑定之后进行。如果 `after` 是 `t` 或被省略，那么新的绑定在最后，在键映射的末尾。但是，在任何继承的键映射之前添加新的绑定。

这是一个例子：

    (define-key-after my-menu [drink]
      '("Drink" . drink-command) 'eat)

为假功能键 `DRINK` 进行绑定，并将其放在 `EAT` 绑定之后。

以下是如何在 `Shell` 模式的 `信号` 菜单中，在项目中断后插入一个名为 `工作` 的项目：

    (define-key-after shell-mode-map [menu-bar signals work]
      '("Work" . work-command) 'break)


<a id="org9249555"></a>

### 23.17.8 简易菜单

以下宏提供了一种方便的方式来定义弹出菜单和/或菜单栏菜单。

    Macro: easy-menu-define symbol maps doc menu ¶

该宏定义了一个弹出菜单和/或菜单栏子菜单，其内容由 `menu` 给出。

如果 `symbol` 不是 `nil` ，它应该是一个符号；那么这个宏将 `symbol` 定义为一个弹出菜单的函数（参见 `Pop-Up Menus` ），其中 `doc` 作为它的文档字符串。符号不应被引用。

无论 `symbol` 的值如何，如果 `maps` 是一个键映射，则菜单将添加到该键映射，作为菜单栏的顶级菜单（请参阅菜单栏）。它也可以是键映射列表，在这种情况下，菜单将单独添加到每个键映射。

menu 的第一个元素必须是一个字符串，用作菜单标签。它后面可以跟任意数量的以下关键字-参数对：

    :filter function

function 必须是一个函数，如果使用一个参数（其他菜单项的列表）调用该函数，则返回要在菜单中显示的实际项目。

    :visible include

include 是一个表达式；如果计算结果为 `nil` ，则菜单不可见。:included 是 `:visible` 的别名。

    :active enable

enable 是一个表达式；如果计算结果为 `nil` ，则菜单不可选择。:enable 是 `:active` 的别名。

menu 中的其余元素是菜单项。

菜单项可以是三个元素的向量，[名称回调启用]。name 是菜单项名称（字符串）。回调是选择项目时要运行的命令或要评估的表达式。enable 是一个表达式；如果它评估为 `nil` ，则禁用该项目以供选择。

或者，菜单项可能具有以下形式：

    [ name callback [ keyword arg ]... ]

其中 `name` 和 `callback` 的含义与上述相同，并且每个可选关键字和 `arg` 对应为以下之一：

    :keys keys

keys 是一个字符串，显示为与菜单项等效的键盘。这通常不需要，因为键盘等效项是自动计算的。键在显示之前使用替换命令键进行扩展（请参阅文档中的替换键绑定）。

    :key-sequence keys

keys 是一个提示，指示将哪个键序列显示为等效键盘，以防命令绑定到多个键序列。如果键未绑定到与此菜单项相同的命令，则无效。

    :active enable

enable 是一个表达式；如果评估为 `nil` ，则该项目不可选择。:enable 是 `:active` 的别名。

    :visible include

include 是一个表达式；如果它的计算结果为 `nil` ，则该项目是不可见的。:included 是 `:visible` 的别名。

    :label form

form 是一个表达式，它被评估以获得一个用作菜单项标签的值（默认为名称）。

    :suffix form

form 是一个动态计算的表达式，其值与菜单项的标签连接。

    :style style

style 是描述菜单项类型的符号；它应该是切换（复选框）或单选（单选按钮）或其他任何内容（意味着普通菜单项）。

    :selected selected

selected 是一个表达式；只要表达式的值为非零，复选框或单选按钮就会被选中。

    :help help

help 是描述菜单项的字符串。

或者，菜单项可以是字符串。然后该字符串作为不可选择的文本出现在菜单中。由破折号组成的字符串显示为分隔符（请参阅菜单分隔符）。

或者，菜单项可以是与菜单格式相同的列表。这是一个子菜单。

这是一个使用 `easy-menu-define` 定义菜单的示例，该菜单类似于菜单栏中示例中定义的菜单：

    (easy-menu-define words-menu global-map
      "Menu for word navigation commands."
      '("Words"
         ["Forward word" forward-word]
         ["Backward word" backward-word]))

